"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/appwrite";
exports.ids = ["vendor-chunks/appwrite"];
exports.modules = {

/***/ "(ssr)/./node_modules/appwrite/dist/esm/sdk.js":
/*!***********************************************!*\
  !*** ./node_modules/appwrite/dist/esm/sdk.js ***!
  \***********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Account: () => (/* binding */ Account),\n/* harmony export */   AppwriteException: () => (/* binding */ AppwriteException),\n/* harmony export */   AuthenticationFactor: () => (/* binding */ AuthenticationFactor),\n/* harmony export */   AuthenticatorType: () => (/* binding */ AuthenticatorType),\n/* harmony export */   Avatars: () => (/* binding */ Avatars),\n/* harmony export */   Browser: () => (/* binding */ Browser),\n/* harmony export */   Client: () => (/* binding */ Client),\n/* harmony export */   Condition: () => (/* binding */ Condition),\n/* harmony export */   CreditCard: () => (/* binding */ CreditCard),\n/* harmony export */   Databases: () => (/* binding */ Databases),\n/* harmony export */   ExecutionMethod: () => (/* binding */ ExecutionMethod),\n/* harmony export */   ExecutionStatus: () => (/* binding */ ExecutionStatus),\n/* harmony export */   ExecutionTrigger: () => (/* binding */ ExecutionTrigger),\n/* harmony export */   Flag: () => (/* binding */ Flag),\n/* harmony export */   Functions: () => (/* binding */ Functions),\n/* harmony export */   Graphql: () => (/* binding */ Graphql),\n/* harmony export */   ID: () => (/* binding */ ID),\n/* harmony export */   ImageFormat: () => (/* binding */ ImageFormat),\n/* harmony export */   ImageGravity: () => (/* binding */ ImageGravity),\n/* harmony export */   Locale: () => (/* binding */ Locale),\n/* harmony export */   Messaging: () => (/* binding */ Messaging),\n/* harmony export */   OAuthProvider: () => (/* binding */ OAuthProvider),\n/* harmony export */   Operator: () => (/* binding */ Operator),\n/* harmony export */   Permission: () => (/* binding */ Permission),\n/* harmony export */   Query: () => (/* binding */ Query),\n/* harmony export */   Realtime: () => (/* binding */ Realtime),\n/* harmony export */   Role: () => (/* binding */ Role),\n/* harmony export */   Storage: () => (/* binding */ Storage),\n/* harmony export */   TablesDB: () => (/* binding */ TablesDB),\n/* harmony export */   Teams: () => (/* binding */ Teams)\n/* harmony export */ });\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\n\n/**\n * Helper class to generate query strings.\n */\nclass Query {\n    /**\n     * Constructor for Query class.\n     *\n     * @param {string} method\n     * @param {AttributesTypes} attribute\n     * @param {QueryTypes} values\n     */\n    constructor(method, attribute, values) {\n        this.method = method;\n        this.attribute = attribute;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    /**\n     * Convert the query object to a JSON string.\n     *\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            attribute: this.attribute,\n            values: this.values,\n        });\n    }\n}\n/**\n * Filter resources where attribute is equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.equal = (attribute, value) => new Query(\"equal\", attribute, value).toString();\n/**\n * Filter resources where attribute is not equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.notEqual = (attribute, value) => new Query(\"notEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThan = (attribute, value) => new Query(\"lessThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is less than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.lessThanEqual = (attribute, value) => new Query(\"lessThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThan = (attribute, value) => new Query(\"greaterThan\", attribute, value).toString();\n/**\n * Filter resources where attribute is greater than or equal to value.\n *\n * @param {string} attribute\n * @param {QueryTypes} value\n * @returns {string}\n */\nQuery.greaterThanEqual = (attribute, value) => new Query(\"greaterThanEqual\", attribute, value).toString();\n/**\n * Filter resources where attribute is null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNull = (attribute) => new Query(\"isNull\", attribute).toString();\n/**\n * Filter resources where attribute is not null.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.isNotNull = (attribute) => new Query(\"isNotNull\", attribute).toString();\n/**\n * Filter resources where attribute is between start and end (inclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.between = (attribute, start, end) => new Query(\"between\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute starts with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.startsWith = (attribute, value) => new Query(\"startsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute ends with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.endsWith = (attribute, value) => new Query(\"endsWith\", attribute, value).toString();\n/**\n * Specify which attributes should be returned by the API call.\n *\n * @param {string[]} attributes\n * @returns {string}\n */\nQuery.select = (attributes) => new Query(\"select\", undefined, attributes).toString();\n/**\n * Filter resources by searching attribute for value.\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.search = (attribute, value) => new Query(\"search\", attribute, value).toString();\n/**\n * Sort results by attribute descending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderDesc = (attribute) => new Query(\"orderDesc\", attribute).toString();\n/**\n * Sort results by attribute ascending.\n *\n * @param {string} attribute\n * @returns {string}\n */\nQuery.orderAsc = (attribute) => new Query(\"orderAsc\", attribute).toString();\n/**\n * Sort results randomly.\n *\n * @returns {string}\n */\nQuery.orderRandom = () => new Query(\"orderRandom\").toString();\n/**\n * Return results after documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorAfter = (documentId) => new Query(\"cursorAfter\", undefined, documentId).toString();\n/**\n * Return results before documentId.\n *\n * @param {string} documentId\n * @returns {string}\n */\nQuery.cursorBefore = (documentId) => new Query(\"cursorBefore\", undefined, documentId).toString();\n/**\n * Return only limit results.\n *\n * @param {number} limit\n * @returns {string}\n */\nQuery.limit = (limit) => new Query(\"limit\", undefined, limit).toString();\n/**\n * Filter resources by skipping the first offset results.\n *\n * @param {number} offset\n * @returns {string}\n */\nQuery.offset = (offset) => new Query(\"offset\", undefined, offset).toString();\n/**\n * Filter resources where attribute contains the specified value.\n *\n * @param {string} attribute\n * @param {string | string[]} value\n * @returns {string}\n */\nQuery.contains = (attribute, value) => new Query(\"contains\", attribute, value).toString();\n/**\n * Filter resources where attribute does not contain the specified value.\n *\n * @param {string} attribute\n * @param {string | any[]} value\n * @returns {string}\n */\nQuery.notContains = (attribute, value) => new Query(\"notContains\", attribute, value).toString();\n/**\n * Filter resources by searching attribute for value (inverse of search).\n * A fulltext index on attribute is required for this query to work.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notSearch = (attribute, value) => new Query(\"notSearch\", attribute, value).toString();\n/**\n * Filter resources where attribute is not between start and end (exclusive).\n *\n * @param {string} attribute\n * @param {string | number} start\n * @param {string | number} end\n * @returns {string}\n */\nQuery.notBetween = (attribute, start, end) => new Query(\"notBetween\", attribute, [start, end]).toString();\n/**\n * Filter resources where attribute does not start with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notStartsWith = (attribute, value) => new Query(\"notStartsWith\", attribute, value).toString();\n/**\n * Filter resources where attribute does not end with value.\n *\n * @param {string} attribute\n * @param {string} value\n * @returns {string}\n */\nQuery.notEndsWith = (attribute, value) => new Query(\"notEndsWith\", attribute, value).toString();\n/**\n * Filter resources where document was created before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdBefore = (value) => Query.lessThan(\"$createdAt\", value);\n/**\n * Filter resources where document was created after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.createdAfter = (value) => Query.greaterThan(\"$createdAt\", value);\n/**\n * Filter resources where document was created between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.createdBetween = (start, end) => Query.between(\"$createdAt\", start, end);\n/**\n * Filter resources where document was updated before date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedBefore = (value) => Query.lessThan(\"$updatedAt\", value);\n/**\n * Filter resources where document was updated after date.\n *\n * @param {string} value\n * @returns {string}\n */\nQuery.updatedAfter = (value) => Query.greaterThan(\"$updatedAt\", value);\n/**\n * Filter resources where document was updated between dates.\n *\n * @param {string} start\n * @param {string} end\n * @returns {string}\n */\nQuery.updatedBetween = (start, end) => Query.between(\"$updatedAt\", start, end);\n/**\n * Combine multiple queries using logical OR operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.or = (queries) => new Query(\"or\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Combine multiple queries using logical AND operator.\n *\n * @param {string[]} queries\n * @returns {string}\n */\nQuery.and = (queries) => new Query(\"and\", undefined, queries.map((query) => JSON.parse(query))).toString();\n/**\n * Filter resources where attribute is at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceEqual = (attribute, values, distance, meters = true) => new Query(\"distanceEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is not at a specific distance from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceNotEqual = (attribute, values, distance, meters = true) => new Query(\"distanceNotEqual\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance greater than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceGreaterThan = (attribute, values, distance, meters = true) => new Query(\"distanceGreaterThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute is at a distance less than the specified value from the given coordinates.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @param {number} distance\n * @param {boolean} meters\n * @returns {string}\n */\nQuery.distanceLessThan = (attribute, values, distance, meters = true) => new Query(\"distanceLessThan\", attribute, [[values, distance, meters]]).toString();\n/**\n * Filter resources where attribute intersects with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.intersects = (attribute, values) => new Query(\"intersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not intersect with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notIntersects = (attribute, values) => new Query(\"notIntersects\", attribute, [values]).toString();\n/**\n * Filter resources where attribute crosses the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.crosses = (attribute, values) => new Query(\"crosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not cross the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notCrosses = (attribute, values) => new Query(\"notCrosses\", attribute, [values]).toString();\n/**\n * Filter resources where attribute overlaps with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.overlaps = (attribute, values) => new Query(\"overlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not overlap with the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notOverlaps = (attribute, values) => new Query(\"notOverlaps\", attribute, [values]).toString();\n/**\n * Filter resources where attribute touches the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.touches = (attribute, values) => new Query(\"touches\", attribute, [values]).toString();\n/**\n * Filter resources where attribute does not touch the given geometry.\n *\n * @param {string} attribute\n * @param {any[]} values\n * @returns {string}\n */\nQuery.notTouches = (attribute, values) => new Query(\"notTouches\", attribute, [values]).toString();\n\n/**\n * Exception thrown by the  package\n */\nclass AppwriteException extends Error {\n    /**\n     * Initializes a Appwrite Exception.\n     *\n     * @param {string} message - The error message.\n     * @param {number} code - The error code. Default is 0.\n     * @param {string} type - The error type. Default is an empty string.\n     * @param {string} response - The response string. Default is an empty string.\n     */\n    constructor(message, code = 0, type = '', response = '') {\n        super(message);\n        this.name = 'AppwriteException';\n        this.message = message;\n        this.code = code;\n        this.type = type;\n        this.response = response;\n    }\n}\n/**\n * Client that handles requests to Appwrite\n */\nclass Client {\n    constructor() {\n        /**\n         * Holds configuration such as project.\n         */\n        this.config = {\n            endpoint: 'https://cloud.appwrite.io/v1',\n            endpointRealtime: '',\n            project: '',\n            jwt: '',\n            locale: '',\n            session: '',\n            devkey: '',\n        };\n        /**\n         * Custom headers for API requests.\n         */\n        this.headers = {\n            'x-sdk-name': 'Web',\n            'x-sdk-platform': 'client',\n            'x-sdk-language': 'web',\n            'x-sdk-version': '21.4.0',\n            'X-Appwrite-Response-Format': '1.8.0',\n        };\n        this.realtime = {\n            socket: undefined,\n            timeout: undefined,\n            heartbeat: undefined,\n            url: '',\n            channels: new Set(),\n            subscriptions: new Map(),\n            subscriptionsCounter: 0,\n            reconnect: true,\n            reconnectAttempts: 0,\n            lastMessage: undefined,\n            connect: () => {\n                clearTimeout(this.realtime.timeout);\n                this.realtime.timeout = window === null || window === void 0 ? void 0 : window.setTimeout(() => {\n                    this.realtime.createSocket();\n                }, 50);\n            },\n            getTimeout: () => {\n                switch (true) {\n                    case this.realtime.reconnectAttempts < 5:\n                        return 1000;\n                    case this.realtime.reconnectAttempts < 15:\n                        return 5000;\n                    case this.realtime.reconnectAttempts < 100:\n                        return 10000;\n                    default:\n                        return 60000;\n                }\n            },\n            createHeartbeat: () => {\n                if (this.realtime.heartbeat) {\n                    clearTimeout(this.realtime.heartbeat);\n                }\n                this.realtime.heartbeat = window === null || window === void 0 ? void 0 : window.setInterval(() => {\n                    var _a;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.send(JSON.stringify({\n                        type: 'ping'\n                    }));\n                }, 20000);\n            },\n            createSocket: () => {\n                var _a, _b, _c;\n                if (this.realtime.channels.size < 1) {\n                    this.realtime.reconnect = false;\n                    (_a = this.realtime.socket) === null || _a === void 0 ? void 0 : _a.close();\n                    return;\n                }\n                const channels = new URLSearchParams();\n                if (this.config.project) {\n                    channels.set('project', this.config.project);\n                }\n                this.realtime.channels.forEach(channel => {\n                    channels.append('channels[]', channel);\n                });\n                const url = this.config.endpointRealtime + '/realtime?' + channels.toString();\n                if (url !== this.realtime.url || // Check if URL is present\n                    !this.realtime.socket || // Check if WebSocket has not been created\n                    ((_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.readyState) > WebSocket.OPEN // Check if WebSocket is CLOSING (3) or CLOSED (4)\n                ) {\n                    if (this.realtime.socket &&\n                        ((_c = this.realtime.socket) === null || _c === void 0 ? void 0 : _c.readyState) < WebSocket.CLOSING // Close WebSocket if it is CONNECTING (0) or OPEN (1)\n                    ) {\n                        this.realtime.reconnect = false;\n                        this.realtime.socket.close();\n                    }\n                    this.realtime.url = url;\n                    this.realtime.socket = new WebSocket(url);\n                    this.realtime.socket.addEventListener('message', this.realtime.onMessage);\n                    this.realtime.socket.addEventListener('open', _event => {\n                        this.realtime.reconnectAttempts = 0;\n                        this.realtime.createHeartbeat();\n                    });\n                    this.realtime.socket.addEventListener('close', event => {\n                        var _a, _b, _c;\n                        if (!this.realtime.reconnect ||\n                            (((_b = (_a = this.realtime) === null || _a === void 0 ? void 0 : _a.lastMessage) === null || _b === void 0 ? void 0 : _b.type) === 'error' && // Check if last message was of type error\n                                ((_c = this.realtime) === null || _c === void 0 ? void 0 : _c.lastMessage.data).code === 1008 // Check for policy violation 1008\n                            )) {\n                            this.realtime.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.realtime.getTimeout();\n                        console.error(`Realtime got disconnected. Reconnect will be attempted in ${timeout / 1000} seconds.`, event.reason);\n                        setTimeout(() => {\n                            this.realtime.reconnectAttempts++;\n                            this.realtime.createSocket();\n                        }, timeout);\n                    });\n                }\n            },\n            onMessage: (event) => {\n                var _a, _b;\n                try {\n                    const message = JSON.parse(event.data);\n                    this.realtime.lastMessage = message;\n                    switch (message.type) {\n                        case 'connected':\n                            let session = this.config.session;\n                            if (!session) {\n                                const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.config.project}`];\n                            }\n                            const messageData = message.data;\n                            if (session && !messageData.user) {\n                                (_b = this.realtime.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                                    type: 'authentication',\n                                    data: {\n                                        session\n                                    }\n                                }));\n                            }\n                            break;\n                        case 'event':\n                            let data = message.data;\n                            if (data === null || data === void 0 ? void 0 : data.channels) {\n                                const isSubscribed = data.channels.some(channel => this.realtime.channels.has(channel));\n                                if (!isSubscribed)\n                                    return;\n                                this.realtime.subscriptions.forEach(subscription => {\n                                    if (data.channels.some(channel => subscription.channels.includes(channel))) {\n                                        setTimeout(() => subscription.callback(data));\n                                    }\n                                });\n                            }\n                            break;\n                        case 'pong':\n                            break; // Handle pong response if needed\n                        case 'error':\n                            throw message.data;\n                        default:\n                            break;\n                    }\n                }\n                catch (e) {\n                    console.error(e);\n                }\n            },\n            cleanUp: channels => {\n                this.realtime.channels.forEach(channel => {\n                    if (channels.includes(channel)) {\n                        let found = Array.from(this.realtime.subscriptions).some(([_key, subscription]) => {\n                            return subscription.channels.includes(channel);\n                        });\n                        if (!found) {\n                            this.realtime.channels.delete(channel);\n                        }\n                    }\n                });\n            }\n        };\n    }\n    /**\n     * Set Endpoint\n     *\n     * Your project endpoint\n     *\n     * @param {string} endpoint\n     *\n     * @returns {this}\n     */\n    setEndpoint(endpoint) {\n        if (!endpoint.startsWith('http://') && !endpoint.startsWith('https://')) {\n            throw new AppwriteException('Invalid endpoint URL: ' + endpoint);\n        }\n        this.config.endpoint = endpoint;\n        this.config.endpointRealtime = endpoint.replace('https://', 'wss://').replace('http://', 'ws://');\n        return this;\n    }\n    /**\n     * Set Realtime Endpoint\n     *\n     * @param {string} endpointRealtime\n     *\n     * @returns {this}\n     */\n    setEndpointRealtime(endpointRealtime) {\n        if (!endpointRealtime.startsWith('ws://') && !endpointRealtime.startsWith('wss://')) {\n            throw new AppwriteException('Invalid realtime endpoint URL: ' + endpointRealtime);\n        }\n        this.config.endpointRealtime = endpointRealtime;\n        return this;\n    }\n    /**\n     * Set Project\n     *\n     * Your project ID\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setProject(value) {\n        this.headers['X-Appwrite-Project'] = value;\n        this.config.project = value;\n        return this;\n    }\n    /**\n     * Set JWT\n     *\n     * Your secret JSON Web Token\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setJWT(value) {\n        this.headers['X-Appwrite-JWT'] = value;\n        this.config.jwt = value;\n        return this;\n    }\n    /**\n     * Set Locale\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setLocale(value) {\n        this.headers['X-Appwrite-Locale'] = value;\n        this.config.locale = value;\n        return this;\n    }\n    /**\n     * Set Session\n     *\n     * The user session to authenticate with\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setSession(value) {\n        this.headers['X-Appwrite-Session'] = value;\n        this.config.session = value;\n        return this;\n    }\n    /**\n     * Set DevKey\n     *\n     * Your secret dev API key\n     *\n     * @param value string\n     *\n     * @return {this}\n     */\n    setDevKey(value) {\n        this.headers['X-Appwrite-Dev-Key'] = value;\n        this.config.devkey = value;\n        return this;\n    }\n    /**\n     * Subscribes to Appwrite events and passes you the payload in realtime.\n     *\n     * @deprecated Use the Realtime service instead.\n     * @see Realtime\n     *\n     * @param {string|string[]} channels\n     * Channel to subscribe - pass a single channel as a string or multiple with an array of strings.\n     *\n     * Possible channels are:\n     * - account\n     * - collections\n     * - collections.[ID]\n     * - collections.[ID].documents\n     * - documents\n     * - documents.[ID]\n     * - files\n     * - files.[ID]\n     * - executions\n     * - executions.[ID]\n     * - functions.[ID]\n     * - teams\n     * - teams.[ID]\n     * - memberships\n     * - memberships.[ID]\n     * @param {(payload: RealtimeMessage) => void} callback Is called on every realtime update.\n     * @returns {() => void} Unsubscribes from events.\n     */\n    subscribe(channels, callback) {\n        let channelArray = typeof channels === 'string' ? [channels] : channels;\n        channelArray.forEach(channel => this.realtime.channels.add(channel));\n        const counter = this.realtime.subscriptionsCounter++;\n        this.realtime.subscriptions.set(counter, {\n            channels: channelArray,\n            callback\n        });\n        this.realtime.connect();\n        return () => {\n            this.realtime.subscriptions.delete(counter);\n            this.realtime.cleanUp(channelArray);\n            this.realtime.connect();\n        };\n    }\n    prepareRequest(method, url, headers = {}, params = {}) {\n        method = method.toUpperCase();\n        headers = Object.assign({}, this.headers, headers);\n        if (typeof window !== 'undefined' && window.localStorage) {\n            const cookieFallback = window.localStorage.getItem('cookieFallback');\n            if (cookieFallback) {\n                headers['X-Fallback-Cookies'] = cookieFallback;\n            }\n        }\n        let options = {\n            method,\n            headers,\n        };\n        if (headers['X-Appwrite-Dev-Key'] === undefined) {\n            options.credentials = 'include';\n        }\n        if (method === 'GET') {\n            for (const [key, value] of Object.entries(Client.flatten(params))) {\n                url.searchParams.append(key, value);\n            }\n        }\n        else {\n            switch (headers['content-type']) {\n                case 'application/json':\n                    options.body = JSON.stringify(params);\n                    break;\n                case 'multipart/form-data':\n                    const formData = new FormData();\n                    for (const [key, value] of Object.entries(params)) {\n                        if (value instanceof File) {\n                            formData.append(key, value, value.name);\n                        }\n                        else if (Array.isArray(value)) {\n                            for (const nestedValue of value) {\n                                formData.append(`${key}[]`, nestedValue);\n                            }\n                        }\n                        else {\n                            formData.append(key, value);\n                        }\n                    }\n                    options.body = formData;\n                    delete headers['content-type'];\n                    break;\n            }\n        }\n        return { uri: url.toString(), options };\n    }\n    chunkedUpload(method, url, headers = {}, originalPayload = {}, onProgress) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const [fileParam, file] = (_a = Object.entries(originalPayload).find(([_, value]) => value instanceof File)) !== null && _a !== void 0 ? _a : [];\n            if (!file || !fileParam) {\n                throw new Error('File not found in payload');\n            }\n            if (file.size <= Client.CHUNK_SIZE) {\n                return yield this.call(method, url, headers, originalPayload);\n            }\n            let start = 0;\n            let response = null;\n            while (start < file.size) {\n                let end = start + Client.CHUNK_SIZE; // Prepare end for the next chunk\n                if (end >= file.size) {\n                    end = file.size; // Adjust for the last chunk to include the last byte\n                }\n                headers['content-range'] = `bytes ${start}-${end - 1}/${file.size}`;\n                const chunk = file.slice(start, end);\n                let payload = Object.assign({}, originalPayload);\n                payload[fileParam] = new File([chunk], file.name);\n                response = yield this.call(method, url, headers, payload);\n                if (onProgress && typeof onProgress === 'function') {\n                    onProgress({\n                        $id: response.$id,\n                        progress: Math.round((end / file.size) * 100),\n                        sizeUploaded: end,\n                        chunksTotal: Math.ceil(file.size / Client.CHUNK_SIZE),\n                        chunksUploaded: Math.ceil(end / Client.CHUNK_SIZE)\n                    });\n                }\n                if (response && response.$id) {\n                    headers['x-appwrite-id'] = response.$id;\n                }\n                start = end;\n            }\n            return response;\n        });\n    }\n    ping() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.call('GET', new URL(this.config.endpoint + '/ping'));\n        });\n    }\n    call(method, url, headers = {}, params = {}, responseType = 'json') {\n        var _a, _b;\n        return __awaiter(this, void 0, void 0, function* () {\n            const { uri, options } = this.prepareRequest(method, url, headers, params);\n            let data = null;\n            const response = yield fetch(uri, options);\n            // type opaque: No-CORS, different-origin response (CORS-issue)\n            if (response.type === 'opaque') {\n                throw new AppwriteException(`Invalid Origin. Register your new client (${window.location.host}) as a new Web platform on your project console dashboard`, 403, \"forbidden\", \"\");\n            }\n            const warnings = response.headers.get('x-appwrite-warning');\n            if (warnings) {\n                warnings.split(';').forEach((warning) => console.warn('Warning: ' + warning));\n            }\n            if ((_a = response.headers.get('content-type')) === null || _a === void 0 ? void 0 : _a.includes('application/json')) {\n                data = yield response.json();\n            }\n            else if (responseType === 'arrayBuffer') {\n                data = yield response.arrayBuffer();\n            }\n            else {\n                data = {\n                    message: yield response.text()\n                };\n            }\n            if (400 <= response.status) {\n                let responseText = '';\n                if (((_b = response.headers.get('content-type')) === null || _b === void 0 ? void 0 : _b.includes('application/json')) || responseType === 'arrayBuffer') {\n                    responseText = JSON.stringify(data);\n                }\n                else {\n                    responseText = data === null || data === void 0 ? void 0 : data.message;\n                }\n                throw new AppwriteException(data === null || data === void 0 ? void 0 : data.message, response.status, data === null || data === void 0 ? void 0 : data.type, responseText);\n            }\n            const cookieFallback = response.headers.get('X-Fallback-Cookies');\n            if (typeof window !== 'undefined' && window.localStorage && cookieFallback) {\n                window.console.warn('Appwrite is using localStorage for session management. Increase your security by adding a custom domain as your API endpoint.');\n                window.localStorage.setItem('cookieFallback', cookieFallback);\n            }\n            return data;\n        });\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Client.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\nClient.CHUNK_SIZE = 1024 * 1024 * 5;\n\nclass Service {\n    constructor(client) {\n        this.client = client;\n    }\n    static flatten(data, prefix = '') {\n        let output = {};\n        for (const [key, value] of Object.entries(data)) {\n            let finalKey = prefix ? prefix + '[' + key + ']' : key;\n            if (Array.isArray(value)) {\n                output = Object.assign(Object.assign({}, output), Service.flatten(value, finalKey));\n            }\n            else {\n                output[finalKey] = value;\n            }\n        }\n        return output;\n    }\n}\n/**\n * The size for chunked uploads in bytes.\n */\nService.CHUNK_SIZE = 5 * 1024 * 1024; // 5MB\n\nclass Account {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    get() {\n        const apiPath = '/account';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                password: rest[1],\n                name: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const password = params.password;\n        const name = params.name;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateEmail(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    listIdentities(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                total: rest[0]\n            };\n        }\n        const queries = params.queries;\n        const total = params.total;\n        const apiPath = '/account/identities';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    deleteIdentity(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                identityId: paramsOrFirst\n            };\n        }\n        const identityId = params.identityId;\n        if (typeof identityId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identityId\"');\n        }\n        const apiPath = '/account/identities/{identityId}'.replace('{identityId}', identityId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to create a JSON Web Token. You can use the resulting JWT to authenticate on behalf of the current user when working with the Appwrite server-side API and SDKs. The JWT secret is valid for 15 minutes from its creation and will be invalid if the user will logout in that time frame.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Jwt>}\n     */\n    createJWT() {\n        const apiPath = '/account/jwts';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listLogs(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                total: rest[0]\n            };\n        }\n        const queries = params.queries;\n        const total = params.total;\n        const apiPath = '/account/logs';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMFA(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                mfa: paramsOrFirst\n            };\n        }\n        const mfa = params.mfa;\n        if (typeof mfa === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"mfa\"');\n        }\n        const apiPath = '/account/mfa';\n        const payload = {};\n        if (typeof mfa !== 'undefined') {\n            payload['mfa'] = mfa;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAAuthenticator(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const type = params.type;\n        const otp = params.otp;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteMfaAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    deleteMFAAuthenticator(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'type' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                type: paramsOrFirst\n            };\n        }\n        const type = params.type;\n        if (typeof type === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"type\"');\n        }\n        const apiPath = '/account/mfa/authenticators/{type}'.replace('{type}', type);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createMfaChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMFAChallenge(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'factor' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                factor: paramsOrFirst\n            };\n        }\n        const factor = params.factor;\n        if (typeof factor === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"factor\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof factor !== 'undefined') {\n            payload['factor'] = factor;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMfaChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateMFAChallenge(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                challengeId: paramsOrFirst,\n                otp: rest[0]\n            };\n        }\n        const challengeId = params.challengeId;\n        const otp = params.otp;\n        if (typeof challengeId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"challengeId\"');\n        }\n        if (typeof otp === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"otp\"');\n        }\n        const apiPath = '/account/mfa/challenge';\n        const payload = {};\n        if (typeof challengeId !== 'undefined') {\n            payload['challengeId'] = challengeId;\n        }\n        if (typeof otp !== 'undefined') {\n            payload['otp'] = otp;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.listMFAFactors` instead.\n     */\n    listMfaFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List the factors available on the account to be used as a MFA challange.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaFactors>}\n     */\n    listMFAFactors() {\n        const apiPath = '/account/mfa/factors';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.getMFARecoveryCodes` instead.\n     */\n    getMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Get recovery codes that can be used as backup for MFA flow. Before getting codes, they must be generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to read recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    getMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.createMFARecoveryCodes` instead.\n     */\n    createMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Generate recovery codes as backup for MFA flow. It's recommended to generate and show then immediately after user successfully adds their authehticator. Recovery codes can be used as a MFA verification type in [createMfaChallenge](/docs/references/cloud/client-web/account#createMfaChallenge) method.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    createMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     * @deprecated This API has been deprecated since 1.8.0. Please use `Account.updateMFARecoveryCodes` instead.\n     */\n    updateMfaRecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Regenerate recovery codes that can be used as backup for MFA flow. Before regenerating codes, they must be first generated using [createMfaRecoveryCodes](/docs/references/cloud/client-web/account#createMfaRecoveryCodes) method. An OTP challenge is required to regenreate recovery codes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.MfaRecoveryCodes>}\n     */\n    updateMFARecoveryCodes() {\n        const apiPath = '/account/mfa/recovery-codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst\n            };\n        }\n        const name = params.name;\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/account/name';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePassword(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                password: paramsOrFirst,\n                oldPassword: rest[0]\n            };\n        }\n        const password = params.password;\n        const oldPassword = params.oldPassword;\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/password';\n        const payload = {};\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        if (typeof oldPassword !== 'undefined') {\n            payload['oldPassword'] = oldPassword;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    updatePhone(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                phone: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const phone = params.phone;\n        const password = params.password;\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/phone';\n        const payload = {};\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the preferences as a key-value object for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Preferences>}\n     */\n    getPrefs() {\n        const apiPath = '/account/prefs';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'prefs' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                prefs: paramsOrFirst\n            };\n        }\n        const prefs = params.prefs;\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/account/prefs';\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                url: rest[0]\n            };\n        }\n        const email = params.email;\n        const url = params.url;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateRecovery(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0],\n                password: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        const password = params.password;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/recovery';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Get the list of active sessions across different devices for the currently logged in user.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.SessionList>}\n     */\n    listSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * Delete all sessions from the user account and remove any sessions cookies from the end client.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<{}>}\n     */\n    deleteSessions() {\n        const apiPath = '/account/sessions';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to allow a new user to register an anonymous account in your project. This route will also create a new session for the user. To allow the new user to convert an anonymous account to a normal account, you need to update its [email and password](https://appwrite.io/docs/references/cloud/client-web/account#updateEmail) or create an [OAuth2 session](https://appwrite.io/docs/references/cloud/client-web/account#CreateOAuth2Session).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Session>}\n     */\n    createAnonymousSession() {\n        const apiPath = '/account/sessions/anonymous';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createEmailPasswordSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                email: paramsOrFirst,\n                password: rest[0]\n            };\n        }\n        const email = params.email;\n        const password = params.password;\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        if (typeof password === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"password\"');\n        }\n        const apiPath = '/account/sessions/email';\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof password !== 'undefined') {\n            payload['password'] = password;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateMagicURLSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createOAuth2Session(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/sessions/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    updatePhoneSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    createSession(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/sessions/token';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteSession(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                sessionId: paramsOrFirst\n            };\n        }\n        const sessionId = params.sessionId;\n        if (typeof sessionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"sessionId\"');\n        }\n        const apiPath = '/account/sessions/{sessionId}'.replace('{sessionId}', sessionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    /**\n     * Block the currently logged in user account. Behind the scene, the user record is not deleted but permanently blocked from any access. To completely delete a user, use the Users API instead.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.User<Preferences>>}\n     */\n    updateStatus() {\n        const apiPath = '/account/status';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    createPushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0],\n                providerId: rest[1]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        const providerId = params.providerId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/push';\n        const payload = {};\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        if (typeof providerId !== 'undefined') {\n            payload['providerId'] = providerId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePushTarget(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst,\n                identifier: rest[0]\n            };\n        }\n        const targetId = params.targetId;\n        const identifier = params.identifier;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        if (typeof identifier === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"identifier\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        if (typeof identifier !== 'undefined') {\n            payload['identifier'] = identifier;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deletePushTarget(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                targetId: paramsOrFirst\n            };\n        }\n        const targetId = params.targetId;\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/account/targets/{targetId}/push'.replace('{targetId}', targetId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createEmailToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                phrase: rest[1]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createMagicURLToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                email: rest[0],\n                url: rest[1],\n                phrase: rest[2]\n            };\n        }\n        const userId = params.userId;\n        const email = params.email;\n        const url = params.url;\n        const phrase = params.phrase;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof email === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"email\"');\n        }\n        const apiPath = '/account/tokens/magic-url';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof phrase !== 'undefined') {\n            payload['phrase'] = phrase;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createOAuth2Token(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'provider' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                provider: paramsOrFirst,\n                success: rest[0],\n                failure: rest[1],\n                scopes: rest[2]\n            };\n        }\n        const provider = params.provider;\n        const success = params.success;\n        const failure = params.failure;\n        const scopes = params.scopes;\n        if (typeof provider === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"provider\"');\n        }\n        const apiPath = '/account/tokens/oauth2/{provider}'.replace('{provider}', provider);\n        const payload = {};\n        if (typeof success !== 'undefined') {\n            payload['success'] = success;\n        }\n        if (typeof failure !== 'undefined') {\n            payload['failure'] = failure;\n        }\n        if (typeof scopes !== 'undefined') {\n            payload['scopes'] = scopes;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        if (typeof window !== 'undefined' && (window === null || window === void 0 ? void 0 : window.location)) {\n            window.location.href = uri.toString();\n            return;\n        }\n        else {\n            return uri.toString();\n        }\n    }\n    createPhoneToken(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                phone: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const phone = params.phone;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof phone === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"phone\"');\n        }\n        const apiPath = '/account/tokens/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createEmailVerification(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    createVerification(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updateEmailVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/email';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    /**\n     * Use this endpoint to send a verification SMS to the currently logged in user. This endpoint is meant for use after updating a user's phone number using the [accountUpdatePhone](https://appwrite.io/docs/references/cloud/client-web/account#updatePhone) endpoint. Learn more about how to [complete the verification process](https://appwrite.io/docs/references/cloud/client-web/account#updatePhoneVerification). The verification code sent to the user's phone number is valid for 15 minutes.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Token>}\n     */\n    createPhoneVerification() {\n        const apiPath = '/account/verifications/phone';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    updatePhoneVerification(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                userId: paramsOrFirst,\n                secret: rest[0]\n            };\n        }\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/account/verifications/phone';\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\nclass Avatars {\n    constructor(client) {\n        this.client = client;\n    }\n    getBrowser(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/browsers/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getCreditCard(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/credit-cards/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFavicon(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst\n            };\n        }\n        const url = params.url;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/favicon';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFlag(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'code' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                code: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                quality: rest[2]\n            };\n        }\n        const code = params.code;\n        const width = params.width;\n        const height = params.height;\n        const quality = params.quality;\n        if (typeof code === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"code\"');\n        }\n        const apiPath = '/avatars/flags/{code}'.replace('{code}', code);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getImage(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                url: paramsOrFirst,\n                width: rest[0],\n                height: rest[1]\n            };\n        }\n        const url = params.url;\n        const width = params.width;\n        const height = params.height;\n        if (typeof url === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"url\"');\n        }\n        const apiPath = '/avatars/image';\n        const payload = {};\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getInitials(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                name: paramsOrFirst,\n                width: rest[0],\n                height: rest[1],\n                background: rest[2]\n            };\n        }\n        const name = params.name;\n        const width = params.width;\n        const height = params.height;\n        const background = params.background;\n        const apiPath = '/avatars/initials';\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getQR(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                text: paramsOrFirst,\n                size: rest[0],\n                margin: rest[1],\n                download: rest[2]\n            };\n        }\n        const text = params.text;\n        const size = params.size;\n        const margin = params.margin;\n        const download = params.download;\n        if (typeof text === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"text\"');\n        }\n        const apiPath = '/avatars/qr';\n        const payload = {};\n        if (typeof text !== 'undefined') {\n            payload['text'] = text;\n        }\n        if (typeof size !== 'undefined') {\n            payload['size'] = size;\n        }\n        if (typeof margin !== 'undefined') {\n            payload['margin'] = margin;\n        }\n        if (typeof download !== 'undefined') {\n            payload['download'] = download;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass Databases {\n    constructor(client) {\n        this.client = client;\n    }\n    listTransactions(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/databases/transactions';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createTransaction(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                ttl: paramsOrFirst\n            };\n        }\n        const ttl = params.ttl;\n        const apiPath = '/databases/transactions';\n        const payload = {};\n        if (typeof ttl !== 'undefined') {\n            payload['ttl'] = ttl;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateTransaction(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                commit: rest[0],\n                rollback: rest[1]\n            };\n        }\n        const transactionId = params.transactionId;\n        const commit = params.commit;\n        const rollback = params.rollback;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof commit !== 'undefined') {\n            payload['commit'] = commit;\n        }\n        if (typeof rollback !== 'undefined') {\n            payload['rollback'] = rollback;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createOperations(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                operations: rest[0]\n            };\n        }\n        const transactionId = params.transactionId;\n        const operations = params.operations;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/databases/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof operations !== 'undefined') {\n            payload['operations'] = operations;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listDocuments(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                queries: rest[1],\n                transactionId: rest[2],\n                total: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        const total = params.total;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId);\n        const payload = {};\n        if (typeof documentId !== 'undefined') {\n            payload['documentId'] = documentId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                queries: rest[2],\n                transactionId: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteDocument(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                transactionId: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId);\n        const payload = {};\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                min: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const min = params.min;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/decrement'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementDocumentAttribute(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                collectionId: rest[0],\n                documentId: rest[1],\n                attribute: rest[2],\n                value: rest[3],\n                max: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const collectionId = params.collectionId;\n        const documentId = params.documentId;\n        const attribute = params.attribute;\n        const value = params.value;\n        const max = params.max;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof collectionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"collectionId\"');\n        }\n        if (typeof documentId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"documentId\"');\n        }\n        if (typeof attribute === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"attribute\"');\n        }\n        const apiPath = '/databases/{databaseId}/collections/{collectionId}/documents/{documentId}/{attribute}/increment'.replace('{databaseId}', databaseId).replace('{collectionId}', collectionId).replace('{documentId}', documentId).replace('{attribute}', attribute);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Functions {\n    constructor(client) {\n        this.client = client;\n    }\n    listExecutions(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                queries: rest[0],\n                total: rest[1]\n            };\n        }\n        const functionId = params.functionId;\n        const queries = params.queries;\n        const total = params.total;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                body: rest[0],\n                async: rest[1],\n                xpath: rest[2],\n                method: rest[3],\n                headers: rest[4],\n                scheduledAt: rest[5]\n            };\n        }\n        const functionId = params.functionId;\n        const body = params.body;\n        const async = params.async;\n        const xpath = params.xpath;\n        const method = params.method;\n        const headers = params.headers;\n        const scheduledAt = params.scheduledAt;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions'.replace('{functionId}', functionId);\n        const payload = {};\n        if (typeof body !== 'undefined') {\n            payload['body'] = body;\n        }\n        if (typeof async !== 'undefined') {\n            payload['async'] = async;\n        }\n        if (typeof xpath !== 'undefined') {\n            payload['path'] = xpath;\n        }\n        if (typeof method !== 'undefined') {\n            payload['method'] = method;\n        }\n        if (typeof headers !== 'undefined') {\n            payload['headers'] = headers;\n        }\n        if (typeof scheduledAt !== 'undefined') {\n            payload['scheduledAt'] = scheduledAt;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getExecution(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                functionId: paramsOrFirst,\n                executionId: rest[0]\n            };\n        }\n        const functionId = params.functionId;\n        const executionId = params.executionId;\n        if (typeof functionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"functionId\"');\n        }\n        if (typeof executionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"executionId\"');\n        }\n        const apiPath = '/functions/{functionId}/executions/{executionId}'.replace('{functionId}', functionId).replace('{executionId}', executionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Graphql {\n    constructor(client) {\n        this.client = client;\n    }\n    query(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    mutation(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst) && 'query' in paramsOrFirst)) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                query: paramsOrFirst\n            };\n        }\n        const query = params.query;\n        if (typeof query === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"query\"');\n        }\n        const apiPath = '/graphql/mutation';\n        const payload = {};\n        if (typeof query !== 'undefined') {\n            payload['query'] = query;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'x-sdk-graphql': 'true',\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n}\n\nclass Locale {\n    constructor(client) {\n        this.client = client;\n    }\n    /**\n     * Get the current user location based on IP. Returns an object with user country code, country name, continent name, continent code, ip address and suggested currency. You can use the locale header to get the data in a supported language.\n     *\n     * ([IP Geolocation by DB-IP](https://db-ip.com))\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.Locale>}\n     */\n    get() {\n        const apiPath = '/locale';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all locale codes in [ISO 639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes).\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LocaleCodeList>}\n     */\n    listCodes() {\n        const apiPath = '/locale/codes';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all continents. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.ContinentList>}\n     */\n    listContinents() {\n        const apiPath = '/locale/continents';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountries() {\n        const apiPath = '/locale/countries';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries that are currently members of the EU. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CountryList>}\n     */\n    listCountriesEU() {\n        const apiPath = '/locale/countries/eu';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all countries phone codes. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.PhoneList>}\n     */\n    listCountriesPhones() {\n        const apiPath = '/locale/countries/phones';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all currencies, including currency symbol, name, plural, and decimal digits for all major and minor currencies. You can use the locale header to get the data in a supported language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.CurrencyList>}\n     */\n    listCurrencies() {\n        const apiPath = '/locale/currencies';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    /**\n     * List of all languages classified by ISO 639-1 including 2-letter code, name in English, and name in the respective language.\n     *\n     * @throws {AppwriteException}\n     * @returns {Promise<Models.LanguageList>}\n     */\n    listLanguages() {\n        const apiPath = '/locale/languages';\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n}\n\nclass Messaging {\n    constructor(client) {\n        this.client = client;\n    }\n    createSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0],\n                targetId: rest[1]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        const targetId = params.targetId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        if (typeof targetId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"targetId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers'.replace('{topicId}', topicId);\n        const payload = {};\n        if (typeof subscriberId !== 'undefined') {\n            payload['subscriberId'] = subscriberId;\n        }\n        if (typeof targetId !== 'undefined') {\n            payload['targetId'] = targetId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    deleteSubscriber(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                topicId: paramsOrFirst,\n                subscriberId: rest[0]\n            };\n        }\n        const topicId = params.topicId;\n        const subscriberId = params.subscriberId;\n        if (typeof topicId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"topicId\"');\n        }\n        if (typeof subscriberId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"subscriberId\"');\n        }\n        const apiPath = '/messaging/topics/{topicId}/subscribers/{subscriberId}'.replace('{topicId}', topicId).replace('{subscriberId}', subscriberId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n}\n\nclass Storage {\n    constructor(client) {\n        this.client = client;\n    }\n    listFiles(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1],\n                total: rest[2]\n            };\n        }\n        const bucketId = params.bucketId;\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createFile(paramsOrFirst, ...rest) {\n        let params;\n        let onProgress;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n            onProgress = paramsOrFirst === null || paramsOrFirst === void 0 ? void 0 : paramsOrFirst.onProgress;\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                file: rest[1],\n                permissions: rest[2]\n            };\n            onProgress = rest[3];\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const file = params.file;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        if (typeof file === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"file\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files'.replace('{bucketId}', bucketId);\n        const payload = {};\n        if (typeof fileId !== 'undefined') {\n            payload['fileId'] = fileId;\n        }\n        if (typeof file !== 'undefined') {\n            payload['file'] = file;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'multipart/form-data',\n        };\n        return this.client.chunkedUpload('post', uri, apiHeaders, payload, onProgress);\n    }\n    getFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                name: rest[1],\n                permissions: rest[2]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const name = params.name;\n        const permissions = params.permissions;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    deleteFile(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    getFileDownload(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/download'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFilePreview(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                width: rest[1],\n                height: rest[2],\n                gravity: rest[3],\n                quality: rest[4],\n                borderWidth: rest[5],\n                borderColor: rest[6],\n                borderRadius: rest[7],\n                opacity: rest[8],\n                rotation: rest[9],\n                background: rest[10],\n                output: rest[11],\n                token: rest[12]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const width = params.width;\n        const height = params.height;\n        const gravity = params.gravity;\n        const quality = params.quality;\n        const borderWidth = params.borderWidth;\n        const borderColor = params.borderColor;\n        const borderRadius = params.borderRadius;\n        const opacity = params.opacity;\n        const rotation = params.rotation;\n        const background = params.background;\n        const output = params.output;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/preview'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof width !== 'undefined') {\n            payload['width'] = width;\n        }\n        if (typeof height !== 'undefined') {\n            payload['height'] = height;\n        }\n        if (typeof gravity !== 'undefined') {\n            payload['gravity'] = gravity;\n        }\n        if (typeof quality !== 'undefined') {\n            payload['quality'] = quality;\n        }\n        if (typeof borderWidth !== 'undefined') {\n            payload['borderWidth'] = borderWidth;\n        }\n        if (typeof borderColor !== 'undefined') {\n            payload['borderColor'] = borderColor;\n        }\n        if (typeof borderRadius !== 'undefined') {\n            payload['borderRadius'] = borderRadius;\n        }\n        if (typeof opacity !== 'undefined') {\n            payload['opacity'] = opacity;\n        }\n        if (typeof rotation !== 'undefined') {\n            payload['rotation'] = rotation;\n        }\n        if (typeof background !== 'undefined') {\n            payload['background'] = background;\n        }\n        if (typeof output !== 'undefined') {\n            payload['output'] = output;\n        }\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n    getFileView(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                bucketId: paramsOrFirst,\n                fileId: rest[0],\n                token: rest[1]\n            };\n        }\n        const bucketId = params.bucketId;\n        const fileId = params.fileId;\n        const token = params.token;\n        if (typeof bucketId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"bucketId\"');\n        }\n        if (typeof fileId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"fileId\"');\n        }\n        const apiPath = '/storage/buckets/{bucketId}/files/{fileId}/view'.replace('{bucketId}', bucketId).replace('{fileId}', fileId);\n        const payload = {};\n        if (typeof token !== 'undefined') {\n            payload['token'] = token;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        payload['project'] = this.client.config.project;\n        for (const [key, value] of Object.entries(Service.flatten(payload))) {\n            uri.searchParams.append(key, value);\n        }\n        return uri.toString();\n    }\n}\n\nclass TablesDB {\n    constructor(client) {\n        this.client = client;\n    }\n    listTransactions(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst\n            };\n        }\n        const queries = params.queries;\n        const apiPath = '/tablesdb/transactions';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createTransaction(paramsOrFirst) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                ttl: paramsOrFirst\n            };\n        }\n        const ttl = params.ttl;\n        const apiPath = '/tablesdb/transactions';\n        const payload = {};\n        if (typeof ttl !== 'undefined') {\n            payload['ttl'] = ttl;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateTransaction(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                commit: rest[0],\n                rollback: rest[1]\n            };\n        }\n        const transactionId = params.transactionId;\n        const commit = params.commit;\n        const rollback = params.rollback;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof commit !== 'undefined') {\n            payload['commit'] = commit;\n        }\n        if (typeof rollback !== 'undefined') {\n            payload['rollback'] = rollback;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteTransaction(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst\n            };\n        }\n        const transactionId = params.transactionId;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}'.replace('{transactionId}', transactionId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    createOperations(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                transactionId: paramsOrFirst,\n                operations: rest[0]\n            };\n        }\n        const transactionId = params.transactionId;\n        const operations = params.operations;\n        if (typeof transactionId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"transactionId\"');\n        }\n        const apiPath = '/tablesdb/transactions/{transactionId}/operations'.replace('{transactionId}', transactionId);\n        const payload = {};\n        if (typeof operations !== 'undefined') {\n            payload['operations'] = operations;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    listRows(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                queries: rest[1],\n                transactionId: rest[2],\n                total: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        const total = params.total;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof data === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"data\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows'.replace('{databaseId}', databaseId).replace('{tableId}', tableId);\n        const payload = {};\n        if (typeof rowId !== 'undefined') {\n            payload['rowId'] = rowId;\n        }\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                queries: rest[2],\n                transactionId: rest[3]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const queries = params.queries;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    upsertRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    updateRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                data: rest[2],\n                permissions: rest[3],\n                transactionId: rest[4]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const data = params.data;\n        const permissions = params.permissions;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof data !== 'undefined') {\n            payload['data'] = data;\n        }\n        if (typeof permissions !== 'undefined') {\n            payload['permissions'] = permissions;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteRow(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                transactionId: rest[2]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId);\n        const payload = {};\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    decrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                min: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const min = params.min;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/decrement'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof min !== 'undefined') {\n            payload['min'] = min;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    incrementRowColumn(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                databaseId: paramsOrFirst,\n                tableId: rest[0],\n                rowId: rest[1],\n                column: rest[2],\n                value: rest[3],\n                max: rest[4],\n                transactionId: rest[5]\n            };\n        }\n        const databaseId = params.databaseId;\n        const tableId = params.tableId;\n        const rowId = params.rowId;\n        const column = params.column;\n        const value = params.value;\n        const max = params.max;\n        const transactionId = params.transactionId;\n        if (typeof databaseId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"databaseId\"');\n        }\n        if (typeof tableId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"tableId\"');\n        }\n        if (typeof rowId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"rowId\"');\n        }\n        if (typeof column === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"column\"');\n        }\n        const apiPath = '/tablesdb/{databaseId}/tables/{tableId}/rows/{rowId}/{column}/increment'.replace('{databaseId}', databaseId).replace('{tableId}', tableId).replace('{rowId}', rowId).replace('{column}', column);\n        const payload = {};\n        if (typeof value !== 'undefined') {\n            payload['value'] = value;\n        }\n        if (typeof max !== 'undefined') {\n            payload['max'] = max;\n        }\n        if (typeof transactionId !== 'undefined') {\n            payload['transactionId'] = transactionId;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n}\n\nclass Teams {\n    constructor(client) {\n        this.client = client;\n    }\n    list(paramsOrFirst, ...rest) {\n        let params;\n        if (!paramsOrFirst || (paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                queries: paramsOrFirst,\n                search: rest[0],\n                total: rest[1]\n            };\n        }\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    create(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams';\n        const payload = {};\n        if (typeof teamId !== 'undefined') {\n            payload['teamId'] = teamId;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    get(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateName(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                name: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof name === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"name\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n    delete(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    listMemberships(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                queries: rest[0],\n                search: rest[1],\n                total: rest[2]\n            };\n        }\n        const teamId = params.teamId;\n        const queries = params.queries;\n        const search = params.search;\n        const total = params.total;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof queries !== 'undefined') {\n            payload['queries'] = queries;\n        }\n        if (typeof search !== 'undefined') {\n            payload['search'] = search;\n        }\n        if (typeof total !== 'undefined') {\n            payload['total'] = total;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    createMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                roles: rest[0],\n                email: rest[1],\n                userId: rest[2],\n                phone: rest[3],\n                url: rest[4],\n                name: rest[5]\n            };\n        }\n        const teamId = params.teamId;\n        const roles = params.roles;\n        const email = params.email;\n        const userId = params.userId;\n        const phone = params.phone;\n        const url = params.url;\n        const name = params.name;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof email !== 'undefined') {\n            payload['email'] = email;\n        }\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof phone !== 'undefined') {\n            payload['phone'] = phone;\n        }\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        if (typeof url !== 'undefined') {\n            payload['url'] = url;\n        }\n        if (typeof name !== 'undefined') {\n            payload['name'] = name;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('post', uri, apiHeaders, payload);\n    }\n    getMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updateMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                roles: rest[1]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const roles = params.roles;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof roles === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"roles\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof roles !== 'undefined') {\n            payload['roles'] = roles;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    deleteMembership(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('delete', uri, apiHeaders, payload);\n    }\n    updateMembershipStatus(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                membershipId: rest[0],\n                userId: rest[1],\n                secret: rest[2]\n            };\n        }\n        const teamId = params.teamId;\n        const membershipId = params.membershipId;\n        const userId = params.userId;\n        const secret = params.secret;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof membershipId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"membershipId\"');\n        }\n        if (typeof userId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"userId\"');\n        }\n        if (typeof secret === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"secret\"');\n        }\n        const apiPath = '/teams/{teamId}/memberships/{membershipId}/status'.replace('{teamId}', teamId).replace('{membershipId}', membershipId);\n        const payload = {};\n        if (typeof userId !== 'undefined') {\n            payload['userId'] = userId;\n        }\n        if (typeof secret !== 'undefined') {\n            payload['secret'] = secret;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('patch', uri, apiHeaders, payload);\n    }\n    getPrefs(paramsOrFirst) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst\n            };\n        }\n        const teamId = params.teamId;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {};\n        return this.client.call('get', uri, apiHeaders, payload);\n    }\n    updatePrefs(paramsOrFirst, ...rest) {\n        let params;\n        if ((paramsOrFirst && typeof paramsOrFirst === 'object' && !Array.isArray(paramsOrFirst))) {\n            params = (paramsOrFirst || {});\n        }\n        else {\n            params = {\n                teamId: paramsOrFirst,\n                prefs: rest[0]\n            };\n        }\n        const teamId = params.teamId;\n        const prefs = params.prefs;\n        if (typeof teamId === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"teamId\"');\n        }\n        if (typeof prefs === 'undefined') {\n            throw new AppwriteException('Missing required parameter: \"prefs\"');\n        }\n        const apiPath = '/teams/{teamId}/prefs'.replace('{teamId}', teamId);\n        const payload = {};\n        if (typeof prefs !== 'undefined') {\n            payload['prefs'] = prefs;\n        }\n        const uri = new URL(this.client.config.endpoint + apiPath);\n        const apiHeaders = {\n            'content-type': 'application/json',\n        };\n        return this.client.call('put', uri, apiHeaders, payload);\n    }\n}\n\nvar RealtimeCode;\n(function (RealtimeCode) {\n    RealtimeCode[RealtimeCode[\"NORMAL_CLOSURE\"] = 1000] = \"NORMAL_CLOSURE\";\n    RealtimeCode[RealtimeCode[\"POLICY_VIOLATION\"] = 1008] = \"POLICY_VIOLATION\";\n    RealtimeCode[RealtimeCode[\"UNKNOWN_ERROR\"] = -1] = \"UNKNOWN_ERROR\";\n})(RealtimeCode || (RealtimeCode = {}));\nclass Realtime {\n    constructor(client) {\n        this.TYPE_ERROR = 'error';\n        this.TYPE_EVENT = 'event';\n        this.TYPE_PONG = 'pong';\n        this.TYPE_CONNECTED = 'connected';\n        this.DEBOUNCE_MS = 1;\n        this.HEARTBEAT_INTERVAL = 20000; // 20 seconds in milliseconds\n        this.activeChannels = new Set();\n        this.activeSubscriptions = new Map();\n        this.subCallDepth = 0;\n        this.reconnectAttempts = 0;\n        this.subscriptionsCounter = 0;\n        this.reconnect = true;\n        this.onErrorCallbacks = [];\n        this.onCloseCallbacks = [];\n        this.onOpenCallbacks = [];\n        this.client = client;\n    }\n    /**\n     * Register a callback function to be called when an error occurs\n     *\n     * @param {Function} callback - Callback function to handle errors\n     * @returns {void}\n     */\n    onError(callback) {\n        this.onErrorCallbacks.push(callback);\n    }\n    /**\n     * Register a callback function to be called when the connection closes\n     *\n     * @param {Function} callback - Callback function to handle connection close\n     * @returns {void}\n     */\n    onClose(callback) {\n        this.onCloseCallbacks.push(callback);\n    }\n    /**\n     * Register a callback function to be called when the connection opens\n     *\n     * @param {Function} callback - Callback function to handle connection open\n     * @returns {void}\n     */\n    onOpen(callback) {\n        this.onOpenCallbacks.push(callback);\n    }\n    startHeartbeat() {\n        this.stopHeartbeat();\n        this.heartbeatTimer = window.setInterval(() => {\n            if (this.socket && this.socket.readyState === WebSocket.OPEN) {\n                this.socket.send(JSON.stringify({ type: 'ping' }));\n            }\n        }, this.HEARTBEAT_INTERVAL);\n    }\n    stopHeartbeat() {\n        if (this.heartbeatTimer) {\n            window.clearInterval(this.heartbeatTimer);\n            this.heartbeatTimer = undefined;\n        }\n    }\n    createSocket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this.activeChannels.size === 0) {\n                this.reconnect = false;\n                yield this.closeSocket();\n                return;\n            }\n            const projectId = this.client.config.project;\n            if (!projectId) {\n                throw new AppwriteException('Missing project ID');\n            }\n            let queryParams = `project=${projectId}`;\n            for (const channel of this.activeChannels) {\n                queryParams += `&channels[]=${encodeURIComponent(channel)}`;\n            }\n            const endpoint = this.client.config.endpointRealtime !== ''\n                ? this.client.config.endpointRealtime\n                : this.client.config.endpoint || '';\n            const realtimeEndpoint = endpoint\n                .replace('https://', 'wss://')\n                .replace('http://', 'ws://');\n            const url = `${realtimeEndpoint}/realtime?${queryParams}`;\n            if (this.socket) {\n                this.reconnect = false;\n                yield this.closeSocket();\n            }\n            return new Promise((resolve, reject) => {\n                try {\n                    this.socket = new WebSocket(url);\n                    this.socket.addEventListener('open', () => {\n                        this.reconnectAttempts = 0;\n                        this.onOpenCallbacks.forEach(callback => callback());\n                        this.startHeartbeat();\n                        resolve();\n                    });\n                    this.socket.addEventListener('message', (event) => {\n                        try {\n                            const message = JSON.parse(event.data);\n                            this.handleMessage(message);\n                        }\n                        catch (error) {\n                            console.error('Failed to parse message:', error);\n                        }\n                    });\n                    this.socket.addEventListener('close', (event) => __awaiter(this, void 0, void 0, function* () {\n                        this.stopHeartbeat();\n                        this.onCloseCallbacks.forEach(callback => callback());\n                        if (!this.reconnect || event.code === RealtimeCode.POLICY_VIOLATION) {\n                            this.reconnect = true;\n                            return;\n                        }\n                        const timeout = this.getTimeout();\n                        console.log(`Realtime disconnected. Re-connecting in ${timeout / 1000} seconds.`);\n                        yield this.sleep(timeout);\n                        this.reconnectAttempts++;\n                        try {\n                            yield this.createSocket();\n                        }\n                        catch (error) {\n                            console.error('Failed to reconnect:', error);\n                        }\n                    }));\n                    this.socket.addEventListener('error', (event) => {\n                        this.stopHeartbeat();\n                        const error = new Error('WebSocket error');\n                        console.error('WebSocket error:', error.message);\n                        this.onErrorCallbacks.forEach(callback => callback(error));\n                        reject(error);\n                    });\n                }\n                catch (error) {\n                    reject(error);\n                }\n            });\n        });\n    }\n    closeSocket() {\n        return __awaiter(this, void 0, void 0, function* () {\n            this.stopHeartbeat();\n            if (this.socket) {\n                return new Promise((resolve) => {\n                    if (!this.socket) {\n                        resolve();\n                        return;\n                    }\n                    if (this.socket.readyState === WebSocket.OPEN ||\n                        this.socket.readyState === WebSocket.CONNECTING) {\n                        this.socket.addEventListener('close', () => {\n                            resolve();\n                        }, { once: true });\n                        this.socket.close(RealtimeCode.NORMAL_CLOSURE);\n                    }\n                    else {\n                        resolve();\n                    }\n                });\n            }\n        });\n    }\n    getTimeout() {\n        if (this.reconnectAttempts < 5) {\n            return 1000;\n        }\n        else if (this.reconnectAttempts < 15) {\n            return 5000;\n        }\n        else if (this.reconnectAttempts < 100) {\n            return 10000;\n        }\n        else {\n            return 60000;\n        }\n    }\n    sleep(ms) {\n        return new Promise(resolve => setTimeout(resolve, ms));\n    }\n    subscribe(channelsOrChannel, callback) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const channels = Array.isArray(channelsOrChannel)\n                ? new Set(channelsOrChannel)\n                : new Set([channelsOrChannel]);\n            this.subscriptionsCounter++;\n            const count = this.subscriptionsCounter;\n            for (const channel of channels) {\n                this.activeChannels.add(channel);\n            }\n            this.activeSubscriptions.set(count, {\n                channels,\n                callback\n            });\n            this.subCallDepth++;\n            yield this.sleep(this.DEBOUNCE_MS);\n            if (this.subCallDepth === 1) {\n                yield this.createSocket();\n            }\n            this.subCallDepth--;\n            return {\n                close: () => __awaiter(this, void 0, void 0, function* () {\n                    this.activeSubscriptions.delete(count);\n                    this.cleanUp(channels);\n                    yield this.createSocket();\n                })\n            };\n        });\n    }\n    cleanUp(channels) {\n        this.activeChannels = new Set(Array.from(this.activeChannels).filter(channel => {\n            if (!channels.has(channel)) {\n                return true;\n            }\n            const subsWithChannel = Array.from(this.activeSubscriptions.values())\n                .filter(sub => sub.channels.has(channel));\n            return subsWithChannel.length > 0;\n        }));\n    }\n    handleMessage(message) {\n        if (!message.type) {\n            return;\n        }\n        switch (message.type) {\n            case this.TYPE_CONNECTED:\n                this.handleResponseConnected(message);\n                break;\n            case this.TYPE_ERROR:\n                this.handleResponseError(message);\n                break;\n            case this.TYPE_EVENT:\n                this.handleResponseEvent(message);\n                break;\n            case this.TYPE_PONG:\n                // Handle pong response if needed\n                break;\n        }\n    }\n    handleResponseConnected(message) {\n        var _a, _b;\n        if (!message.data) {\n            return;\n        }\n        const messageData = message.data;\n        let session = this.client.config.session;\n        if (!session) {\n            try {\n                const cookie = JSON.parse((_a = window.localStorage.getItem('cookieFallback')) !== null && _a !== void 0 ? _a : '{}');\n                session = cookie === null || cookie === void 0 ? void 0 : cookie[`a_session_${this.client.config.project}`];\n            }\n            catch (error) {\n                console.error('Failed to parse cookie fallback:', error);\n            }\n        }\n        if (session && !messageData.user) {\n            (_b = this.socket) === null || _b === void 0 ? void 0 : _b.send(JSON.stringify({\n                type: 'authentication',\n                data: {\n                    session\n                }\n            }));\n        }\n    }\n    handleResponseError(message) {\n        var _a, _b;\n        const error = new AppwriteException(((_a = message.data) === null || _a === void 0 ? void 0 : _a.message) || 'Unknown error');\n        const statusCode = (_b = message.data) === null || _b === void 0 ? void 0 : _b.code;\n        this.onErrorCallbacks.forEach(callback => callback(error, statusCode));\n    }\n    handleResponseEvent(message) {\n        const data = message.data;\n        if (!data) {\n            return;\n        }\n        const channels = data.channels;\n        const events = data.events;\n        const payload = data.payload;\n        const timestamp = data.timestamp;\n        if (!channels || !events || !payload) {\n            return;\n        }\n        const hasActiveChannel = channels.some(channel => this.activeChannels.has(channel));\n        if (!hasActiveChannel) {\n            return;\n        }\n        for (const [_, subscription] of this.activeSubscriptions) {\n            const hasSubscribedChannel = channels.some(channel => subscription.channels.has(channel));\n            if (hasSubscribedChannel) {\n                const response = {\n                    events,\n                    channels,\n                    timestamp,\n                    payload\n                };\n                subscription.callback(response);\n            }\n        }\n    }\n}\n\n/**\n * Helper class to generate permission strings for resources.\n */\nclass Permission {\n}\n/**\n * Generate read permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.read = (role) => {\n    return `read(\"${role}\")`;\n};\n/**\n * Generate write permission string for the provided role.\n *\n * This is an alias of update, delete, and possibly create.\n * Don't use write in combination with update, delete, or create.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.write = (role) => {\n    return `write(\"${role}\")`;\n};\n/**\n * Generate create permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.create = (role) => {\n    return `create(\"${role}\")`;\n};\n/**\n * Generate update permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.update = (role) => {\n    return `update(\"${role}\")`;\n};\n/**\n * Generate delete permission string for the provided role.\n *\n * @param {string} role\n * @returns {string}\n */\nPermission.delete = (role) => {\n    return `delete(\"${role}\")`;\n};\n\n/**\n * Helper class to generate role strings for `Permission`.\n */\nclass Role {\n    /**\n     * Grants access to anyone.\n     *\n     * This includes authenticated and unauthenticated users.\n     *\n     * @returns {string}\n     */\n    static any() {\n        return 'any';\n    }\n    /**\n     * Grants access to a specific user by user ID.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} id\n     * @param {string} status\n     * @returns {string}\n     */\n    static user(id, status = '') {\n        if (status === '') {\n            return `user:${id}`;\n        }\n        return `user:${id}/${status}`;\n    }\n    /**\n     * Grants access to any authenticated or anonymous user.\n     *\n     * You can optionally pass verified or unverified for\n     * `status` to target specific types of users.\n     *\n     * @param {string} status\n     * @returns {string}\n     */\n    static users(status = '') {\n        if (status === '') {\n            return 'users';\n        }\n        return `users/${status}`;\n    }\n    /**\n     * Grants access to any guest user without a session.\n     *\n     * Authenticated users don't have access to this role.\n     *\n     * @returns {string}\n     */\n    static guests() {\n        return 'guests';\n    }\n    /**\n     * Grants access to a team by team ID.\n     *\n     * You can optionally pass a role for `role` to target\n     * team members with the specified role.\n     *\n     * @param {string} id\n     * @param {string} role\n     * @returns {string}\n     */\n    static team(id, role = '') {\n        if (role === '') {\n            return `team:${id}`;\n        }\n        return `team:${id}/${role}`;\n    }\n    /**\n     * Grants access to a specific member of a team.\n     *\n     * When the member is removed from the team, they will\n     * no longer have access.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static member(id) {\n        return `member:${id}`;\n    }\n    /**\n     * Grants access to a user with the specified label.\n     *\n     * @param {string} name\n     * @returns  {string}\n     */\n    static label(name) {\n        return `label:${name}`;\n    }\n}\n\nvar _a, _ID_hexTimestamp;\n/**\n * Helper class to generate ID strings for resources.\n */\nclass ID {\n    /**\n     * Uses the provided ID as the ID for the resource.\n     *\n     * @param {string} id\n     * @returns {string}\n     */\n    static custom(id) {\n        return id;\n    }\n    /**\n     * Have Appwrite generate a unique ID for you.\n     *\n     * @param {number} padding. Default is 7.\n     * @returns {string}\n     */\n    static unique(padding = 7) {\n        // Generate a unique ID with padding to have a longer ID\n        const baseId = __classPrivateFieldGet(ID, _a, \"m\", _ID_hexTimestamp).call(ID);\n        let randomPadding = '';\n        for (let i = 0; i < padding; i++) {\n            const randomHexDigit = Math.floor(Math.random() * 16).toString(16);\n            randomPadding += randomHexDigit;\n        }\n        return baseId + randomPadding;\n    }\n}\n_a = ID, _ID_hexTimestamp = function _ID_hexTimestamp() {\n    const now = new Date();\n    const sec = Math.floor(now.getTime() / 1000);\n    const msec = now.getMilliseconds();\n    // Convert to hexadecimal\n    const hexTimestamp = sec.toString(16) + msec.toString(16).padStart(5, '0');\n    return hexTimestamp;\n};\n\nvar Condition;\n(function (Condition) {\n    Condition[\"Equal\"] = \"equal\";\n    Condition[\"NotEqual\"] = \"notEqual\";\n    Condition[\"GreaterThan\"] = \"greaterThan\";\n    Condition[\"GreaterThanEqual\"] = \"greaterThanEqual\";\n    Condition[\"LessThan\"] = \"lessThan\";\n    Condition[\"LessThanEqual\"] = \"lessThanEqual\";\n    Condition[\"Contains\"] = \"contains\";\n    Condition[\"IsNull\"] = \"isNull\";\n    Condition[\"IsNotNull\"] = \"isNotNull\";\n})(Condition || (Condition = {}));\n/**\n * Helper class to generate operator strings for atomic operations.\n */\nclass Operator {\n    /**\n     * Constructor for Operator class.\n     *\n     * @param {string} method\n     * @param {OperatorValues} values\n     */\n    constructor(method, values) {\n        this.method = method;\n        if (values !== undefined) {\n            if (Array.isArray(values)) {\n                this.values = values;\n            }\n            else {\n                this.values = [values];\n            }\n        }\n    }\n    /**\n     * Convert the operator object to a JSON string.\n     *\n     * @returns {string}\n     */\n    toString() {\n        return JSON.stringify({\n            method: this.method,\n            values: this.values,\n        });\n    }\n}\n/**\n * Increment a numeric attribute by a specified value.\n *\n * @param {number} value\n * @param {number} max\n * @returns {string}\n */\nOperator.increment = (value = 1, max) => {\n    if (isNaN(value) || !isFinite(value)) {\n        throw new Error(\"Value cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [value];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"increment\", values).toString();\n};\n/**\n * Decrement a numeric attribute by a specified value.\n *\n * @param {number} value\n * @param {number} min\n * @returns {string}\n */\nOperator.decrement = (value = 1, min) => {\n    if (isNaN(value) || !isFinite(value)) {\n        throw new Error(\"Value cannot be NaN or Infinity\");\n    }\n    if (min !== undefined && (isNaN(min) || !isFinite(min))) {\n        throw new Error(\"Min cannot be NaN or Infinity\");\n    }\n    const values = [value];\n    if (min !== undefined) {\n        values.push(min);\n    }\n    return new Operator(\"decrement\", values).toString();\n};\n/**\n * Multiply a numeric attribute by a specified factor.\n *\n * @param {number} factor\n * @param {number} max\n * @returns {string}\n */\nOperator.multiply = (factor, max) => {\n    if (isNaN(factor) || !isFinite(factor)) {\n        throw new Error(\"Factor cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [factor];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"multiply\", values).toString();\n};\n/**\n * Divide a numeric attribute by a specified divisor.\n *\n * @param {number} divisor\n * @param {number} min\n * @returns {string}\n */\nOperator.divide = (divisor, min) => {\n    if (isNaN(divisor) || !isFinite(divisor)) {\n        throw new Error(\"Divisor cannot be NaN or Infinity\");\n    }\n    if (min !== undefined && (isNaN(min) || !isFinite(min))) {\n        throw new Error(\"Min cannot be NaN or Infinity\");\n    }\n    if (divisor === 0) {\n        throw new Error(\"Divisor cannot be zero\");\n    }\n    const values = [divisor];\n    if (min !== undefined) {\n        values.push(min);\n    }\n    return new Operator(\"divide\", values).toString();\n};\n/**\n * Apply modulo operation on a numeric attribute.\n *\n * @param {number} divisor\n * @returns {string}\n */\nOperator.modulo = (divisor) => {\n    if (isNaN(divisor) || !isFinite(divisor)) {\n        throw new Error(\"Divisor cannot be NaN or Infinity\");\n    }\n    if (divisor === 0) {\n        throw new Error(\"Divisor cannot be zero\");\n    }\n    return new Operator(\"modulo\", [divisor]).toString();\n};\n/**\n * Raise a numeric attribute to a specified power.\n *\n * @param {number} exponent\n * @param {number} max\n * @returns {string}\n */\nOperator.power = (exponent, max) => {\n    if (isNaN(exponent) || !isFinite(exponent)) {\n        throw new Error(\"Exponent cannot be NaN or Infinity\");\n    }\n    if (max !== undefined && (isNaN(max) || !isFinite(max))) {\n        throw new Error(\"Max cannot be NaN or Infinity\");\n    }\n    const values = [exponent];\n    if (max !== undefined) {\n        values.push(max);\n    }\n    return new Operator(\"power\", values).toString();\n};\n/**\n * Append values to an array attribute.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayAppend = (values) => new Operator(\"arrayAppend\", values).toString();\n/**\n * Prepend values to an array attribute.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayPrepend = (values) => new Operator(\"arrayPrepend\", values).toString();\n/**\n * Insert a value at a specific index in an array attribute.\n *\n * @param {number} index\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayInsert = (index, value) => new Operator(\"arrayInsert\", [index, value]).toString();\n/**\n * Remove a value from an array attribute.\n *\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayRemove = (value) => new Operator(\"arrayRemove\", [value]).toString();\n/**\n * Remove duplicate values from an array attribute.\n *\n * @returns {string}\n */\nOperator.arrayUnique = () => new Operator(\"arrayUnique\", []).toString();\n/**\n * Keep only values that exist in both the current array and the provided array.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayIntersect = (values) => new Operator(\"arrayIntersect\", values).toString();\n/**\n * Remove values from the array that exist in the provided array.\n *\n * @param {any[]} values\n * @returns {string}\n */\nOperator.arrayDiff = (values) => new Operator(\"arrayDiff\", values).toString();\n/**\n * Filter array values based on a condition.\n *\n * @param {Condition} condition\n * @param {any} value\n * @returns {string}\n */\nOperator.arrayFilter = (condition, value) => {\n    const values = [condition, value === undefined ? null : value];\n    return new Operator(\"arrayFilter\", values).toString();\n};\n/**\n * Concatenate a value to a string or array attribute.\n *\n * @param {any} value\n * @returns {string}\n */\nOperator.stringConcat = (value) => new Operator(\"stringConcat\", [value]).toString();\n/**\n * Replace occurrences of a search string with a replacement string.\n *\n * @param {string} search\n * @param {string} replace\n * @returns {string}\n */\nOperator.stringReplace = (search, replace) => new Operator(\"stringReplace\", [search, replace]).toString();\n/**\n * Toggle a boolean attribute.\n *\n * @returns {string}\n */\nOperator.toggle = () => new Operator(\"toggle\", []).toString();\n/**\n * Add days to a date attribute.\n *\n * @param {number} days\n * @returns {string}\n */\nOperator.dateAddDays = (days) => new Operator(\"dateAddDays\", [days]).toString();\n/**\n * Subtract days from a date attribute.\n *\n * @param {number} days\n * @returns {string}\n */\nOperator.dateSubDays = (days) => new Operator(\"dateSubDays\", [days]).toString();\n/**\n * Set a date attribute to the current date and time.\n *\n * @returns {string}\n */\nOperator.dateSetNow = () => new Operator(\"dateSetNow\", []).toString();\n\nvar AuthenticatorType;\n(function (AuthenticatorType) {\n    AuthenticatorType[\"Totp\"] = \"totp\";\n})(AuthenticatorType || (AuthenticatorType = {}));\n\nvar AuthenticationFactor;\n(function (AuthenticationFactor) {\n    AuthenticationFactor[\"Email\"] = \"email\";\n    AuthenticationFactor[\"Phone\"] = \"phone\";\n    AuthenticationFactor[\"Totp\"] = \"totp\";\n    AuthenticationFactor[\"Recoverycode\"] = \"recoverycode\";\n})(AuthenticationFactor || (AuthenticationFactor = {}));\n\nvar OAuthProvider;\n(function (OAuthProvider) {\n    OAuthProvider[\"Amazon\"] = \"amazon\";\n    OAuthProvider[\"Apple\"] = \"apple\";\n    OAuthProvider[\"Auth0\"] = \"auth0\";\n    OAuthProvider[\"Authentik\"] = \"authentik\";\n    OAuthProvider[\"Autodesk\"] = \"autodesk\";\n    OAuthProvider[\"Bitbucket\"] = \"bitbucket\";\n    OAuthProvider[\"Bitly\"] = \"bitly\";\n    OAuthProvider[\"Box\"] = \"box\";\n    OAuthProvider[\"Dailymotion\"] = \"dailymotion\";\n    OAuthProvider[\"Discord\"] = \"discord\";\n    OAuthProvider[\"Disqus\"] = \"disqus\";\n    OAuthProvider[\"Dropbox\"] = \"dropbox\";\n    OAuthProvider[\"Etsy\"] = \"etsy\";\n    OAuthProvider[\"Facebook\"] = \"facebook\";\n    OAuthProvider[\"Figma\"] = \"figma\";\n    OAuthProvider[\"Github\"] = \"github\";\n    OAuthProvider[\"Gitlab\"] = \"gitlab\";\n    OAuthProvider[\"Google\"] = \"google\";\n    OAuthProvider[\"Linkedin\"] = \"linkedin\";\n    OAuthProvider[\"Microsoft\"] = \"microsoft\";\n    OAuthProvider[\"Notion\"] = \"notion\";\n    OAuthProvider[\"Oidc\"] = \"oidc\";\n    OAuthProvider[\"Okta\"] = \"okta\";\n    OAuthProvider[\"Paypal\"] = \"paypal\";\n    OAuthProvider[\"PaypalSandbox\"] = \"paypalSandbox\";\n    OAuthProvider[\"Podio\"] = \"podio\";\n    OAuthProvider[\"Salesforce\"] = \"salesforce\";\n    OAuthProvider[\"Slack\"] = \"slack\";\n    OAuthProvider[\"Spotify\"] = \"spotify\";\n    OAuthProvider[\"Stripe\"] = \"stripe\";\n    OAuthProvider[\"Tradeshift\"] = \"tradeshift\";\n    OAuthProvider[\"TradeshiftBox\"] = \"tradeshiftBox\";\n    OAuthProvider[\"Twitch\"] = \"twitch\";\n    OAuthProvider[\"Wordpress\"] = \"wordpress\";\n    OAuthProvider[\"Yahoo\"] = \"yahoo\";\n    OAuthProvider[\"Yammer\"] = \"yammer\";\n    OAuthProvider[\"Yandex\"] = \"yandex\";\n    OAuthProvider[\"Zoho\"] = \"zoho\";\n    OAuthProvider[\"Zoom\"] = \"zoom\";\n    OAuthProvider[\"Mock\"] = \"mock\";\n})(OAuthProvider || (OAuthProvider = {}));\n\nvar Browser;\n(function (Browser) {\n    Browser[\"AvantBrowser\"] = \"aa\";\n    Browser[\"AndroidWebViewBeta\"] = \"an\";\n    Browser[\"GoogleChrome\"] = \"ch\";\n    Browser[\"GoogleChromeIOS\"] = \"ci\";\n    Browser[\"GoogleChromeMobile\"] = \"cm\";\n    Browser[\"Chromium\"] = \"cr\";\n    Browser[\"MozillaFirefox\"] = \"ff\";\n    Browser[\"Safari\"] = \"sf\";\n    Browser[\"MobileSafari\"] = \"mf\";\n    Browser[\"MicrosoftEdge\"] = \"ps\";\n    Browser[\"MicrosoftEdgeIOS\"] = \"oi\";\n    Browser[\"OperaMini\"] = \"om\";\n    Browser[\"Opera\"] = \"op\";\n    Browser[\"OperaNext\"] = \"on\";\n})(Browser || (Browser = {}));\n\nvar CreditCard;\n(function (CreditCard) {\n    CreditCard[\"AmericanExpress\"] = \"amex\";\n    CreditCard[\"Argencard\"] = \"argencard\";\n    CreditCard[\"Cabal\"] = \"cabal\";\n    CreditCard[\"Cencosud\"] = \"cencosud\";\n    CreditCard[\"DinersClub\"] = \"diners\";\n    CreditCard[\"Discover\"] = \"discover\";\n    CreditCard[\"Elo\"] = \"elo\";\n    CreditCard[\"Hipercard\"] = \"hipercard\";\n    CreditCard[\"JCB\"] = \"jcb\";\n    CreditCard[\"Mastercard\"] = \"mastercard\";\n    CreditCard[\"Naranja\"] = \"naranja\";\n    CreditCard[\"TarjetaShopping\"] = \"targeta-shopping\";\n    CreditCard[\"UnionPay\"] = \"unionpay\";\n    CreditCard[\"Visa\"] = \"visa\";\n    CreditCard[\"MIR\"] = \"mir\";\n    CreditCard[\"Maestro\"] = \"maestro\";\n    CreditCard[\"Rupay\"] = \"rupay\";\n})(CreditCard || (CreditCard = {}));\n\nvar Flag;\n(function (Flag) {\n    Flag[\"Afghanistan\"] = \"af\";\n    Flag[\"Angola\"] = \"ao\";\n    Flag[\"Albania\"] = \"al\";\n    Flag[\"Andorra\"] = \"ad\";\n    Flag[\"UnitedArabEmirates\"] = \"ae\";\n    Flag[\"Argentina\"] = \"ar\";\n    Flag[\"Armenia\"] = \"am\";\n    Flag[\"AntiguaAndBarbuda\"] = \"ag\";\n    Flag[\"Australia\"] = \"au\";\n    Flag[\"Austria\"] = \"at\";\n    Flag[\"Azerbaijan\"] = \"az\";\n    Flag[\"Burundi\"] = \"bi\";\n    Flag[\"Belgium\"] = \"be\";\n    Flag[\"Benin\"] = \"bj\";\n    Flag[\"BurkinaFaso\"] = \"bf\";\n    Flag[\"Bangladesh\"] = \"bd\";\n    Flag[\"Bulgaria\"] = \"bg\";\n    Flag[\"Bahrain\"] = \"bh\";\n    Flag[\"Bahamas\"] = \"bs\";\n    Flag[\"BosniaAndHerzegovina\"] = \"ba\";\n    Flag[\"Belarus\"] = \"by\";\n    Flag[\"Belize\"] = \"bz\";\n    Flag[\"Bolivia\"] = \"bo\";\n    Flag[\"Brazil\"] = \"br\";\n    Flag[\"Barbados\"] = \"bb\";\n    Flag[\"BruneiDarussalam\"] = \"bn\";\n    Flag[\"Bhutan\"] = \"bt\";\n    Flag[\"Botswana\"] = \"bw\";\n    Flag[\"CentralAfricanRepublic\"] = \"cf\";\n    Flag[\"Canada\"] = \"ca\";\n    Flag[\"Switzerland\"] = \"ch\";\n    Flag[\"Chile\"] = \"cl\";\n    Flag[\"China\"] = \"cn\";\n    Flag[\"CoteDIvoire\"] = \"ci\";\n    Flag[\"Cameroon\"] = \"cm\";\n    Flag[\"DemocraticRepublicOfTheCongo\"] = \"cd\";\n    Flag[\"RepublicOfTheCongo\"] = \"cg\";\n    Flag[\"Colombia\"] = \"co\";\n    Flag[\"Comoros\"] = \"km\";\n    Flag[\"CapeVerde\"] = \"cv\";\n    Flag[\"CostaRica\"] = \"cr\";\n    Flag[\"Cuba\"] = \"cu\";\n    Flag[\"Cyprus\"] = \"cy\";\n    Flag[\"CzechRepublic\"] = \"cz\";\n    Flag[\"Germany\"] = \"de\";\n    Flag[\"Djibouti\"] = \"dj\";\n    Flag[\"Dominica\"] = \"dm\";\n    Flag[\"Denmark\"] = \"dk\";\n    Flag[\"DominicanRepublic\"] = \"do\";\n    Flag[\"Algeria\"] = \"dz\";\n    Flag[\"Ecuador\"] = \"ec\";\n    Flag[\"Egypt\"] = \"eg\";\n    Flag[\"Eritrea\"] = \"er\";\n    Flag[\"Spain\"] = \"es\";\n    Flag[\"Estonia\"] = \"ee\";\n    Flag[\"Ethiopia\"] = \"et\";\n    Flag[\"Finland\"] = \"fi\";\n    Flag[\"Fiji\"] = \"fj\";\n    Flag[\"France\"] = \"fr\";\n    Flag[\"MicronesiaFederatedStatesOf\"] = \"fm\";\n    Flag[\"Gabon\"] = \"ga\";\n    Flag[\"UnitedKingdom\"] = \"gb\";\n    Flag[\"Georgia\"] = \"ge\";\n    Flag[\"Ghana\"] = \"gh\";\n    Flag[\"Guinea\"] = \"gn\";\n    Flag[\"Gambia\"] = \"gm\";\n    Flag[\"GuineaBissau\"] = \"gw\";\n    Flag[\"EquatorialGuinea\"] = \"gq\";\n    Flag[\"Greece\"] = \"gr\";\n    Flag[\"Grenada\"] = \"gd\";\n    Flag[\"Guatemala\"] = \"gt\";\n    Flag[\"Guyana\"] = \"gy\";\n    Flag[\"Honduras\"] = \"hn\";\n    Flag[\"Croatia\"] = \"hr\";\n    Flag[\"Haiti\"] = \"ht\";\n    Flag[\"Hungary\"] = \"hu\";\n    Flag[\"Indonesia\"] = \"id\";\n    Flag[\"India\"] = \"in\";\n    Flag[\"Ireland\"] = \"ie\";\n    Flag[\"IranIslamicRepublicOf\"] = \"ir\";\n    Flag[\"Iraq\"] = \"iq\";\n    Flag[\"Iceland\"] = \"is\";\n    Flag[\"Israel\"] = \"il\";\n    Flag[\"Italy\"] = \"it\";\n    Flag[\"Jamaica\"] = \"jm\";\n    Flag[\"Jordan\"] = \"jo\";\n    Flag[\"Japan\"] = \"jp\";\n    Flag[\"Kazakhstan\"] = \"kz\";\n    Flag[\"Kenya\"] = \"ke\";\n    Flag[\"Kyrgyzstan\"] = \"kg\";\n    Flag[\"Cambodia\"] = \"kh\";\n    Flag[\"Kiribati\"] = \"ki\";\n    Flag[\"SaintKittsAndNevis\"] = \"kn\";\n    Flag[\"SouthKorea\"] = \"kr\";\n    Flag[\"Kuwait\"] = \"kw\";\n    Flag[\"LaoPeopleSDemocraticRepublic\"] = \"la\";\n    Flag[\"Lebanon\"] = \"lb\";\n    Flag[\"Liberia\"] = \"lr\";\n    Flag[\"Libya\"] = \"ly\";\n    Flag[\"SaintLucia\"] = \"lc\";\n    Flag[\"Liechtenstein\"] = \"li\";\n    Flag[\"SriLanka\"] = \"lk\";\n    Flag[\"Lesotho\"] = \"ls\";\n    Flag[\"Lithuania\"] = \"lt\";\n    Flag[\"Luxembourg\"] = \"lu\";\n    Flag[\"Latvia\"] = \"lv\";\n    Flag[\"Morocco\"] = \"ma\";\n    Flag[\"Monaco\"] = \"mc\";\n    Flag[\"Moldova\"] = \"md\";\n    Flag[\"Madagascar\"] = \"mg\";\n    Flag[\"Maldives\"] = \"mv\";\n    Flag[\"Mexico\"] = \"mx\";\n    Flag[\"MarshallIslands\"] = \"mh\";\n    Flag[\"NorthMacedonia\"] = \"mk\";\n    Flag[\"Mali\"] = \"ml\";\n    Flag[\"Malta\"] = \"mt\";\n    Flag[\"Myanmar\"] = \"mm\";\n    Flag[\"Montenegro\"] = \"me\";\n    Flag[\"Mongolia\"] = \"mn\";\n    Flag[\"Mozambique\"] = \"mz\";\n    Flag[\"Mauritania\"] = \"mr\";\n    Flag[\"Mauritius\"] = \"mu\";\n    Flag[\"Malawi\"] = \"mw\";\n    Flag[\"Malaysia\"] = \"my\";\n    Flag[\"Namibia\"] = \"na\";\n    Flag[\"Niger\"] = \"ne\";\n    Flag[\"Nigeria\"] = \"ng\";\n    Flag[\"Nicaragua\"] = \"ni\";\n    Flag[\"Netherlands\"] = \"nl\";\n    Flag[\"Norway\"] = \"no\";\n    Flag[\"Nepal\"] = \"np\";\n    Flag[\"Nauru\"] = \"nr\";\n    Flag[\"NewZealand\"] = \"nz\";\n    Flag[\"Oman\"] = \"om\";\n    Flag[\"Pakistan\"] = \"pk\";\n    Flag[\"Panama\"] = \"pa\";\n    Flag[\"Peru\"] = \"pe\";\n    Flag[\"Philippines\"] = \"ph\";\n    Flag[\"Palau\"] = \"pw\";\n    Flag[\"PapuaNewGuinea\"] = \"pg\";\n    Flag[\"Poland\"] = \"pl\";\n    Flag[\"FrenchPolynesia\"] = \"pf\";\n    Flag[\"NorthKorea\"] = \"kp\";\n    Flag[\"Portugal\"] = \"pt\";\n    Flag[\"Paraguay\"] = \"py\";\n    Flag[\"Qatar\"] = \"qa\";\n    Flag[\"Romania\"] = \"ro\";\n    Flag[\"Russia\"] = \"ru\";\n    Flag[\"Rwanda\"] = \"rw\";\n    Flag[\"SaudiArabia\"] = \"sa\";\n    Flag[\"Sudan\"] = \"sd\";\n    Flag[\"Senegal\"] = \"sn\";\n    Flag[\"Singapore\"] = \"sg\";\n    Flag[\"SolomonIslands\"] = \"sb\";\n    Flag[\"SierraLeone\"] = \"sl\";\n    Flag[\"ElSalvador\"] = \"sv\";\n    Flag[\"SanMarino\"] = \"sm\";\n    Flag[\"Somalia\"] = \"so\";\n    Flag[\"Serbia\"] = \"rs\";\n    Flag[\"SouthSudan\"] = \"ss\";\n    Flag[\"SaoTomeAndPrincipe\"] = \"st\";\n    Flag[\"Suriname\"] = \"sr\";\n    Flag[\"Slovakia\"] = \"sk\";\n    Flag[\"Slovenia\"] = \"si\";\n    Flag[\"Sweden\"] = \"se\";\n    Flag[\"Eswatini\"] = \"sz\";\n    Flag[\"Seychelles\"] = \"sc\";\n    Flag[\"Syria\"] = \"sy\";\n    Flag[\"Chad\"] = \"td\";\n    Flag[\"Togo\"] = \"tg\";\n    Flag[\"Thailand\"] = \"th\";\n    Flag[\"Tajikistan\"] = \"tj\";\n    Flag[\"Turkmenistan\"] = \"tm\";\n    Flag[\"TimorLeste\"] = \"tl\";\n    Flag[\"Tonga\"] = \"to\";\n    Flag[\"TrinidadAndTobago\"] = \"tt\";\n    Flag[\"Tunisia\"] = \"tn\";\n    Flag[\"Turkey\"] = \"tr\";\n    Flag[\"Tuvalu\"] = \"tv\";\n    Flag[\"Tanzania\"] = \"tz\";\n    Flag[\"Uganda\"] = \"ug\";\n    Flag[\"Ukraine\"] = \"ua\";\n    Flag[\"Uruguay\"] = \"uy\";\n    Flag[\"UnitedStates\"] = \"us\";\n    Flag[\"Uzbekistan\"] = \"uz\";\n    Flag[\"VaticanCity\"] = \"va\";\n    Flag[\"SaintVincentAndTheGrenadines\"] = \"vc\";\n    Flag[\"Venezuela\"] = \"ve\";\n    Flag[\"Vietnam\"] = \"vn\";\n    Flag[\"Vanuatu\"] = \"vu\";\n    Flag[\"Samoa\"] = \"ws\";\n    Flag[\"Yemen\"] = \"ye\";\n    Flag[\"SouthAfrica\"] = \"za\";\n    Flag[\"Zambia\"] = \"zm\";\n    Flag[\"Zimbabwe\"] = \"zw\";\n})(Flag || (Flag = {}));\n\nvar ExecutionMethod;\n(function (ExecutionMethod) {\n    ExecutionMethod[\"GET\"] = \"GET\";\n    ExecutionMethod[\"POST\"] = \"POST\";\n    ExecutionMethod[\"PUT\"] = \"PUT\";\n    ExecutionMethod[\"PATCH\"] = \"PATCH\";\n    ExecutionMethod[\"DELETE\"] = \"DELETE\";\n    ExecutionMethod[\"OPTIONS\"] = \"OPTIONS\";\n    ExecutionMethod[\"HEAD\"] = \"HEAD\";\n})(ExecutionMethod || (ExecutionMethod = {}));\n\nvar ImageGravity;\n(function (ImageGravity) {\n    ImageGravity[\"Center\"] = \"center\";\n    ImageGravity[\"Topleft\"] = \"top-left\";\n    ImageGravity[\"Top\"] = \"top\";\n    ImageGravity[\"Topright\"] = \"top-right\";\n    ImageGravity[\"Left\"] = \"left\";\n    ImageGravity[\"Right\"] = \"right\";\n    ImageGravity[\"Bottomleft\"] = \"bottom-left\";\n    ImageGravity[\"Bottom\"] = \"bottom\";\n    ImageGravity[\"Bottomright\"] = \"bottom-right\";\n})(ImageGravity || (ImageGravity = {}));\n\nvar ImageFormat;\n(function (ImageFormat) {\n    ImageFormat[\"Jpg\"] = \"jpg\";\n    ImageFormat[\"Jpeg\"] = \"jpeg\";\n    ImageFormat[\"Png\"] = \"png\";\n    ImageFormat[\"Webp\"] = \"webp\";\n    ImageFormat[\"Heic\"] = \"heic\";\n    ImageFormat[\"Avif\"] = \"avif\";\n    ImageFormat[\"Gif\"] = \"gif\";\n})(ImageFormat || (ImageFormat = {}));\n\nvar ExecutionTrigger;\n(function (ExecutionTrigger) {\n    ExecutionTrigger[\"Http\"] = \"http\";\n    ExecutionTrigger[\"Schedule\"] = \"schedule\";\n    ExecutionTrigger[\"Event\"] = \"event\";\n})(ExecutionTrigger || (ExecutionTrigger = {}));\n\nvar ExecutionStatus;\n(function (ExecutionStatus) {\n    ExecutionStatus[\"Waiting\"] = \"waiting\";\n    ExecutionStatus[\"Processing\"] = \"processing\";\n    ExecutionStatus[\"Completed\"] = \"completed\";\n    ExecutionStatus[\"Failed\"] = \"failed\";\n    ExecutionStatus[\"Scheduled\"] = \"scheduled\";\n})(ExecutionStatus || (ExecutionStatus = {}));\n\n\n//# sourceMappingURL=sdk.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYXBwd3JpdGUvZGlzdC9lc20vc2RrLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxZQUFZO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxZQUFZO0FBQ3ZCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsWUFBWTtBQUN2QixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFlBQVk7QUFDdkIsYUFB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QTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELEtBQUssWUFBWSxLQUFLO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLLFlBQVksS0FBSztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQsU0FBUyxZQUFZLFNBQVM7QUFDakY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsVUFBVSxZQUFZLFVBQVU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLFlBQVksVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxVQUFVLFlBQVksVUFBVTtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFNBQVMsaUJBQWlCLFNBQVM7QUFDOUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsU0FBUyxpQkFBaUIsU0FBUztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsU0FBUyxZQUFZLFNBQVM7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsS0FBSyxZQUFZLEtBQUs7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxLQUFLLFlBQVksS0FBSztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLEtBQUssWUFBWSxLQUFLO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxjQUFjLFlBQVksY0FBYztBQUMxRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYyxZQUFZLGNBQWM7QUFDMUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFD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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxXQUFXLFNBQVMsUUFBUSxpQkFBaUIsV0FBVyx5QkFBeUIsUUFBUTtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxTQUFTLFFBQVEsT0FBTyxNQUFNLFlBQVksV0FBVyx5QkFBeUIsUUFBUSxzQkFBc0IsTUFBTTtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsV0FBVyxTQUFTLFFBQVEsT0FBTyxNQUFNLFlBQVksV0FBVyx5QkFBeUIsUUFBUSxzQkFBc0IsTUFBTTtBQUNqSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sWUFBWSxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sWUFBWSxPQUFPO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sd0JBQXdCLE9BQU87QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLHdCQUF3QixPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxPQUFPLGNBQWMsYUFBYSxZQUFZLE9BQU8scUJBQXFCLGFBQWE7QUFDeEg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sY0FBYyxhQUFhLFlBQVksT0FBTyxxQkFBcUIsYUFBYTtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxjQUFjLGFBQWEsWUFBWSxPQUFPLHFCQUFxQixhQUFhO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sY0FBYyxhQUFhLG1CQUFtQixPQUFPLHFCQUFxQixhQUFhO0FBQy9IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLE9BQU8sa0JBQWtCLE9BQU87QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsT0FBTyxrQkFBa0IsT0FBTztBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsY0FBYztBQUNoRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsVUFBVTtBQUNuRDtBQUNBLDhDQUE4Qyw0QkFBNEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsaUJBQWlCLFlBQVksWUFBWTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLGdCQUFnQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixJQUFJLFlBQVk7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUlBQW1JO0FBQ25JLDhGQUE4RiwyQkFBMkI7QUFDekg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHFCQUFxQixLQUFLO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0Esc0JBQXNCLEtBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQSxzQkFBc0IsS0FBSztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBLHNCQUFzQixLQUFLO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixHQUFHO0FBQzlCO0FBQ0EsdUJBQXVCLEdBQUcsR0FBRyxPQUFPO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU87QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLEdBQUc7QUFDOUI7QUFDQSx1QkFBdUIsR0FBRyxHQUFHLEtBQUs7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSx5QkFBeUIsR0FBRztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixrQkFBa0I7QUFDbEI7QUFDQTtBQUNBLHdCQUF3QixLQUFLO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGdCQUFnQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxXQUFXO0FBQ3RCLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsS0FBSztBQUNoQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixXQUFXLFFBQVE7QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsUUFBUTtBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9EQUFvRDs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxzQ0FBc0M7O0FBRXZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQkFBMEI7O0FBRTNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxnQ0FBZ0M7O0FBRWpDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9CQUFvQjs7QUFFckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQywwQ0FBMEM7O0FBRTNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLG9DQUFvQzs7QUFFckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxrQ0FBa0M7O0FBRW5DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0Qzs7QUFFN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDBDQUEwQzs7QUFFc1Q7QUFDalciLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWtpdGEvRGVza3RvcC9mb2N1c3BoZXJlL25vZGVfbW9kdWxlcy9hcHB3cml0ZS9kaXN0L2VzbS9zZGsuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0KHJlY2VpdmVyLCBzdGF0ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgZ2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgcmVhZCBwcml2YXRlIG1lbWJlciBmcm9tIGFuIG9iamVjdCB3aG9zZSBjbGFzcyBkaWQgbm90IGRlY2xhcmUgaXRcIik7XHJcbiAgICByZXR1cm4ga2luZCA9PT0gXCJtXCIgPyBmIDoga2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIpIDogZiA/IGYudmFsdWUgOiBzdGF0ZS5nZXQocmVjZWl2ZXIpO1xyXG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIHF1ZXJ5IHN0cmluZ3MuXG4gKi9cbmNsYXNzIFF1ZXJ5IHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgUXVlcnkgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtBdHRyaWJ1dGVzVHlwZXN9IGF0dHJpYnV0ZVxuICAgICAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWV0aG9kLCBhdHRyaWJ1dGUsIHZhbHVlcykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgdGhpcy5hdHRyaWJ1dGUgPSBhdHRyaWJ1dGU7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBxdWVyeSBvYmplY3QgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgYXR0cmlidXRlOiB0aGlzLmF0dHJpYnV0ZSxcbiAgICAgICAgICAgIHZhbHVlczogdGhpcy52YWx1ZXMsXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwiZXF1YWxcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IGVxdWFsIHRvIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7UXVlcnlUeXBlc30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEVxdWFsID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcIm5vdEVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGxlc3MgdGhhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5sZXNzVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJsZXNzVGhhblwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubGVzc1RoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJsZXNzVGhhbkVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIGdyZWF0ZXIgdGhhbiB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge1F1ZXJ5VHlwZXN9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ncmVhdGVyVGhhbiA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJncmVhdGVyVGhhblwiLCBhdHRyaWJ1dGUsIHZhbHVlKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtRdWVyeVR5cGVzfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZ3JlYXRlclRoYW5FcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJncmVhdGVyVGhhbkVxdWFsXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGlzIG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuaXNOdWxsID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwiaXNOdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IG51bGwuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuaXNOb3ROdWxsID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwiaXNOb3ROdWxsXCIsIGF0dHJpYnV0ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYmV0d2VlbiBzdGFydCBhbmQgZW5kIChpbmNsdXNpdmUpLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBzdGFydFxuICogQHBhcmFtIHtzdHJpbmcgfCBudW1iZXJ9IGVuZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuYmV0d2VlbiA9IChhdHRyaWJ1dGUsIHN0YXJ0LCBlbmQpID0+IG5ldyBRdWVyeShcImJldHdlZW5cIiwgYXR0cmlidXRlLCBbc3RhcnQsIGVuZF0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIHN0YXJ0cyB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuc3RhcnRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJzdGFydHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGVuZHMgd2l0aCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmVuZHNXaXRoID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImVuZHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFNwZWNpZnkgd2hpY2ggYXR0cmlidXRlcyBzaG91bGQgYmUgcmV0dXJuZWQgYnkgdGhlIEFQSSBjYWxsLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nW119IGF0dHJpYnV0ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnNlbGVjdCA9IChhdHRyaWJ1dGVzKSA9PiBuZXcgUXVlcnkoXCJzZWxlY3RcIiwgdW5kZWZpbmVkLCBhdHRyaWJ1dGVzKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIGJ5IHNlYXJjaGluZyBhdHRyaWJ1dGUgZm9yIHZhbHVlLlxuICogQSBmdWxsdGV4dCBpbmRleCBvbiBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgZm9yIHRoaXMgcXVlcnkgdG8gd29yay5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJzZWFyY2hcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogU29ydCByZXN1bHRzIGJ5IGF0dHJpYnV0ZSBkZXNjZW5kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm9yZGVyRGVzYyA9IChhdHRyaWJ1dGUpID0+IG5ldyBRdWVyeShcIm9yZGVyRGVzY1wiLCBhdHRyaWJ1dGUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFNvcnQgcmVzdWx0cyBieSBhdHRyaWJ1dGUgYXNjZW5kaW5nLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm9yZGVyQXNjID0gKGF0dHJpYnV0ZSkgPT4gbmV3IFF1ZXJ5KFwib3JkZXJBc2NcIiwgYXR0cmlidXRlKS50b1N0cmluZygpO1xuLyoqXG4gKiBTb3J0IHJlc3VsdHMgcmFuZG9tbHkuXG4gKlxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkub3JkZXJSYW5kb20gPSAoKSA9PiBuZXcgUXVlcnkoXCJvcmRlclJhbmRvbVwiKS50b1N0cmluZygpO1xuLyoqXG4gKiBSZXR1cm4gcmVzdWx0cyBhZnRlciBkb2N1bWVudElkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jdXJzb3JBZnRlciA9IChkb2N1bWVudElkKSA9PiBuZXcgUXVlcnkoXCJjdXJzb3JBZnRlclwiLCB1bmRlZmluZWQsIGRvY3VtZW50SWQpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJldHVybiByZXN1bHRzIGJlZm9yZSBkb2N1bWVudElkLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBkb2N1bWVudElkXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5jdXJzb3JCZWZvcmUgPSAoZG9jdW1lbnRJZCkgPT4gbmV3IFF1ZXJ5KFwiY3Vyc29yQmVmb3JlXCIsIHVuZGVmaW5lZCwgZG9jdW1lbnRJZCkudG9TdHJpbmcoKTtcbi8qKlxuICogUmV0dXJuIG9ubHkgbGltaXQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gbGltaXRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmxpbWl0ID0gKGxpbWl0KSA9PiBuZXcgUXVlcnkoXCJsaW1pdFwiLCB1bmRlZmluZWQsIGxpbWl0KS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIGJ5IHNraXBwaW5nIHRoZSBmaXJzdCBvZmZzZXQgcmVzdWx0cy5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gb2Zmc2V0XG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vZmZzZXQgPSAob2Zmc2V0KSA9PiBuZXcgUXVlcnkoXCJvZmZzZXRcIiwgdW5kZWZpbmVkLCBvZmZzZXQpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGNvbnRhaW5zIHRoZSBzcGVjaWZpZWQgdmFsdWUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHtzdHJpbmcgfCBzdHJpbmdbXX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNvbnRhaW5zID0gKGF0dHJpYnV0ZSwgdmFsdWUpID0+IG5ldyBRdWVyeShcImNvbnRhaW5zXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IGFueVtdfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90Q29udGFpbnMgPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90Q29udGFpbnNcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyBieSBzZWFyY2hpbmcgYXR0cmlidXRlIGZvciB2YWx1ZSAoaW52ZXJzZSBvZiBzZWFyY2gpLlxuICogQSBmdWxsdGV4dCBpbmRleCBvbiBhdHRyaWJ1dGUgaXMgcmVxdWlyZWQgZm9yIHRoaXMgcXVlcnkgdG8gd29yay5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdFNlYXJjaCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RTZWFyY2hcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgbm90IGJldHdlZW4gc3RhcnQgYW5kIGVuZCAoZXhjbHVzaXZlKS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge3N0cmluZyB8IG51bWJlcn0gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nIHwgbnVtYmVyfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm5vdEJldHdlZW4gPSAoYXR0cmlidXRlLCBzdGFydCwgZW5kKSA9PiBuZXcgUXVlcnkoXCJub3RCZXR3ZWVuXCIsIGF0dHJpYnV0ZSwgW3N0YXJ0LCBlbmRdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBzdGFydCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90U3RhcnRzV2l0aCA9IChhdHRyaWJ1dGUsIHZhbHVlKSA9PiBuZXcgUXVlcnkoXCJub3RTdGFydHNXaXRoXCIsIGF0dHJpYnV0ZSwgdmFsdWUpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIGRvZXMgbm90IGVuZCB3aXRoIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90RW5kc1dpdGggPSAoYXR0cmlidXRlLCB2YWx1ZSkgPT4gbmV3IFF1ZXJ5KFwibm90RW5kc1dpdGhcIiwgYXR0cmlidXRlLCB2YWx1ZSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgY3JlYXRlZCBiZWZvcmUgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyZWF0ZWRCZWZvcmUgPSAodmFsdWUpID0+IFF1ZXJ5Lmxlc3NUaGFuKFwiJGNyZWF0ZWRBdFwiLCB2YWx1ZSk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIGNyZWF0ZWQgYWZ0ZXIgZGF0ZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyZWF0ZWRBZnRlciA9ICh2YWx1ZSkgPT4gUXVlcnkuZ3JlYXRlclRoYW4oXCIkY3JlYXRlZEF0XCIsIHZhbHVlKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBkb2N1bWVudCB3YXMgY3JlYXRlZCBiZXR3ZWVuIGRhdGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdGFydFxuICogQHBhcmFtIHtzdHJpbmd9IGVuZFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuY3JlYXRlZEJldHdlZW4gPSAoc3RhcnQsIGVuZCkgPT4gUXVlcnkuYmV0d2VlbihcIiRjcmVhdGVkQXRcIiwgc3RhcnQsIGVuZCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIHVwZGF0ZWQgYmVmb3JlIGRhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS51cGRhdGVkQmVmb3JlID0gKHZhbHVlKSA9PiBRdWVyeS5sZXNzVGhhbihcIiR1cGRhdGVkQXRcIiwgdmFsdWUpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGRvY3VtZW50IHdhcyB1cGRhdGVkIGFmdGVyIGRhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS51cGRhdGVkQWZ0ZXIgPSAodmFsdWUpID0+IFF1ZXJ5LmdyZWF0ZXJUaGFuKFwiJHVwZGF0ZWRBdFwiLCB2YWx1ZSk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgZG9jdW1lbnQgd2FzIHVwZGF0ZWQgYmV0d2VlbiBkYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RhcnRcbiAqIEBwYXJhbSB7c3RyaW5nfSBlbmRcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LnVwZGF0ZWRCZXR3ZWVuID0gKHN0YXJ0LCBlbmQpID0+IFF1ZXJ5LmJldHdlZW4oXCIkdXBkYXRlZEF0XCIsIHN0YXJ0LCBlbmQpO1xuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIHF1ZXJpZXMgdXNpbmcgbG9naWNhbCBPUiBvcGVyYXRvci5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ1tdfSBxdWVyaWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5vciA9IChxdWVyaWVzKSA9PiBuZXcgUXVlcnkoXCJvclwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuLyoqXG4gKiBDb21iaW5lIG11bHRpcGxlIHF1ZXJpZXMgdXNpbmcgbG9naWNhbCBBTkQgb3BlcmF0b3IuXG4gKlxuICogQHBhcmFtIHtzdHJpbmdbXX0gcXVlcmllc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuYW5kID0gKHF1ZXJpZXMpID0+IG5ldyBRdWVyeShcImFuZFwiLCB1bmRlZmluZWQsIHF1ZXJpZXMubWFwKChxdWVyeSkgPT4gSlNPTi5wYXJzZShxdWVyeSkpKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBhdCBhIHNwZWNpZmljIGRpc3RhbmNlIGZyb20gdGhlIGdpdmVuIGNvb3JkaW5hdGVzLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IG1ldGVyc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkuZGlzdGFuY2VFcXVhbCA9IChhdHRyaWJ1dGUsIHZhbHVlcywgZGlzdGFuY2UsIG1ldGVycyA9IHRydWUpID0+IG5ldyBRdWVyeShcImRpc3RhbmNlRXF1YWxcIiwgYXR0cmlidXRlLCBbW3ZhbHVlcywgZGlzdGFuY2UsIG1ldGVyc11dKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBpcyBub3QgYXQgYSBzcGVjaWZpYyBkaXN0YW5jZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlTm90RXF1YWwgPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZU5vdEVxdWFsXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYXQgYSBkaXN0YW5jZSBncmVhdGVyIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlR3JlYXRlclRoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZUdyZWF0ZXJUaGFuXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaXMgYXQgYSBkaXN0YW5jZSBsZXNzIHRoYW4gdGhlIHNwZWNpZmllZCB2YWx1ZSBmcm9tIHRoZSBnaXZlbiBjb29yZGluYXRlcy5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZVxuICogQHBhcmFtIHtib29sZWFufSBtZXRlcnNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmRpc3RhbmNlTGVzc1RoYW4gPSAoYXR0cmlidXRlLCB2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnMgPSB0cnVlKSA9PiBuZXcgUXVlcnkoXCJkaXN0YW5jZUxlc3NUaGFuXCIsIGF0dHJpYnV0ZSwgW1t2YWx1ZXMsIGRpc3RhbmNlLCBtZXRlcnNdXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgaW50ZXJzZWN0cyB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmludGVyc2VjdHMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcImludGVyc2VjdHNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3QgaW50ZXJzZWN0IHdpdGggdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90SW50ZXJzZWN0cyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwibm90SW50ZXJzZWN0c1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBjcm9zc2VzIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5LmNyb3NzZXMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcImNyb3NzZXNcIiwgYXR0cmlidXRlLCBbdmFsdWVzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogRmlsdGVyIHJlc291cmNlcyB3aGVyZSBhdHRyaWJ1dGUgZG9lcyBub3QgY3Jvc3MgdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90Q3Jvc3NlcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwibm90Q3Jvc3Nlc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBvdmVybGFwcyB3aXRoIHRoZSBnaXZlbiBnZW9tZXRyeS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYXR0cmlidXRlXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblF1ZXJ5Lm92ZXJsYXBzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJvdmVybGFwc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCBvdmVybGFwIHdpdGggdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkubm90T3ZlcmxhcHMgPSAoYXR0cmlidXRlLCB2YWx1ZXMpID0+IG5ldyBRdWVyeShcIm5vdE92ZXJsYXBzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEZpbHRlciByZXNvdXJjZXMgd2hlcmUgYXR0cmlidXRlIHRvdWNoZXMgdGhlIGdpdmVuIGdlb21ldHJ5LlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSBhdHRyaWJ1dGVcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUXVlcnkudG91Y2hlcyA9IChhdHRyaWJ1dGUsIHZhbHVlcykgPT4gbmV3IFF1ZXJ5KFwidG91Y2hlc1wiLCBhdHRyaWJ1dGUsIFt2YWx1ZXNdKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgcmVzb3VyY2VzIHdoZXJlIGF0dHJpYnV0ZSBkb2VzIG5vdCB0b3VjaCB0aGUgZ2l2ZW4gZ2VvbWV0cnkuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IGF0dHJpYnV0ZVxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5RdWVyeS5ub3RUb3VjaGVzID0gKGF0dHJpYnV0ZSwgdmFsdWVzKSA9PiBuZXcgUXVlcnkoXCJub3RUb3VjaGVzXCIsIGF0dHJpYnV0ZSwgW3ZhbHVlc10pLnRvU3RyaW5nKCk7XG5cbi8qKlxuICogRXhjZXB0aW9uIHRocm93biBieSB0aGUgIHBhY2thZ2VcbiAqL1xuY2xhc3MgQXBwd3JpdGVFeGNlcHRpb24gZXh0ZW5kcyBFcnJvciB7XG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYSBBcHB3cml0ZSBFeGNlcHRpb24uXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBlcnJvciBtZXNzYWdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBjb2RlIC0gVGhlIGVycm9yIGNvZGUuIERlZmF1bHQgaXMgMC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZSAtIFRoZSBlcnJvciB0eXBlLiBEZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcmVzcG9uc2UgLSBUaGUgcmVzcG9uc2Ugc3RyaW5nLiBEZWZhdWx0IGlzIGFuIGVtcHR5IHN0cmluZy5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBjb2RlID0gMCwgdHlwZSA9ICcnLCByZXNwb25zZSA9ICcnKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLm5hbWUgPSAnQXBwd3JpdGVFeGNlcHRpb24nO1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2U7XG4gICAgfVxufVxuLyoqXG4gKiBDbGllbnQgdGhhdCBoYW5kbGVzIHJlcXVlc3RzIHRvIEFwcHdyaXRlXG4gKi9cbmNsYXNzIENsaWVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBIb2xkcyBjb25maWd1cmF0aW9uIHN1Y2ggYXMgcHJvamVjdC5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29uZmlnID0ge1xuICAgICAgICAgICAgZW5kcG9pbnQ6ICdodHRwczovL2Nsb3VkLmFwcHdyaXRlLmlvL3YxJyxcbiAgICAgICAgICAgIGVuZHBvaW50UmVhbHRpbWU6ICcnLFxuICAgICAgICAgICAgcHJvamVjdDogJycsXG4gICAgICAgICAgICBqd3Q6ICcnLFxuICAgICAgICAgICAgbG9jYWxlOiAnJyxcbiAgICAgICAgICAgIHNlc3Npb246ICcnLFxuICAgICAgICAgICAgZGV2a2V5OiAnJyxcbiAgICAgICAgfTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEN1c3RvbSBoZWFkZXJzIGZvciBBUEkgcmVxdWVzdHMuXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmhlYWRlcnMgPSB7XG4gICAgICAgICAgICAneC1zZGstbmFtZSc6ICdXZWInLFxuICAgICAgICAgICAgJ3gtc2RrLXBsYXRmb3JtJzogJ2NsaWVudCcsXG4gICAgICAgICAgICAneC1zZGstbGFuZ3VhZ2UnOiAnd2ViJyxcbiAgICAgICAgICAgICd4LXNkay12ZXJzaW9uJzogJzIxLjQuMCcsXG4gICAgICAgICAgICAnWC1BcHB3cml0ZS1SZXNwb25zZS1Gb3JtYXQnOiAnMS44LjAnLFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnJlYWx0aW1lID0ge1xuICAgICAgICAgICAgc29ja2V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICB0aW1lb3V0OiB1bmRlZmluZWQsXG4gICAgICAgICAgICBoZWFydGJlYXQ6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIHVybDogJycsXG4gICAgICAgICAgICBjaGFubmVsczogbmV3IFNldCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uczogbmV3IE1hcCgpLFxuICAgICAgICAgICAgc3Vic2NyaXB0aW9uc0NvdW50ZXI6IDAsXG4gICAgICAgICAgICByZWNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICByZWNvbm5lY3RBdHRlbXB0czogMCxcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjb25uZWN0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWUudGltZW91dCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS50aW1lb3V0ID0gd2luZG93ID09PSBudWxsIHx8IHdpbmRvdyA9PT0gdm9pZCAwID8gdm9pZCAwIDogd2luZG93LnNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH0sIDUwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaW1lb3V0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA8IDU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTU6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gNTAwMDtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdEF0dGVtcHRzIDwgMTAwOlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDEwMDAwO1xuICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIDYwMDAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVIZWFydGJlYXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5oZWFydGJlYXQpIHtcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRoaXMucmVhbHRpbWUuaGVhcnRiZWF0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5oZWFydGJlYXQgPSB3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cuc2V0SW50ZXJ2YWwoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICAgICAgICAgIChfYSA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2VuZChKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAncGluZydcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIDIwMDAwKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjcmVhdGVTb2NrZXQ6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5jaGFubmVscy5zaXplIDwgMSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAoX2EgPSB0aGlzLnJlYWx0aW1lLnNvY2tldCkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbHMgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY29uZmlnLnByb2plY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMuc2V0KCdwcm9qZWN0JywgdGhpcy5jb25maWcucHJvamVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuZm9yRWFjaChjaGFubmVsID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbHMuYXBwZW5kKCdjaGFubmVsc1tdJywgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3QgdXJsID0gdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSArICcvcmVhbHRpbWU/JyArIGNoYW5uZWxzLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHVybCAhPT0gdGhpcy5yZWFsdGltZS51cmwgfHwgLy8gQ2hlY2sgaWYgVVJMIGlzIHByZXNlbnRcbiAgICAgICAgICAgICAgICAgICAgIXRoaXMucmVhbHRpbWUuc29ja2V0IHx8IC8vIENoZWNrIGlmIFdlYlNvY2tldCBoYXMgbm90IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgICAgICAgICAoKF9iID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5yZWFkeVN0YXRlKSA+IFdlYlNvY2tldC5PUEVOIC8vIENoZWNrIGlmIFdlYlNvY2tldCBpcyBDTE9TSU5HICgzKSBvciBDTE9TRUQgKDQpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnJlYWx0aW1lLnNvY2tldCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKChfYyA9IHRoaXMucmVhbHRpbWUuc29ja2V0KSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVhZHlTdGF0ZSkgPCBXZWJTb2NrZXQuQ0xPU0lORyAvLyBDbG9zZSBXZWJTb2NrZXQgaWYgaXQgaXMgQ09OTkVDVElORyAoMCkgb3IgT1BFTiAoMSlcbiAgICAgICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnVybCA9IHVybDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ21lc3NhZ2UnLCB0aGlzLnJlYWx0aW1lLm9uTWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCBfZXZlbnQgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5yZWNvbm5lY3RBdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNyZWF0ZUhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignY2xvc2UnLCBldmVudCA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX2EsIF9iLCBfYztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5yZWFsdGltZS5yZWNvbm5lY3QgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKChfYiA9IChfYSA9IHRoaXMucmVhbHRpbWUpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sYXN0TWVzc2FnZSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnR5cGUpID09PSAnZXJyb3InICYmIC8vIENoZWNrIGlmIGxhc3QgbWVzc2FnZSB3YXMgb2YgdHlwZSBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9jID0gdGhpcy5yZWFsdGltZSkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmxhc3RNZXNzYWdlLmRhdGEpLmNvZGUgPT09IDEwMDggLy8gQ2hlY2sgZm9yIHBvbGljeSB2aW9sYXRpb24gMTAwOFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLnJlY29ubmVjdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRoaXMucmVhbHRpbWUuZ2V0VGltZW91dCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihgUmVhbHRpbWUgZ290IGRpc2Nvbm5lY3RlZC4gUmVjb25uZWN0IHdpbGwgYmUgYXR0ZW1wdGVkIGluICR7dGltZW91dCAvIDEwMDB9IHNlY29uZHMuYCwgZXZlbnQucmVhc29uKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUucmVjb25uZWN0QXR0ZW1wdHMrKztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbk1lc3NhZ2U6IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZSA9IEpTT04ucGFyc2UoZXZlbnQuZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUubGFzdE1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgc2Vzc2lvbiA9IHRoaXMuY29uZmlnLnNlc3Npb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IEpTT04ucGFyc2UoKF9hID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb29raWVGYWxsYmFjaycpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAne30nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvbiA9IGNvb2tpZSA9PT0gbnVsbCB8fCBjb29raWUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNvb2tpZVtgYV9zZXNzaW9uXyR7dGhpcy5jb25maWcucHJvamVjdH1gXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWVzc2FnZURhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNlc3Npb24gJiYgIW1lc3NhZ2VEYXRhLnVzZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKF9iID0gdGhpcy5yZWFsdGltZS5zb2NrZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zZW5kKEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Vzc2lvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZXZlbnQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGRhdGEuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNTdWJzY3JpYmVkID0gZGF0YS5jaGFubmVscy5zb21lKGNoYW5uZWwgPT4gdGhpcy5yZWFsdGltZS5jaGFubmVscy5oYXMoY2hhbm5lbCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzU3Vic2NyaWJlZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zLmZvckVhY2goc3Vic2NyaXB0aW9uID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLmNoYW5uZWxzLnNvbWUoY2hhbm5lbCA9PiBzdWJzY3JpcHRpb24uY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBzdWJzY3JpcHRpb24uY2FsbGJhY2soZGF0YSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdwb25nJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhazsgLy8gSGFuZGxlIHBvbmcgcmVzcG9uc2UgaWYgbmVlZGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdlcnJvcic6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbWVzc2FnZS5kYXRhO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhblVwOiBjaGFubmVscyA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5mb3JFYWNoKGNoYW5uZWwgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBmb3VuZCA9IEFycmF5LmZyb20odGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zKS5zb21lKChbX2tleSwgc3Vic2NyaXB0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzdWJzY3JpcHRpb24uY2hhbm5lbHMuaW5jbHVkZXMoY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNoYW5uZWxzLmRlbGV0ZShjaGFubmVsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgRW5kcG9pbnRcbiAgICAgKlxuICAgICAqIFlvdXIgcHJvamVjdCBlbmRwb2ludFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRFbmRwb2ludChlbmRwb2ludCkge1xuICAgICAgICBpZiAoIWVuZHBvaW50LnN0YXJ0c1dpdGgoJ2h0dHA6Ly8nKSAmJiAhZW5kcG9pbnQuc3RhcnRzV2l0aCgnaHR0cHM6Ly8nKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdJbnZhbGlkIGVuZHBvaW50IFVSTDogJyArIGVuZHBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbmZpZy5lbmRwb2ludCA9IGVuZHBvaW50O1xuICAgICAgICB0aGlzLmNvbmZpZy5lbmRwb2ludFJlYWx0aW1lID0gZW5kcG9pbnQucmVwbGFjZSgnaHR0cHM6Ly8nLCAnd3NzOi8vJykucmVwbGFjZSgnaHR0cDovLycsICd3czovLycpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IFJlYWx0aW1lIEVuZHBvaW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gZW5kcG9pbnRSZWFsdGltZVxuICAgICAqXG4gICAgICogQHJldHVybnMge3RoaXN9XG4gICAgICovXG4gICAgc2V0RW5kcG9pbnRSZWFsdGltZShlbmRwb2ludFJlYWx0aW1lKSB7XG4gICAgICAgIGlmICghZW5kcG9pbnRSZWFsdGltZS5zdGFydHNXaXRoKCd3czovLycpICYmICFlbmRwb2ludFJlYWx0aW1lLnN0YXJ0c1dpdGgoJ3dzczovLycpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ0ludmFsaWQgcmVhbHRpbWUgZW5kcG9pbnQgVVJMOiAnICsgZW5kcG9pbnRSZWFsdGltZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb25maWcuZW5kcG9pbnRSZWFsdGltZSA9IGVuZHBvaW50UmVhbHRpbWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgUHJvamVjdFxuICAgICAqXG4gICAgICogWW91ciBwcm9qZWN0IElEXG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHNldFByb2plY3QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLVByb2plY3QnXSA9IHZhbHVlO1xuICAgICAgICB0aGlzLmNvbmZpZy5wcm9qZWN0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXQgSldUXG4gICAgICpcbiAgICAgKiBZb3VyIHNlY3JldCBKU09OIFdlYiBUb2tlblxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRKV1QodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLUpXVCddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLmp3dCA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IExvY2FsZVxuICAgICAqXG4gICAgICogQHBhcmFtIHZhbHVlIHN0cmluZ1xuICAgICAqXG4gICAgICogQHJldHVybiB7dGhpc31cbiAgICAgKi9cbiAgICBzZXRMb2NhbGUodmFsdWUpIHtcbiAgICAgICAgdGhpcy5oZWFkZXJzWydYLUFwcHdyaXRlLUxvY2FsZSddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLmxvY2FsZSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IFNlc3Npb25cbiAgICAgKlxuICAgICAqIFRoZSB1c2VyIHNlc3Npb24gdG8gYXV0aGVudGljYXRlIHdpdGhcbiAgICAgKlxuICAgICAqIEBwYXJhbSB2YWx1ZSBzdHJpbmdcbiAgICAgKlxuICAgICAqIEByZXR1cm4ge3RoaXN9XG4gICAgICovXG4gICAgc2V0U2Vzc2lvbih2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ1gtQXBwd3JpdGUtU2Vzc2lvbiddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLnNlc3Npb24gPSB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNldCBEZXZLZXlcbiAgICAgKlxuICAgICAqIFlvdXIgc2VjcmV0IGRldiBBUEkga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0gdmFsdWUgc3RyaW5nXG4gICAgICpcbiAgICAgKiBAcmV0dXJuIHt0aGlzfVxuICAgICAqL1xuICAgIHNldERldktleSh2YWx1ZSkge1xuICAgICAgICB0aGlzLmhlYWRlcnNbJ1gtQXBwd3JpdGUtRGV2LUtleSddID0gdmFsdWU7XG4gICAgICAgIHRoaXMuY29uZmlnLmRldmtleSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU3Vic2NyaWJlcyB0byBBcHB3cml0ZSBldmVudHMgYW5kIHBhc3NlcyB5b3UgdGhlIHBheWxvYWQgaW4gcmVhbHRpbWUuXG4gICAgICpcbiAgICAgKiBAZGVwcmVjYXRlZCBVc2UgdGhlIFJlYWx0aW1lIHNlcnZpY2UgaW5zdGVhZC5cbiAgICAgKiBAc2VlIFJlYWx0aW1lXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ3xzdHJpbmdbXX0gY2hhbm5lbHNcbiAgICAgKiBDaGFubmVsIHRvIHN1YnNjcmliZSAtIHBhc3MgYSBzaW5nbGUgY2hhbm5lbCBhcyBhIHN0cmluZyBvciBtdWx0aXBsZSB3aXRoIGFuIGFycmF5IG9mIHN0cmluZ3MuXG4gICAgICpcbiAgICAgKiBQb3NzaWJsZSBjaGFubmVscyBhcmU6XG4gICAgICogLSBhY2NvdW50XG4gICAgICogLSBjb2xsZWN0aW9uc1xuICAgICAqIC0gY29sbGVjdGlvbnMuW0lEXVxuICAgICAqIC0gY29sbGVjdGlvbnMuW0lEXS5kb2N1bWVudHNcbiAgICAgKiAtIGRvY3VtZW50c1xuICAgICAqIC0gZG9jdW1lbnRzLltJRF1cbiAgICAgKiAtIGZpbGVzXG4gICAgICogLSBmaWxlcy5bSURdXG4gICAgICogLSBleGVjdXRpb25zXG4gICAgICogLSBleGVjdXRpb25zLltJRF1cbiAgICAgKiAtIGZ1bmN0aW9ucy5bSURdXG4gICAgICogLSB0ZWFtc1xuICAgICAqIC0gdGVhbXMuW0lEXVxuICAgICAqIC0gbWVtYmVyc2hpcHNcbiAgICAgKiAtIG1lbWJlcnNoaXBzLltJRF1cbiAgICAgKiBAcGFyYW0geyhwYXlsb2FkOiBSZWFsdGltZU1lc3NhZ2UpID0+IHZvaWR9IGNhbGxiYWNrIElzIGNhbGxlZCBvbiBldmVyeSByZWFsdGltZSB1cGRhdGUuXG4gICAgICogQHJldHVybnMgeygpID0+IHZvaWR9IFVuc3Vic2NyaWJlcyBmcm9tIGV2ZW50cy5cbiAgICAgKi9cbiAgICBzdWJzY3JpYmUoY2hhbm5lbHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxldCBjaGFubmVsQXJyYXkgPSB0eXBlb2YgY2hhbm5lbHMgPT09ICdzdHJpbmcnID8gW2NoYW5uZWxzXSA6IGNoYW5uZWxzO1xuICAgICAgICBjaGFubmVsQXJyYXkuZm9yRWFjaChjaGFubmVsID0+IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuYWRkKGNoYW5uZWwpKTtcbiAgICAgICAgY29uc3QgY291bnRlciA9IHRoaXMucmVhbHRpbWUuc3Vic2NyaXB0aW9uc0NvdW50ZXIrKztcbiAgICAgICAgdGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zLnNldChjb3VudGVyLCB7XG4gICAgICAgICAgICBjaGFubmVsczogY2hhbm5lbEFycmF5LFxuICAgICAgICAgICAgY2FsbGJhY2tcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVhbHRpbWUuY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5zdWJzY3JpcHRpb25zLmRlbGV0ZShjb3VudGVyKTtcbiAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2xlYW5VcChjaGFubmVsQXJyYXkpO1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0KCk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgdXJsLCBoZWFkZXJzID0ge30sIHBhcmFtcyA9IHt9KSB7XG4gICAgICAgIG1ldGhvZCA9IG1ldGhvZC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICBoZWFkZXJzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5oZWFkZXJzLCBoZWFkZXJzKTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5sb2NhbFN0b3JhZ2UpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvb2tpZUZhbGxiYWNrID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb29raWVGYWxsYmFjaycpO1xuICAgICAgICAgICAgaWYgKGNvb2tpZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1snWC1GYWxsYmFjay1Db29raWVzJ10gPSBjb29raWVGYWxsYmFjaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgIGhlYWRlcnMsXG4gICAgICAgIH07XG4gICAgICAgIGlmIChoZWFkZXJzWydYLUFwcHdyaXRlLURldi1LZXknXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBvcHRpb25zLmNyZWRlbnRpYWxzID0gJ2luY2x1ZGUnO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgPT09ICdHRVQnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhDbGllbnQuZmxhdHRlbihwYXJhbXMpKSkge1xuICAgICAgICAgICAgICAgIHVybC5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3dpdGNoIChoZWFkZXJzWydjb250ZW50LXR5cGUnXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FwcGxpY2F0aW9uL2pzb24nOlxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBKU09OLnN0cmluZ2lmeShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdtdWx0aXBhcnQvZm9ybS1kYXRhJzpcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMocGFyYW1zKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlLCB2YWx1ZS5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRWYWx1ZSBvZiB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoYCR7a2V5fVtdYCwgbmVzdGVkVmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLmJvZHkgPSBmb3JtRGF0YTtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyB1cmk6IHVybC50b1N0cmluZygpLCBvcHRpb25zIH07XG4gICAgfVxuICAgIGNodW5rZWRVcGxvYWQobWV0aG9kLCB1cmwsIGhlYWRlcnMgPSB7fSwgb3JpZ2luYWxQYXlsb2FkID0ge30sIG9uUHJvZ3Jlc3MpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgW2ZpbGVQYXJhbSwgZmlsZV0gPSAoX2EgPSBPYmplY3QuZW50cmllcyhvcmlnaW5hbFBheWxvYWQpLmZpbmQoKFtfLCB2YWx1ZV0pID0+IHZhbHVlIGluc3RhbmNlb2YgRmlsZSkpICE9PSBudWxsICYmIF9hICE9PSB2b2lkIDAgPyBfYSA6IFtdO1xuICAgICAgICAgICAgaWYgKCFmaWxlIHx8ICFmaWxlUGFyYW0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpbGUgbm90IGZvdW5kIGluIHBheWxvYWQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChmaWxlLnNpemUgPD0gQ2xpZW50LkNIVU5LX1NJWkUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5jYWxsKG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBvcmlnaW5hbFBheWxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgICAgICAgIGxldCByZXNwb25zZSA9IG51bGw7XG4gICAgICAgICAgICB3aGlsZSAoc3RhcnQgPCBmaWxlLnNpemUpIHtcbiAgICAgICAgICAgICAgICBsZXQgZW5kID0gc3RhcnQgKyBDbGllbnQuQ0hVTktfU0laRTsgLy8gUHJlcGFyZSBlbmQgZm9yIHRoZSBuZXh0IGNodW5rXG4gICAgICAgICAgICAgICAgaWYgKGVuZCA+PSBmaWxlLnNpemUpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5kID0gZmlsZS5zaXplOyAvLyBBZGp1c3QgZm9yIHRoZSBsYXN0IGNodW5rIHRvIGluY2x1ZGUgdGhlIGxhc3QgYnl0ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXJhbmdlJ10gPSBgYnl0ZXMgJHtzdGFydH0tJHtlbmQgLSAxfS8ke2ZpbGUuc2l6ZX1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNodW5rID0gZmlsZS5zbGljZShzdGFydCwgZW5kKTtcbiAgICAgICAgICAgICAgICBsZXQgcGF5bG9hZCA9IE9iamVjdC5hc3NpZ24oe30sIG9yaWdpbmFsUGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgcGF5bG9hZFtmaWxlUGFyYW1dID0gbmV3IEZpbGUoW2NodW5rXSwgZmlsZS5uYW1lKTtcbiAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIHRoaXMuY2FsbChtZXRob2QsIHVybCwgaGVhZGVycywgcGF5bG9hZCk7XG4gICAgICAgICAgICAgICAgaWYgKG9uUHJvZ3Jlc3MgJiYgdHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Qcm9ncmVzcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAkaWQ6IHJlc3BvbnNlLiRpZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzOiBNYXRoLnJvdW5kKChlbmQgLyBmaWxlLnNpemUpICogMTAwKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNpemVVcGxvYWRlZDogZW5kLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2h1bmtzVG90YWw6IE1hdGguY2VpbChmaWxlLnNpemUgLyBDbGllbnQuQ0hVTktfU0laRSksXG4gICAgICAgICAgICAgICAgICAgICAgICBjaHVua3NVcGxvYWRlZDogTWF0aC5jZWlsKGVuZCAvIENsaWVudC5DSFVOS19TSVpFKVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlICYmIHJlc3BvbnNlLiRpZCkge1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzWyd4LWFwcHdyaXRlLWlkJ10gPSByZXNwb25zZS4kaWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0YXJ0ID0gZW5kO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGluZygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNhbGwoJ0dFVCcsIG5ldyBVUkwodGhpcy5jb25maWcuZW5kcG9pbnQgKyAnL3BpbmcnKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKG1ldGhvZCwgdXJsLCBoZWFkZXJzID0ge30sIHBhcmFtcyA9IHt9LCByZXNwb25zZVR5cGUgPSAnanNvbicpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdXJpLCBvcHRpb25zIH0gPSB0aGlzLnByZXBhcmVSZXF1ZXN0KG1ldGhvZCwgdXJsLCBoZWFkZXJzLCBwYXJhbXMpO1xuICAgICAgICAgICAgbGV0IGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaCh1cmksIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy8gdHlwZSBvcGFxdWU6IE5vLUNPUlMsIGRpZmZlcmVudC1vcmlnaW4gcmVzcG9uc2UgKENPUlMtaXNzdWUpXG4gICAgICAgICAgICBpZiAocmVzcG9uc2UudHlwZSA9PT0gJ29wYXF1ZScpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oYEludmFsaWQgT3JpZ2luLiBSZWdpc3RlciB5b3VyIG5ldyBjbGllbnQgKCR7d2luZG93LmxvY2F0aW9uLmhvc3R9KSBhcyBhIG5ldyBXZWIgcGxhdGZvcm0gb24geW91ciBwcm9qZWN0IGNvbnNvbGUgZGFzaGJvYXJkYCwgNDAzLCBcImZvcmJpZGRlblwiLCBcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdhcm5pbmdzID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ3gtYXBwd3JpdGUtd2FybmluZycpO1xuICAgICAgICAgICAgaWYgKHdhcm5pbmdzKSB7XG4gICAgICAgICAgICAgICAgd2FybmluZ3Muc3BsaXQoJzsnKS5mb3JFYWNoKCh3YXJuaW5nKSA9PiBjb25zb2xlLndhcm4oJ1dhcm5pbmc6ICcgKyB3YXJuaW5nKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKF9hID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoJ2NvbnRlbnQtdHlwZScpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5jbHVkZXMoJ2FwcGxpY2F0aW9uL2pzb24nKSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB5aWVsZCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXNwb25zZVR5cGUgPT09ICdhcnJheUJ1ZmZlcicpIHtcbiAgICAgICAgICAgICAgICBkYXRhID0geWllbGQgcmVzcG9uc2UuYXJyYXlCdWZmZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGEgPSB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2U6IHlpZWxkIHJlc3BvbnNlLnRleHQoKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoNDAwIDw9IHJlc3BvbnNlLnN0YXR1cykge1xuICAgICAgICAgICAgICAgIGxldCByZXNwb25zZVRleHQgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoKChfYiA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdjb250ZW50LXR5cGUnKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykpIHx8IHJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5QnVmZmVyJykge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZVRleHQgPSBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlVGV4dCA9IGRhdGEgPT09IG51bGwgfHwgZGF0YSA9PT0gdm9pZCAwID8gdm9pZCAwIDogZGF0YS5tZXNzYWdlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLm1lc3NhZ2UsIHJlc3BvbnNlLnN0YXR1cywgZGF0YSA9PT0gbnVsbCB8fCBkYXRhID09PSB2b2lkIDAgPyB2b2lkIDAgOiBkYXRhLnR5cGUsIHJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjb29raWVGYWxsYmFjayA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCdYLUZhbGxiYWNrLUNvb2tpZXMnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cubG9jYWxTdG9yYWdlICYmIGNvb2tpZUZhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgd2luZG93LmNvbnNvbGUud2FybignQXBwd3JpdGUgaXMgdXNpbmcgbG9jYWxTdG9yYWdlIGZvciBzZXNzaW9uIG1hbmFnZW1lbnQuIEluY3JlYXNlIHlvdXIgc2VjdXJpdHkgYnkgYWRkaW5nIGEgY3VzdG9tIGRvbWFpbiBhcyB5b3VyIEFQSSBlbmRwb2ludC4nKTtcbiAgICAgICAgICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oJ2Nvb2tpZUZhbGxiYWNrJywgY29va2llRmFsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZmxhdHRlbihkYXRhLCBwcmVmaXggPSAnJykge1xuICAgICAgICBsZXQgb3V0cHV0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGRhdGEpKSB7XG4gICAgICAgICAgICBsZXQgZmluYWxLZXkgPSBwcmVmaXggPyBwcmVmaXggKyAnWycgKyBrZXkgKyAnXScgOiBrZXk7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBvdXRwdXQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG91dHB1dCksIENsaWVudC5mbGF0dGVuKHZhbHVlLCBmaW5hbEtleSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0W2ZpbmFsS2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvdXRwdXQ7XG4gICAgfVxufVxuQ2xpZW50LkNIVU5LX1NJWkUgPSAxMDI0ICogMTAyNCAqIDU7XG5cbmNsYXNzIFNlcnZpY2Uge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgc3RhdGljIGZsYXR0ZW4oZGF0YSwgcHJlZml4ID0gJycpIHtcbiAgICAgICAgbGV0IG91dHB1dCA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhkYXRhKSkge1xuICAgICAgICAgICAgbGV0IGZpbmFsS2V5ID0gcHJlZml4ID8gcHJlZml4ICsgJ1snICsga2V5ICsgJ10nIDoga2V5O1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgb3V0cHV0ID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBvdXRwdXQpLCBTZXJ2aWNlLmZsYXR0ZW4odmFsdWUsIGZpbmFsS2V5KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBvdXRwdXRbZmluYWxLZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG91dHB1dDtcbiAgICB9XG59XG4vKipcbiAqIFRoZSBzaXplIGZvciBjaHVua2VkIHVwbG9hZHMgaW4gYnl0ZXMuXG4gKi9cblNlcnZpY2UuQ0hVTktfU0laRSA9IDUgKiAxMDI0ICogMTAyNDsgLy8gNU1CXG5cbmNsYXNzIEFjY291bnQge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuVXNlcjxQcmVmZXJlbmNlcz4+fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZW1haWw6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcGFzc3dvcmQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgbmFtZTogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50JztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bhc3N3b3JkJ10gPSBwYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZUVtYWlsKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9lbWFpbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBsaXN0SWRlbnRpdGllcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2lkZW50aXRpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVJZGVudGl0eShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgaWRlbnRpdHlJZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpZGVudGl0eUlkID0gcGFyYW1zLmlkZW50aXR5SWQ7XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpdHlJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiaWRlbnRpdHlJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9pZGVudGl0aWVzL3tpZGVudGl0eUlkfScucmVwbGFjZSgne2lkZW50aXR5SWR9JywgaWRlbnRpdHlJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBjcmVhdGUgYSBKU09OIFdlYiBUb2tlbi4gWW91IGNhbiB1c2UgdGhlIHJlc3VsdGluZyBKV1QgdG8gYXV0aGVudGljYXRlIG9uIGJlaGFsZiBvZiB0aGUgY3VycmVudCB1c2VyIHdoZW4gd29ya2luZyB3aXRoIHRoZSBBcHB3cml0ZSBzZXJ2ZXItc2lkZSBBUEkgYW5kIFNES3MuIFRoZSBKV1Qgc2VjcmV0IGlzIHZhbGlkIGZvciAxNSBtaW51dGVzIGZyb20gaXRzIGNyZWF0aW9uIGFuZCB3aWxsIGJlIGludmFsaWQgaWYgdGhlIHVzZXIgd2lsbCBsb2dvdXQgaW4gdGhhdCB0aW1lIGZyYW1lLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkp3dD59XG4gICAgICovXG4gICAgY3JlYXRlSldUKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L2p3dHMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGxpc3RMb2dzKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKCFwYXJhbXNPckZpcnN0IHx8IChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3QgdG90YWwgPSBwYXJhbXMudG90YWw7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbG9ncyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1GQShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgbWZhOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1mYSA9IHBhcmFtcy5tZmE7XG4gICAgICAgIGlmICh0eXBlb2YgbWZhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZmFcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG1mYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21mYSddID0gbWZhO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVNZmFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU1GQUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcmFtcy50eXBlO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTWZhQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvdHA6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHlwZSA9IHBhcmFtcy50eXBlO1xuICAgICAgICBjb25zdCBvdHAgPSBwYXJhbXMub3RwO1xuICAgICAgICBpZiAodHlwZW9mIHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInR5cGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2F1dGhlbnRpY2F0b3JzL3t0eXBlfScucmVwbGFjZSgne3R5cGV9JywgdHlwZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvdHAnXSA9IG90cDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1GQUF1dGhlbnRpY2F0b3IocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICd0eXBlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3RwOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgY29uc3Qgb3RwID0gcGFyYW1zLm90cDtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwib3RwXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVNZmFBdXRoZW50aWNhdG9yKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAndHlwZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHR5cGUgPSBwYXJhbXMudHlwZTtcbiAgICAgICAgaWYgKHR5cGVvZiB0eXBlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0eXBlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9hdXRoZW50aWNhdG9ycy97dHlwZX0nLnJlcGxhY2UoJ3t0eXBlfScsIHR5cGUpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlTUZBQXV0aGVudGljYXRvcihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3R5cGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eXBlID0gcGFyYW1zLnR5cGU7XG4gICAgICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHlwZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvYXV0aGVudGljYXRvcnMve3R5cGV9Jy5yZXBsYWNlKCd7dHlwZX0nLCB0eXBlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU1mYUNoYWxsZW5nZShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ2ZhY3RvcicgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmYWN0b3I6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yID0gcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZhY3RvclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhY3RvciddID0gZmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU1GQUNoYWxsZW5nZShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ2ZhY3RvcicgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBmYWN0b3I6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZmFjdG9yID0gcGFyYW1zLmZhY3RvcjtcbiAgICAgICAgaWYgKHR5cGVvZiBmYWN0b3IgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZhY3RvclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGZhY3RvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhY3RvciddID0gZmFjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1mYUNoYWxsZW5nZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY2hhbGxlbmdlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3RwOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNoYWxsZW5nZUlkID0gcGFyYW1zLmNoYWxsZW5nZUlkO1xuICAgICAgICBjb25zdCBvdHAgPSBwYXJhbXMub3RwO1xuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjaGFsbGVuZ2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvdHAgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm90cFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvY2hhbGxlbmdlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNoYWxsZW5nZUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY2hhbGxlbmdlSWQnXSA9IGNoYWxsZW5nZUlkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3RwJ10gPSBvdHA7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVNRkFDaGFsbGVuZ2UocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNoYWxsZW5nZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG90cDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFsbGVuZ2VJZCA9IHBhcmFtcy5jaGFsbGVuZ2VJZDtcbiAgICAgICAgY29uc3Qgb3RwID0gcGFyYW1zLm90cDtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY2hhbGxlbmdlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3RwID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJvdHBcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2NoYWxsZW5nZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBjaGFsbGVuZ2VJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2NoYWxsZW5nZUlkJ10gPSBjaGFsbGVuZ2VJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG90cCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ290cCddID0gb3RwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgZmFjdG9ycyBhdmFpbGFibGUgb24gdGhlIGFjY291bnQgdG8gYmUgdXNlZCBhcyBhIE1GQSBjaGFsbGFuZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhRmFjdG9ycz59XG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSAxLjguMC4gUGxlYXNlIHVzZSBgQWNjb3VudC5saXN0TUZBRmFjdG9yc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICBsaXN0TWZhRmFjdG9ycygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvZmFjdG9ycyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCB0aGUgZmFjdG9ycyBhdmFpbGFibGUgb24gdGhlIGFjY291bnQgdG8gYmUgdXNlZCBhcyBhIE1GQSBjaGFsbGFuZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhRmFjdG9ycz59XG4gICAgICovXG4gICAgbGlzdE1GQUZhY3RvcnMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL2ZhY3RvcnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZSBnZXR0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZ2VuZXJhdGVkIHVzaW5nIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKSBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVhZCByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKiBAZGVwcmVjYXRlZCBUaGlzIEFQSSBoYXMgYmVlbiBkZXByZWNhdGVkIHNpbmNlIDEuOC4wLiBQbGVhc2UgdXNlIGBBY2NvdW50LmdldE1GQVJlY292ZXJ5Q29kZXNgIGluc3RlYWQuXG4gICAgICovXG4gICAgZ2V0TWZhUmVjb3ZlcnlDb2RlcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9tZmEvcmVjb3ZlcnktY29kZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZSBnZXR0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZ2VuZXJhdGVkIHVzaW5nIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKSBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVhZCByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKi9cbiAgICBnZXRNRkFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgYXMgYmFja3VwIGZvciBNRkEgZmxvdy4gSXQncyByZWNvbW1lbmRlZCB0byBnZW5lcmF0ZSBhbmQgc2hvdyB0aGVuIGltbWVkaWF0ZWx5IGFmdGVyIHVzZXIgc3VjY2Vzc2Z1bGx5IGFkZHMgdGhlaXIgYXV0aGVodGljYXRvci4gUmVjb3ZlcnkgY29kZXMgY2FuIGJlIHVzZWQgYXMgYSBNRkEgdmVyaWZpY2F0aW9uIHR5cGUgaW4gW2NyZWF0ZU1mYUNoYWxsZW5nZV0oL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjY3JlYXRlTWZhQ2hhbGxlbmdlKSBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuTWZhUmVjb3ZlcnlDb2Rlcz59XG4gICAgICogQGRlcHJlY2F0ZWQgVGhpcyBBUEkgaGFzIGJlZW4gZGVwcmVjYXRlZCBzaW5jZSAxLjguMC4gUGxlYXNlIHVzZSBgQWNjb3VudC5jcmVhdGVNRkFSZWNvdmVyeUNvZGVzYCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGNyZWF0ZU1mYVJlY292ZXJ5Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbWZhL3JlY292ZXJ5LWNvZGVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBJdCdzIHJlY29tbWVuZGVkIHRvIGdlbmVyYXRlIGFuZCBzaG93IHRoZW4gaW1tZWRpYXRlbHkgYWZ0ZXIgdXNlciBzdWNjZXNzZnVsbHkgYWRkcyB0aGVpciBhdXRoZWh0aWNhdG9yLiBSZWNvdmVyeSBjb2RlcyBjYW4gYmUgdXNlZCBhcyBhIE1GQSB2ZXJpZmljYXRpb24gdHlwZSBpbiBbY3JlYXRlTWZhQ2hhbGxlbmdlXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFDaGFsbGVuZ2UpIG1ldGhvZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKi9cbiAgICBjcmVhdGVNRkFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVnZW5lcmF0ZSByZWNvdmVyeSBjb2RlcyB0aGF0IGNhbiBiZSB1c2VkIGFzIGJhY2t1cCBmb3IgTUZBIGZsb3cuIEJlZm9yZSByZWdlbmVyYXRpbmcgY29kZXMsIHRoZXkgbXVzdCBiZSBmaXJzdCBnZW5lcmF0ZWQgdXNpbmcgW2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXNdKC9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I2NyZWF0ZU1mYVJlY292ZXJ5Q29kZXMpIG1ldGhvZC4gQW4gT1RQIGNoYWxsZW5nZSBpcyByZXF1aXJlZCB0byByZWdlbnJlYXRlIHJlY292ZXJ5IGNvZGVzLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLk1mYVJlY292ZXJ5Q29kZXM+fVxuICAgICAqIEBkZXByZWNhdGVkIFRoaXMgQVBJIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgMS44LjAuIFBsZWFzZSB1c2UgYEFjY291bnQudXBkYXRlTUZBUmVjb3ZlcnlDb2Rlc2AgaW5zdGVhZC5cbiAgICAgKi9cbiAgICB1cGRhdGVNZmFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2VuZXJhdGUgcmVjb3ZlcnkgY29kZXMgdGhhdCBjYW4gYmUgdXNlZCBhcyBiYWNrdXAgZm9yIE1GQSBmbG93LiBCZWZvcmUgcmVnZW5lcmF0aW5nIGNvZGVzLCB0aGV5IG11c3QgYmUgZmlyc3QgZ2VuZXJhdGVkIHVzaW5nIFtjcmVhdGVNZmFSZWNvdmVyeUNvZGVzXSgvZG9jcy9yZWZlcmVuY2VzL2Nsb3VkL2NsaWVudC13ZWIvYWNjb3VudCNjcmVhdGVNZmFSZWNvdmVyeUNvZGVzKSBtZXRob2QuIEFuIE9UUCBjaGFsbGVuZ2UgaXMgcmVxdWlyZWQgdG8gcmVnZW5yZWF0ZSByZWNvdmVyeSBjb2Rlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5NZmFSZWNvdmVyeUNvZGVzPn1cbiAgICAgKi9cbiAgICB1cGRhdGVNRkFSZWNvdmVyeUNvZGVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L21mYS9yZWNvdmVyeS1jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU5hbWUocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvbmFtZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUGFzc3dvcmQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG9sZFBhc3N3b3JkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhc3N3b3JkID0gcGFyYW1zLnBhc3N3b3JkO1xuICAgICAgICBjb25zdCBvbGRQYXNzd29yZCA9IHBhcmFtcy5vbGRQYXNzd29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcGFzc3dvcmQnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvbGRQYXNzd29yZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29sZFBhc3N3b3JkJ10gPSBvbGRQYXNzd29yZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUGhvbmUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHBob25lOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHBhc3N3b3JkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBob25lID0gcGFyYW1zLnBob25lO1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGhvbmVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInBhc3N3b3JkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHBob25lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhvbmUnXSA9IHBob25lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGFzc3dvcmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXNzd29yZCddID0gcGFzc3dvcmQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgcHJlZmVyZW5jZXMgYXMgYSBrZXktdmFsdWUgb2JqZWN0IGZvciB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8UHJlZmVyZW5jZXM+fVxuICAgICAqL1xuICAgIGdldFByZWZzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ByZWZzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQcmVmcyhwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3ByZWZzJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHByZWZzOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByZWZzID0gcGFyYW1zLnByZWZzO1xuICAgICAgICBpZiAodHlwZW9mIHByZWZzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcmVmc1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9wcmVmcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBwcmVmcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3ByZWZzJ10gPSBwcmVmcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlUmVjb3ZlcnkocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGVtYWlsOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHVybDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZW1haWxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcmVjb3ZlcnknO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydlbWFpbCddID0gZW1haWw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVSZWNvdmVyeShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBjb25zdCBwYXNzd29yZCA9IHBhcmFtcy5wYXNzd29yZDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwYXNzd29yZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicGFzc3dvcmRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvcmVjb3ZlcnknO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFjdGl2ZSBzZXNzaW9ucyBhY3Jvc3MgZGlmZmVyZW50IGRldmljZXMgZm9yIHRoZSBjdXJyZW50bHkgbG9nZ2VkIGluIHVzZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuU2Vzc2lvbkxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RTZXNzaW9ucygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVsZXRlIGFsbCBzZXNzaW9ucyBmcm9tIHRoZSB1c2VyIGFjY291bnQgYW5kIHJlbW92ZSBhbnkgc2Vzc2lvbnMgY29va2llcyBmcm9tIHRoZSBlbmQgY2xpZW50LlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8e30+fVxuICAgICAqL1xuICAgIGRlbGV0ZVNlc3Npb25zKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFVzZSB0aGlzIGVuZHBvaW50IHRvIGFsbG93IGEgbmV3IHVzZXIgdG8gcmVnaXN0ZXIgYW4gYW5vbnltb3VzIGFjY291bnQgaW4geW91ciBwcm9qZWN0LiBUaGlzIHJvdXRlIHdpbGwgYWxzbyBjcmVhdGUgYSBuZXcgc2Vzc2lvbiBmb3IgdGhlIHVzZXIuIFRvIGFsbG93IHRoZSBuZXcgdXNlciB0byBjb252ZXJ0IGFuIGFub255bW91cyBhY2NvdW50IHRvIGEgbm9ybWFsIGFjY291bnQsIHlvdSBuZWVkIHRvIHVwZGF0ZSBpdHMgW2VtYWlsIGFuZCBwYXNzd29yZF0oaHR0cHM6Ly9hcHB3cml0ZS5pby9kb2NzL3JlZmVyZW5jZXMvY2xvdWQvY2xpZW50LXdlYi9hY2NvdW50I3VwZGF0ZUVtYWlsKSBvciBjcmVhdGUgYW4gW09BdXRoMiBzZXNzaW9uXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjQ3JlYXRlT0F1dGgyU2Vzc2lvbikuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuU2Vzc2lvbj59XG4gICAgICovXG4gICAgY3JlYXRlQW5vbnltb3VzU2Vzc2lvbigpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9hbm9ueW1vdXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZUVtYWlsUGFzc3dvcmRTZXNzaW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBlbWFpbDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBwYXNzd29yZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBlbWFpbCA9IHBhcmFtcy5lbWFpbDtcbiAgICAgICAgY29uc3QgcGFzc3dvcmQgPSBwYXJhbXMucGFzc3dvcmQ7XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwYXNzd29yZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9lbWFpbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhc3N3b3JkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGFzc3dvcmQnXSA9IHBhc3N3b3JkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1hZ2ljVVJMU2Vzc2lvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL21hZ2ljLXVybCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NlY3JldCddID0gc2VjcmV0O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlT0F1dGgyU2Vzc2lvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3Byb3ZpZGVyJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHN1Y2Nlc3M6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZmFpbHVyZTogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBzY29wZXM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBwYXJhbXMucHJvdmlkZXI7XG4gICAgICAgIGNvbnN0IHN1Y2Nlc3MgPSBwYXJhbXMuc3VjY2VzcztcbiAgICAgICAgY29uc3QgZmFpbHVyZSA9IHBhcmFtcy5mYWlsdXJlO1xuICAgICAgICBjb25zdCBzY29wZXMgPSBwYXJhbXMuc2NvcGVzO1xuICAgICAgICBpZiAodHlwZW9mIHByb3ZpZGVyID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcm92aWRlclwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy9vYXV0aDIve3Byb3ZpZGVyfScucmVwbGFjZSgne3Byb3ZpZGVyfScsIHByb3ZpZGVyKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHN1Y2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzdWNjZXNzJ10gPSBzdWNjZXNzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmFpbHVyZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2ZhaWx1cmUnXSA9IGZhaWx1cmU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY29wZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzY29wZXMnXSA9IHNjb3BlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICh3aW5kb3cgPT09IG51bGwgfHwgd2luZG93ID09PSB2b2lkIDAgPyB2b2lkIDAgOiB3aW5kb3cubG9jYXRpb24pKSB7XG4gICAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaHJlZiA9IHVyaS50b1N0cmluZygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHVwZGF0ZVBob25lU2Vzc2lvbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNlY3JldDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBzZWNyZXQgPSBwYXJhbXMuc2VjcmV0O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNlY3JldCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2VjcmV0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVTZXNzaW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvc2Vzc2lvbnMvdG9rZW4nO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWNyZXQnXSA9IHNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRTZXNzaW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2Vzc2lvbklkID0gcGFyYW1zLnNlc3Npb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXNzaW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlc3Npb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC9zZXNzaW9ucy97c2Vzc2lvbklkfScucmVwbGFjZSgne3Nlc3Npb25JZH0nLCBzZXNzaW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVNlc3Npb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwYXJhbXMuc2Vzc2lvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZVNlc3Npb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHNlc3Npb25JZDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZXNzaW9uSWQgPSBwYXJhbXMuc2Vzc2lvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHNlc3Npb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic2Vzc2lvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Nlc3Npb25zL3tzZXNzaW9uSWR9Jy5yZXBsYWNlKCd7c2Vzc2lvbklkfScsIHNlc3Npb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBCbG9jayB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyIGFjY291bnQuIEJlaGluZCB0aGUgc2NlbmUsIHRoZSB1c2VyIHJlY29yZCBpcyBub3QgZGVsZXRlZCBidXQgcGVybWFuZW50bHkgYmxvY2tlZCBmcm9tIGFueSBhY2Nlc3MuIFRvIGNvbXBsZXRlbHkgZGVsZXRlIGEgdXNlciwgdXNlIHRoZSBVc2VycyBBUEkgaW5zdGVhZC5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Vc2VyPFByZWZlcmVuY2VzPj59XG4gICAgICovXG4gICAgdXBkYXRlU3RhdHVzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3N0YXR1cyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZVB1c2hUYXJnZXQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRhcmdldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcHJvdmlkZXJJZDogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHBhcmFtcy50YXJnZXRJZDtcbiAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IHBhcmFtcy5pZGVudGlmaWVyO1xuICAgICAgICBjb25zdCBwcm92aWRlcklkID0gcGFyYW1zLnByb3ZpZGVySWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aWZpZXJcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdGFyZ2V0cy9wdXNoJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGFyZ2V0SWQnXSA9IHRhcmdldElkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaWRlbnRpZmllciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2lkZW50aWZpZXInXSA9IGlkZW50aWZpZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJvdmlkZXJJZCddID0gcHJvdmlkZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQdXNoVGFyZ2V0KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0YXJnZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBpZGVudGlmaWVyOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gcGFyYW1zLnRhcmdldElkO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gcGFyYW1zLmlkZW50aWZpZXI7XG4gICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhcmdldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGlkZW50aWZpZXIgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImlkZW50aWZpZXJcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdGFyZ2V0cy97dGFyZ2V0SWR9L3B1c2gnLnJlcGxhY2UoJ3t0YXJnZXRJZH0nLCB0YXJnZXRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBpZGVudGlmaWVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaWRlbnRpZmllciddID0gaWRlbnRpZmllcjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZVB1c2hUYXJnZXQocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRhcmdldElkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRhcmdldElkID0gcGFyYW1zLnRhcmdldElkO1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90YXJnZXRzL3t0YXJnZXRJZH0vcHVzaCcucmVwbGFjZSgne3RhcmdldElkfScsIHRhcmdldElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZUVtYWlsVG9rZW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBlbWFpbDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBwaHJhc2U6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHBocmFzZSA9IHBhcmFtcy5waHJhc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9lbWFpbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1c2VySWQnXSA9IHVzZXJJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhyYXNlJ10gPSBwaHJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlTWFnaWNVUkxUb2tlbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGVtYWlsOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHVybDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBwaHJhc2U6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3QgZW1haWwgPSBwYXJhbXMuZW1haWw7XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGNvbnN0IHBocmFzZSA9IHBhcmFtcy5waHJhc2U7XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZW1haWwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImVtYWlsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3Rva2Vucy9tYWdpYy11cmwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBlbWFpbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2VtYWlsJ10gPSBlbWFpbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGhyYXNlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGhyYXNlJ10gPSBwaHJhc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlT0F1dGgyVG9rZW4ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdwcm92aWRlcicgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzdWNjZXNzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGZhaWx1cmU6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgc2NvcGVzOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb3ZpZGVyID0gcGFyYW1zLnByb3ZpZGVyO1xuICAgICAgICBjb25zdCBzdWNjZXNzID0gcGFyYW1zLnN1Y2Nlc3M7XG4gICAgICAgIGNvbnN0IGZhaWx1cmUgPSBwYXJhbXMuZmFpbHVyZTtcbiAgICAgICAgY29uc3Qgc2NvcGVzID0gcGFyYW1zLnNjb3BlcztcbiAgICAgICAgaWYgKHR5cGVvZiBwcm92aWRlciA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicHJvdmlkZXJcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdG9rZW5zL29hdXRoMi97cHJvdmlkZXJ9Jy5yZXBsYWNlKCd7cHJvdmlkZXJ9JywgcHJvdmlkZXIpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3VjY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3N1Y2Nlc3MnXSA9IHN1Y2Nlc3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmYWlsdXJlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZmFpbHVyZSddID0gZmFpbHVyZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHNjb3BlcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Njb3BlcyddID0gc2NvcGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKHdpbmRvdyA9PT0gbnVsbCB8fCB3aW5kb3cgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHdpbmRvdy5sb2NhdGlvbikpIHtcbiAgICAgICAgICAgIHdpbmRvdy5sb2NhdGlvbi5ocmVmID0gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlUGhvbmVUb2tlbihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXNlcklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHBob25lOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHBob25lID0gcGFyYW1zLnBob25lO1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXNlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBob25lID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwaG9uZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC90b2tlbnMvcGhvbmUnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVFbWFpbFZlcmlmaWNhdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVybCA9IHBhcmFtcy51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgdXJsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1cmxcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9ucy9lbWFpbCc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVWZXJpZmljYXRpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVybDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBpZiAodHlwZW9mIHVybCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidXJsXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hY2NvdW50L3ZlcmlmaWNhdGlvbnMvZW1haWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlRW1haWxWZXJpZmljYXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb25zL2VtYWlsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVWZXJpZmljYXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb25zL2VtYWlsJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVc2UgdGhpcyBlbmRwb2ludCB0byBzZW5kIGEgdmVyaWZpY2F0aW9uIFNNUyB0byB0aGUgY3VycmVudGx5IGxvZ2dlZCBpbiB1c2VyLiBUaGlzIGVuZHBvaW50IGlzIG1lYW50IGZvciB1c2UgYWZ0ZXIgdXBkYXRpbmcgYSB1c2VyJ3MgcGhvbmUgbnVtYmVyIHVzaW5nIHRoZSBbYWNjb3VudFVwZGF0ZVBob25lXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmUpIGVuZHBvaW50LiBMZWFybiBtb3JlIGFib3V0IGhvdyB0byBbY29tcGxldGUgdGhlIHZlcmlmaWNhdGlvbiBwcm9jZXNzXShodHRwczovL2FwcHdyaXRlLmlvL2RvY3MvcmVmZXJlbmNlcy9jbG91ZC9jbGllbnQtd2ViL2FjY291bnQjdXBkYXRlUGhvbmVWZXJpZmljYXRpb24pLiBUaGUgdmVyaWZpY2F0aW9uIGNvZGUgc2VudCB0byB0aGUgdXNlcidzIHBob25lIG51bWJlciBpcyB2YWxpZCBmb3IgMTUgbWludXRlcy5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Ub2tlbj59XG4gICAgICovXG4gICAgY3JlYXRlUGhvbmVWZXJpZmljYXRpb24oKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2FjY291bnQvdmVyaWZpY2F0aW9ucy9waG9uZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlUGhvbmVWZXJpZmljYXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHVzZXJJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzZWNyZXQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXNlcklkID0gcGFyYW1zLnVzZXJJZDtcbiAgICAgICAgY29uc3Qgc2VjcmV0ID0gcGFyYW1zLnNlY3JldDtcbiAgICAgICAgaWYgKHR5cGVvZiB1c2VySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVzZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWNyZXQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInNlY3JldFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYWNjb3VudC92ZXJpZmljYXRpb25zL3Bob25lJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbn1cblxuY2xhc3MgQXZhdGFycyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBnZXRCcm93c2VyKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSAmJiAnY29kZScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBjb2RlOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBxdWFsaXR5OiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvZGUgPSBwYXJhbXMuY29kZTtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IHF1YWxpdHkgPSBwYXJhbXMucXVhbGl0eTtcbiAgICAgICAgaWYgKHR5cGVvZiBjb2RlID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2RlXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2Jyb3dzZXJzL3tjb2RlfScucmVwbGFjZSgne2NvZGV9JywgY29kZSk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB3aWR0aCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3dpZHRoJ10gPSB3aWR0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGhlaWdodCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlaWdodCddID0gaGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcXVhbGl0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1YWxpdHknXSA9IHF1YWxpdHk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0Q3JlZGl0Q2FyZChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ2NvZGUnIGluIHBhcmFtc09yRmlyc3QpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgY29kZTogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB3aWR0aDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb2RlID0gcGFyYW1zLmNvZGU7XG4gICAgICAgIGNvbnN0IHdpZHRoID0gcGFyYW1zLndpZHRoO1xuICAgICAgICBjb25zdCBoZWlnaHQgPSBwYXJhbXMuaGVpZ2h0O1xuICAgICAgICBjb25zdCBxdWFsaXR5ID0gcGFyYW1zLnF1YWxpdHk7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29kZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9jcmVkaXQtY2FyZHMve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRGYXZpY29uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9mYXZpY29uJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVybCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VybCddID0gdXJsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEZsYWcocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdjb2RlJyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGNvZGU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHF1YWxpdHk6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZSA9IHBhcmFtcy5jb2RlO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBpZiAodHlwZW9mIGNvZGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvZGVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2F2YXRhcnMvZmxhZ3Mve2NvZGV9Jy5yZXBsYWNlKCd7Y29kZX0nLCBjb2RlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBxdWFsaXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVhbGl0eSddID0gcXVhbGl0eTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRJbWFnZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdXJsOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHdpZHRoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGhlaWdodDogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmwgPSBwYXJhbXMudXJsO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInVybFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvYXZhdGFycy9pbWFnZSc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiB1cmwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd1cmwnXSA9IHVybDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgZ2V0SW5pdGlhbHMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIG5hbWU6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBjb25zdCB3aWR0aCA9IHBhcmFtcy53aWR0aDtcbiAgICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyYW1zLmhlaWdodDtcbiAgICAgICAgY29uc3QgYmFja2dyb3VuZCA9IHBhcmFtcy5iYWNrZ3JvdW5kO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL2luaXRpYWxzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG5hbWUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyduYW1lJ10gPSBuYW1lO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygd2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd3aWR0aCddID0gd2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBoZWlnaHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydoZWlnaHQnXSA9IGhlaWdodDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldFFSKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHNpemU6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgbWFyZ2luOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRvd25sb2FkOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRleHQgPSBwYXJhbXMudGV4dDtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcmFtcy5zaXplO1xuICAgICAgICBjb25zdCBtYXJnaW4gPSBwYXJhbXMubWFyZ2luO1xuICAgICAgICBjb25zdCBkb3dubG9hZCA9IHBhcmFtcy5kb3dubG9hZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZXh0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZXh0XCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9hdmF0YXJzL3FyJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRleHQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0ZXh0J10gPSB0ZXh0O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NpemUnXSA9IHNpemU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBtYXJnaW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydtYXJnaW4nXSA9IG1hcmdpbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvd25sb2FkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZG93bmxvYWQnXSA9IGRvd25sb2FkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxufVxuXG5jbGFzcyBEYXRhYmFzZXMge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgbGlzdFRyYW5zYWN0aW9ucyhwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICghcGFyYW1zT3JGaXJzdCB8fCAocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgcXVlcmllczogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy90cmFuc2FjdGlvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR0bDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0dGwgPSBwYXJhbXMudHRsO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMvdHJhbnNhY3Rpb25zJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHR0bCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3R0bCddID0gdHRsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0cmFuc2FjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfScucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29tbWl0OiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvbGxiYWNrOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgY29uc3QgY29tbWl0ID0gcGFyYW1zLmNvbW1pdDtcbiAgICAgICAgY29uc3Qgcm9sbGJhY2sgPSBwYXJhbXMucm9sbGJhY2s7XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidHJhbnNhY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0nLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWl0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tbWl0J10gPSBjb21taXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb2xsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGxiYWNrJ10gPSByb2xsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy90cmFuc2FjdGlvbnMve3RyYW5zYWN0aW9uSWR9Jy5yZXBsYWNlKCd7dHJhbnNhY3Rpb25JZH0nLCB0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU9wZXJhdGlvbnMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uczogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbnMgPSBwYXJhbXMub3BlcmF0aW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0cmFuc2FjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMvdHJhbnNhY3Rpb25zL3t0cmFuc2FjdGlvbklkfS9vcGVyYXRpb25zJy5yZXBsYWNlKCd7dHJhbnNhY3Rpb25JZH0nLCB0cmFuc2FjdGlvbklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIG9wZXJhdGlvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydvcGVyYXRpb25zJ10gPSBvcGVyYXRpb25zO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGxpc3REb2N1bWVudHMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZURvY3VtZW50KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbGxlY3Rpb25JZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBkb2N1bWVudElkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb25JZCA9IHBhcmFtcy5jb2xsZWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGRvY3VtZW50SWQgPSBwYXJhbXMuZG9jdW1lbnRJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RvY3VtZW50SWQnXSA9IGRvY3VtZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0RG9jdW1lbnQocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzNdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cHNlcnREb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7Y29sbGVjdGlvbklkfScsIGNvbGxlY3Rpb25JZCkucmVwbGFjZSgne2RvY3VtZW50SWR9JywgZG9jdW1lbnRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVEb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCBjb2xsZWN0aW9uSWQgPSBwYXJhbXMuY29sbGVjdGlvbklkO1xuICAgICAgICBjb25zdCBkb2N1bWVudElkID0gcGFyYW1zLmRvY3VtZW50SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb25JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sbGVjdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRvY3VtZW50SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRvY3VtZW50SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2RhdGFiYXNlcy97ZGF0YWJhc2VJZH0vY29sbGVjdGlvbnMve2NvbGxlY3Rpb25JZH0vZG9jdW1lbnRzL3tkb2N1bWVudElkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVEb2N1bWVudChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBjb2xsZWN0aW9uSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgZG9jdW1lbnRJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBjb2xsZWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImNvbGxlY3Rpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkb2N1bWVudElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkb2N1bWVudElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9kYXRhYmFzZXMve2RhdGFiYXNlSWR9L2NvbGxlY3Rpb25zL3tjb2xsZWN0aW9uSWR9L2RvY3VtZW50cy97ZG9jdW1lbnRJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3tjb2xsZWN0aW9uSWR9JywgY29sbGVjdGlvbklkKS5yZXBsYWNlKCd7ZG9jdW1lbnRJZH0nLCBkb2N1bWVudElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVjcmVtZW50RG9jdW1lbnRBdHRyaWJ1dGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1pbjogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBwYXJhbXMuYXR0cmlidXRlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgY29uc3QgbWluID0gcGFyYW1zLm1pbjtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImF0dHJpYnV0ZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9L3thdHRyaWJ1dGV9L2RlY3JlbWVudCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpLnJlcGxhY2UoJ3thdHRyaWJ1dGV9JywgYXR0cmlidXRlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWluJ10gPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgaW5jcmVtZW50RG9jdW1lbnRBdHRyaWJ1dGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgY29sbGVjdGlvbklkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGRvY3VtZW50SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1heDogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbklkID0gcGFyYW1zLmNvbGxlY3Rpb25JZDtcbiAgICAgICAgY29uc3QgZG9jdW1lbnRJZCA9IHBhcmFtcy5kb2N1bWVudElkO1xuICAgICAgICBjb25zdCBhdHRyaWJ1dGUgPSBwYXJhbXMuYXR0cmlidXRlO1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHBhcmFtcy52YWx1ZTtcbiAgICAgICAgY29uc3QgbWF4ID0gcGFyYW1zLm1heDtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJjb2xsZWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZG9jdW1lbnRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZG9jdW1lbnRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhdHRyaWJ1dGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImF0dHJpYnV0ZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZGF0YWJhc2VzL3tkYXRhYmFzZUlkfS9jb2xsZWN0aW9ucy97Y29sbGVjdGlvbklkfS9kb2N1bWVudHMve2RvY3VtZW50SWR9L3thdHRyaWJ1dGV9L2luY3JlbWVudCcucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne2NvbGxlY3Rpb25JZH0nLCBjb2xsZWN0aW9uSWQpLnJlcGxhY2UoJ3tkb2N1bWVudElkfScsIGRvY3VtZW50SWQpLnJlcGxhY2UoJ3thdHRyaWJ1dGV9JywgYXR0cmlidXRlKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIEZ1bmN0aW9ucyB7XG4gICAgY29uc3RydWN0b3IoY2xpZW50KSB7XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICBsaXN0RXhlY3V0aW9ucyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZnVuY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uSWQgPSBwYXJhbXMuZnVuY3Rpb25JZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCB0b3RhbCA9IHBhcmFtcy50b3RhbDtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9mdW5jdGlvbnMve2Z1bmN0aW9uSWR9L2V4ZWN1dGlvbnMnLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVFeGVjdXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgYm9keTogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBhc3luYzogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB4cGF0aDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBtZXRob2Q6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgaGVhZGVyczogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICBzY2hlZHVsZWRBdDogcmVzdFs1XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbklkID0gcGFyYW1zLmZ1bmN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGJvZHkgPSBwYXJhbXMuYm9keTtcbiAgICAgICAgY29uc3QgYXN5bmMgPSBwYXJhbXMuYXN5bmM7XG4gICAgICAgIGNvbnN0IHhwYXRoID0gcGFyYW1zLnhwYXRoO1xuICAgICAgICBjb25zdCBtZXRob2QgPSBwYXJhbXMubWV0aG9kO1xuICAgICAgICBjb25zdCBoZWFkZXJzID0gcGFyYW1zLmhlYWRlcnM7XG4gICAgICAgIGNvbnN0IHNjaGVkdWxlZEF0ID0gcGFyYW1zLnNjaGVkdWxlZEF0O1xuICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZ1bmN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2Z1bmN0aW9ucy97ZnVuY3Rpb25JZH0vZXhlY3V0aW9ucycucmVwbGFjZSgne2Z1bmN0aW9uSWR9JywgZnVuY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBib2R5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYm9keSddID0gYm9keTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGFzeW5jICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnYXN5bmMnXSA9IGFzeW5jO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgeHBhdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwYXRoJ10gPSB4cGF0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG1ldGhvZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ21ldGhvZCddID0gbWV0aG9kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVhZGVycyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2hlYWRlcnMnXSA9IGhlYWRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzY2hlZHVsZWRBdCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3NjaGVkdWxlZEF0J10gPSBzY2hlZHVsZWRBdDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRFeGVjdXRpb24ocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGZ1bmN0aW9uSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZXhlY3V0aW9uSWQ6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZnVuY3Rpb25JZCA9IHBhcmFtcy5mdW5jdGlvbklkO1xuICAgICAgICBjb25zdCBleGVjdXRpb25JZCA9IHBhcmFtcy5leGVjdXRpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmdW5jdGlvbklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGV4ZWN1dGlvbklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJleGVjdXRpb25JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZnVuY3Rpb25zL3tmdW5jdGlvbklkfS9leGVjdXRpb25zL3tleGVjdXRpb25JZH0nLnJlcGxhY2UoJ3tmdW5jdGlvbklkfScsIGZ1bmN0aW9uSWQpLnJlcGxhY2UoJ3tleGVjdXRpb25JZH0nLCBleGVjdXRpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIEdyYXBocWwge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgcXVlcnkocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpICYmICdxdWVyeScgaW4gcGFyYW1zT3JGaXJzdCkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBxdWVyeTogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWVyeSA9IHBhcmFtcy5xdWVyeTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicXVlcnlcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2dyYXBocWwnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcnkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyeSddID0gcXVlcnk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICd4LXNkay1ncmFwaHFsJzogJ3RydWUnLFxuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBtdXRhdGlvbihwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkgJiYgJ3F1ZXJ5JyBpbiBwYXJhbXNPckZpcnN0KSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJ5OiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJ5ID0gcGFyYW1zLnF1ZXJ5O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJxdWVyeVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvZ3JhcGhxbC9tdXRhdGlvbic7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyeSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJ5J10gPSBxdWVyeTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ3gtc2RrLWdyYXBocWwnOiAndHJ1ZScsXG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBMb2NhbGUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHVzZXIgbG9jYXRpb24gYmFzZWQgb24gSVAuIFJldHVybnMgYW4gb2JqZWN0IHdpdGggdXNlciBjb3VudHJ5IGNvZGUsIGNvdW50cnkgbmFtZSwgY29udGluZW50IG5hbWUsIGNvbnRpbmVudCBjb2RlLCBpcCBhZGRyZXNzIGFuZCBzdWdnZXN0ZWQgY3VycmVuY3kuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIChbSVAgR2VvbG9jYXRpb24gYnkgREItSVBdKGh0dHBzOi8vZGItaXAuY29tKSlcbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Mb2NhbGU+fVxuICAgICAqL1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBsb2NhbGUgY29kZXMgaW4gW0lTTyA2MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkxvY2FsZUNvZGVMaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0Q29kZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb2Rlcyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgY29udGluZW50cy4gWW91IGNhbiB1c2UgdGhlIGxvY2FsZSBoZWFkZXIgdG8gZ2V0IHRoZSBkYXRhIGluIGEgc3VwcG9ydGVkIGxhbmd1YWdlLlxuICAgICAqXG4gICAgICogQHRocm93cyB7QXBwd3JpdGVFeGNlcHRpb259XG4gICAgICogQHJldHVybnMge1Byb21pc2U8TW9kZWxzLkNvbnRpbmVudExpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb250aW5lbnRzKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY29udGluZW50cyc7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTGlzdCBvZiBhbGwgY291bnRyaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuQ291bnRyeUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb3VudHJpZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGNvdW50cmllcyB0aGF0IGFyZSBjdXJyZW50bHkgbWVtYmVycyBvZiB0aGUgRVUuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5Db3VudHJ5TGlzdD59XG4gICAgICovXG4gICAgbGlzdENvdW50cmllc0VVKCkge1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9sb2NhbGUvY291bnRyaWVzL2V1JztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjb3VudHJpZXMgcGhvbmUgY29kZXMuIFlvdSBjYW4gdXNlIHRoZSBsb2NhbGUgaGVhZGVyIHRvIGdldCB0aGUgZGF0YSBpbiBhIHN1cHBvcnRlZCBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5QaG9uZUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RDb3VudHJpZXNQaG9uZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9jb3VudHJpZXMvcGhvbmVzJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMaXN0IG9mIGFsbCBjdXJyZW5jaWVzLCBpbmNsdWRpbmcgY3VycmVuY3kgc3ltYm9sLCBuYW1lLCBwbHVyYWwsIGFuZCBkZWNpbWFsIGRpZ2l0cyBmb3IgYWxsIG1ham9yIGFuZCBtaW5vciBjdXJyZW5jaWVzLiBZb3UgY2FuIHVzZSB0aGUgbG9jYWxlIGhlYWRlciB0byBnZXQgdGhlIGRhdGEgaW4gYSBzdXBwb3J0ZWQgbGFuZ3VhZ2UuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtBcHB3cml0ZUV4Y2VwdGlvbn1cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTxNb2RlbHMuQ3VycmVuY3lMaXN0Pn1cbiAgICAgKi9cbiAgICBsaXN0Q3VycmVuY2llcygpIHtcbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbG9jYWxlL2N1cnJlbmNpZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3Qgb2YgYWxsIGxhbmd1YWdlcyBjbGFzc2lmaWVkIGJ5IElTTyA2MzktMSBpbmNsdWRpbmcgMi1sZXR0ZXIgY29kZSwgbmFtZSBpbiBFbmdsaXNoLCBhbmQgbmFtZSBpbiB0aGUgcmVzcGVjdGl2ZSBsYW5ndWFnZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0FwcHdyaXRlRXhjZXB0aW9ufVxuICAgICAqIEByZXR1cm5zIHtQcm9taXNlPE1vZGVscy5MYW5ndWFnZUxpc3Q+fVxuICAgICAqL1xuICAgIGxpc3RMYW5ndWFnZXMoKSB7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL2xvY2FsZS9sYW5ndWFnZXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBNZXNzYWdpbmcge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICB9XG4gICAgY3JlYXRlU3Vic2NyaWJlcihwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdG9waWNJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBzdWJzY3JpYmVySWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgdGFyZ2V0SWQ6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNJZCA9IHBhcmFtcy50b3BpY0lkO1xuICAgICAgICBjb25zdCBzdWJzY3JpYmVySWQgPSBwYXJhbXMuc3Vic2NyaWJlcklkO1xuICAgICAgICBjb25zdCB0YXJnZXRJZCA9IHBhcmFtcy50YXJnZXRJZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0b3BpY0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0b3BpY0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHN1YnNjcmliZXJJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwic3Vic2NyaWJlcklkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhcmdldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YXJnZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMnLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygc3Vic2NyaWJlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc3Vic2NyaWJlcklkJ10gPSBzdWJzY3JpYmVySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXRJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RhcmdldElkJ10gPSB0YXJnZXRJZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVTdWJzY3JpYmVyKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0b3BpY0lkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHN1YnNjcmliZXJJZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b3BpY0lkID0gcGFyYW1zLnRvcGljSWQ7XG4gICAgICAgIGNvbnN0IHN1YnNjcmliZXJJZCA9IHBhcmFtcy5zdWJzY3JpYmVySWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdG9waWNJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidG9waWNJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzdWJzY3JpYmVySWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInN1YnNjcmliZXJJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvbWVzc2FnaW5nL3RvcGljcy97dG9waWNJZH0vc3Vic2NyaWJlcnMve3N1YnNjcmliZXJJZH0nLnJlcGxhY2UoJ3t0b3BpY0lkfScsIHRvcGljSWQpLnJlcGxhY2UoJ3tzdWJzY3JpYmVySWR9Jywgc3Vic2NyaWJlcklkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxufVxuXG5jbGFzcyBTdG9yYWdlIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3RGaWxlcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgcXVlcmllczogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBzZWFyY2g6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgdG90YWw6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnVja2V0SWQgPSBwYXJhbXMuYnVja2V0SWQ7XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGFyYW1zLnNlYXJjaDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwYXJhbXMudG90YWw7XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcycucmVwbGFjZSgne2J1Y2tldElkfScsIGJ1Y2tldElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGVGaWxlKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgbGV0IG9uUHJvZ3Jlc3M7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgICAgICBvblByb2dyZXNzID0gcGFyYW1zT3JGaXJzdCA9PT0gbnVsbCB8fCBwYXJhbXNPckZpcnN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbXNPckZpcnN0Lm9uUHJvZ3Jlc3M7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIGZpbGU6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbMl1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBvblByb2dyZXNzID0gcmVzdFszXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgY29uc3QgZmlsZSA9IHBhcmFtcy5maWxlO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlSWQnXSA9IGZpbGVJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGUgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydmaWxlJ10gPSBmaWxlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnbXVsdGlwYXJ0L2Zvcm0tZGF0YScsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jaHVua2VkVXBsb2FkKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkLCBvblByb2dyZXNzKTtcbiAgICB9XG4gICAgZ2V0RmlsZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZUZpbGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJ1Y2tldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBuYW1lOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCBuYW1lID0gcGFyYW1zLm5hbWU7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBpZiAodHlwZW9mIGJ1Y2tldElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJidWNrZXRJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaWxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImZpbGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvc3RvcmFnZS9idWNrZXRzL3tidWNrZXRJZH0vZmlsZXMve2ZpbGVJZH0nLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ25hbWUnXSA9IG5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZUZpbGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGJ1Y2tldElkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGZpbGVJZDogcmVzdFswXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2RlbGV0ZScsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldEZpbGVEb3dubG9hZChwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L2Rvd25sb2FkJy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRva2VuICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG9rZW4nXSA9IHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIHBheWxvYWRbJ3Byb2plY3QnXSA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhTZXJ2aWNlLmZsYXR0ZW4ocGF5bG9hZCkpKSB7XG4gICAgICAgICAgICB1cmkuc2VhcmNoUGFyYW1zLmFwcGVuZChrZXksIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdXJpLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGdldEZpbGVQcmV2aWV3KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBidWNrZXRJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBmaWxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgd2lkdGg6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIGdyYXZpdHk6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgcXVhbGl0eTogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICBib3JkZXJXaWR0aDogcmVzdFs1XSxcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogcmVzdFs2XSxcbiAgICAgICAgICAgICAgICBib3JkZXJSYWRpdXM6IHJlc3RbN10sXG4gICAgICAgICAgICAgICAgb3BhY2l0eTogcmVzdFs4XSxcbiAgICAgICAgICAgICAgICByb3RhdGlvbjogcmVzdFs5XSxcbiAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kOiByZXN0WzEwXSxcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHJlc3RbMTFdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzEyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBidWNrZXRJZCA9IHBhcmFtcy5idWNrZXRJZDtcbiAgICAgICAgY29uc3QgZmlsZUlkID0gcGFyYW1zLmZpbGVJZDtcbiAgICAgICAgY29uc3Qgd2lkdGggPSBwYXJhbXMud2lkdGg7XG4gICAgICAgIGNvbnN0IGhlaWdodCA9IHBhcmFtcy5oZWlnaHQ7XG4gICAgICAgIGNvbnN0IGdyYXZpdHkgPSBwYXJhbXMuZ3Jhdml0eTtcbiAgICAgICAgY29uc3QgcXVhbGl0eSA9IHBhcmFtcy5xdWFsaXR5O1xuICAgICAgICBjb25zdCBib3JkZXJXaWR0aCA9IHBhcmFtcy5ib3JkZXJXaWR0aDtcbiAgICAgICAgY29uc3QgYm9yZGVyQ29sb3IgPSBwYXJhbXMuYm9yZGVyQ29sb3I7XG4gICAgICAgIGNvbnN0IGJvcmRlclJhZGl1cyA9IHBhcmFtcy5ib3JkZXJSYWRpdXM7XG4gICAgICAgIGNvbnN0IG9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eTtcbiAgICAgICAgY29uc3Qgcm90YXRpb24gPSBwYXJhbXMucm90YXRpb247XG4gICAgICAgIGNvbnN0IGJhY2tncm91bmQgPSBwYXJhbXMuYmFja2dyb3VuZDtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0gcGFyYW1zLm91dHB1dDtcbiAgICAgICAgY29uc3QgdG9rZW4gPSBwYXJhbXMudG9rZW47XG4gICAgICAgIGlmICh0eXBlb2YgYnVja2V0SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImJ1Y2tldElkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGZpbGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZmlsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy9zdG9yYWdlL2J1Y2tldHMve2J1Y2tldElkfS9maWxlcy97ZmlsZUlkfS9wcmV2aWV3Jy5yZXBsYWNlKCd7YnVja2V0SWR9JywgYnVja2V0SWQpLnJlcGxhY2UoJ3tmaWxlSWR9JywgZmlsZUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHdpZHRoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnd2lkdGgnXSA9IHdpZHRoO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgaGVpZ2h0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnaGVpZ2h0J10gPSBoZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBncmF2aXR5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZ3Jhdml0eSddID0gZ3Jhdml0eTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHF1YWxpdHkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWFsaXR5J10gPSBxdWFsaXR5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYm9yZGVyV2lkdGggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydib3JkZXJXaWR0aCddID0gYm9yZGVyV2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBib3JkZXJDb2xvciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlckNvbG9yJ10gPSBib3JkZXJDb2xvcjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvcmRlclJhZGl1cyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2JvcmRlclJhZGl1cyddID0gYm9yZGVyUmFkaXVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3BhY2l0eSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ29wYWNpdHknXSA9IG9wYWNpdHk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3RhdGlvbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvdGF0aW9uJ10gPSByb3RhdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJhY2tncm91bmQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydiYWNrZ3JvdW5kJ10gPSBiYWNrZ3JvdW5kO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3V0cHV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3V0cHV0J10gPSBvdXRwdXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Rva2VuJ10gPSB0b2tlbjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBwYXlsb2FkWydwcm9qZWN0J10gPSB0aGlzLmNsaWVudC5jb25maWcucHJvamVjdDtcbiAgICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMoU2VydmljZS5mbGF0dGVuKHBheWxvYWQpKSkge1xuICAgICAgICAgICAgdXJpLnNlYXJjaFBhcmFtcy5hcHBlbmQoa2V5LCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHVyaS50b1N0cmluZygpO1xuICAgIH1cbiAgICBnZXRGaWxlVmlldyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYnVja2V0SWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgZmlsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRva2VuOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGJ1Y2tldElkID0gcGFyYW1zLmJ1Y2tldElkO1xuICAgICAgICBjb25zdCBmaWxlSWQgPSBwYXJhbXMuZmlsZUlkO1xuICAgICAgICBjb25zdCB0b2tlbiA9IHBhcmFtcy50b2tlbjtcbiAgICAgICAgaWYgKHR5cGVvZiBidWNrZXRJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiYnVja2V0SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZmlsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJmaWxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3N0b3JhZ2UvYnVja2V0cy97YnVja2V0SWR9L2ZpbGVzL3tmaWxlSWR9L3ZpZXcnLnJlcGxhY2UoJ3tidWNrZXRJZH0nLCBidWNrZXRJZCkucmVwbGFjZSgne2ZpbGVJZH0nLCBmaWxlSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b2tlbiddID0gdG9rZW47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgcGF5bG9hZFsncHJvamVjdCddID0gdGhpcy5jbGllbnQuY29uZmlnLnByb2plY3Q7XG4gICAgICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKFNlcnZpY2UuZmxhdHRlbihwYXlsb2FkKSkpIHtcbiAgICAgICAgICAgIHVyaS5zZWFyY2hQYXJhbXMuYXBwZW5kKGtleSwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB1cmkudG9TdHJpbmcoKTtcbiAgICB9XG59XG5cbmNsYXNzIFRhYmxlc0RCIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3RUcmFuc2FjdGlvbnMocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi90cmFuc2FjdGlvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHR0bDogcGFyYW1zT3JGaXJzdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0dGwgPSBwYXJhbXMudHRsO1xuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi90cmFuc2FjdGlvbnMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdHRsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHRsJ10gPSB0dGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwb3N0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0nLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZVRyYW5zYWN0aW9uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIGNvbW1pdDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb2xsYmFjazogcmVzdFsxXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IGNvbW1pdCA9IHBhcmFtcy5jb21taXQ7XG4gICAgICAgIGNvbnN0IHJvbGxiYWNrID0gcGFyYW1zLnJvbGxiYWNrO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0nLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY29tbWl0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnY29tbWl0J10gPSBjb21taXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb2xsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3JvbGxiYWNrJ10gPSByb2xsYmFjaztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVsZXRlVHJhbnNhY3Rpb24ocGFyYW1zT3JGaXJzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0nLnJlcGxhY2UoJ3t0cmFuc2FjdGlvbklkfScsIHRyYW5zYWN0aW9uSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlT3BlcmF0aW9ucyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBvcGVyYXRpb25zOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgY29uc3Qgb3BlcmF0aW9ucyA9IHBhcmFtcy5vcGVyYXRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRyYW5zYWN0aW9uSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3RyYW5zYWN0aW9ucy97dHJhbnNhY3Rpb25JZH0vb3BlcmF0aW9ucycucmVwbGFjZSgne3RyYW5zYWN0aW9uSWR9JywgdHJhbnNhY3Rpb25JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBvcGVyYXRpb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnb3BlcmF0aW9ucyddID0gb3BlcmF0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBsaXN0Um93cyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFszXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3QgcXVlcmllcyA9IHBhcmFtcy5xdWVyaWVzO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdG90YWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0b3RhbCddID0gdG90YWw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgY3JlYXRlUm93KHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm93SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgZGF0YTogcmVzdFsyXSxcbiAgICAgICAgICAgICAgICBwZXJtaXNzaW9uczogcmVzdFszXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzRdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgZGF0YSA9IHBhcmFtcy5kYXRhO1xuICAgICAgICBjb25zdCBwZXJtaXNzaW9ucyA9IHBhcmFtcy5wZXJtaXNzaW9ucztcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cycucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Jvd0lkJ10gPSByb3dJZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRhdGEgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydkYXRhJ10gPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgcGVybWlzc2lvbnMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydwZXJtaXNzaW9ucyddID0gcGVybWlzc2lvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRSb3cocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbM11cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBxdWVyaWVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncXVlcmllcyddID0gcXVlcmllcztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwc2VydFJvdyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgZGF0YWJhc2VJZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICB0YWJsZUlkOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvd0lkOiByZXN0WzFdLFxuICAgICAgICAgICAgICAgIGRhdGE6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGVybWlzc2lvbnM6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb25JZDogcmVzdFs0XVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkYXRhYmFzZUlkID0gcGFyYW1zLmRhdGFiYXNlSWQ7XG4gICAgICAgIGNvbnN0IHRhYmxlSWQgPSBwYXJhbXMudGFibGVJZDtcbiAgICAgICAgY29uc3Qgcm93SWQgPSBwYXJhbXMucm93SWQ7XG4gICAgICAgIGNvbnN0IGRhdGEgPSBwYXJhbXMuZGF0YTtcbiAgICAgICAgY29uc3QgcGVybWlzc2lvbnMgPSBwYXJhbXMucGVybWlzc2lvbnM7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0nLnJlcGxhY2UoJ3tkYXRhYmFzZUlkfScsIGRhdGFiYXNlSWQpLnJlcGxhY2UoJ3t0YWJsZUlkfScsIHRhYmxlSWQpLnJlcGxhY2UoJ3tyb3dJZH0nLCByb3dJZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZGF0YSddID0gZGF0YTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBlcm1pc3Npb25zICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncGVybWlzc2lvbnMnXSA9IHBlcm1pc3Npb25zO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdHJhbnNhY3Rpb25JZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RyYW5zYWN0aW9uSWQnXSA9IHRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwdXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVSb3cocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICBkYXRhOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHBlcm1pc3Npb25zOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uSWQ6IHJlc3RbNF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YWJhc2VJZCA9IHBhcmFtcy5kYXRhYmFzZUlkO1xuICAgICAgICBjb25zdCB0YWJsZUlkID0gcGFyYW1zLnRhYmxlSWQ7XG4gICAgICAgIGNvbnN0IHJvd0lkID0gcGFyYW1zLnJvd0lkO1xuICAgICAgICBjb25zdCBkYXRhID0gcGFyYW1zLmRhdGE7XG4gICAgICAgIGNvbnN0IHBlcm1pc3Npb25zID0gcGFyYW1zLnBlcm1pc3Npb25zO1xuICAgICAgICBjb25zdCB0cmFuc2FjdGlvbklkID0gcGFyYW1zLnRyYW5zYWN0aW9uSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YWJhc2VJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiZGF0YWJhc2VJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0YWJsZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0YWJsZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvd0lkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb3dJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGFibGVzZGIve2RhdGFiYXNlSWR9L3RhYmxlcy97dGFibGVJZH0vcm93cy97cm93SWR9Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ2RhdGEnXSA9IGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwZXJtaXNzaW9ucyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Blcm1pc3Npb25zJ10gPSBwZXJtaXNzaW9ucztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVSb3cocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGRhdGFiYXNlSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgdGFibGVJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICByb3dJZDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgdHJhbnNhY3Rpb25JZCA9IHBhcmFtcy50cmFuc2FjdGlvbklkO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGFiYXNlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcImRhdGFiYXNlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdGFibGVJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGFibGVJZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiByb3dJZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwicm93SWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RhYmxlc2RiL3tkYXRhYmFzZUlkfS90YWJsZXMve3RhYmxlSWR9L3Jvd3Mve3Jvd0lkfScucmVwbGFjZSgne2RhdGFiYXNlSWR9JywgZGF0YWJhc2VJZCkucmVwbGFjZSgne3RhYmxlSWR9JywgdGFibGVJZCkucmVwbGFjZSgne3Jvd0lkfScsIHJvd0lkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHRyYW5zYWN0aW9uSWQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWyd0cmFuc2FjdGlvbklkJ10gPSB0cmFuc2FjdGlvbklkO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgZGVjcmVtZW50Um93Q29sdW1uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm93SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgY29sdW1uOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1pbjogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgY29sdW1uID0gcGFyYW1zLmNvbHVtbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1pbiA9IHBhcmFtcy5taW47XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sdW1uXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0ve2NvbHVtbn0vZGVjcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpLnJlcGxhY2UoJ3tjb2x1bW59JywgY29sdW1uKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWluICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWluJ10gPSBtaW47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgaW5jcmVtZW50Um93Q29sdW1uKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICBkYXRhYmFzZUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHRhYmxlSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm93SWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgY29sdW1uOiByZXN0WzJdLFxuICAgICAgICAgICAgICAgIHZhbHVlOiByZXN0WzNdLFxuICAgICAgICAgICAgICAgIG1heDogcmVzdFs0XSxcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbklkOiByZXN0WzVdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGFiYXNlSWQgPSBwYXJhbXMuZGF0YWJhc2VJZDtcbiAgICAgICAgY29uc3QgdGFibGVJZCA9IHBhcmFtcy50YWJsZUlkO1xuICAgICAgICBjb25zdCByb3dJZCA9IHBhcmFtcy5yb3dJZDtcbiAgICAgICAgY29uc3QgY29sdW1uID0gcGFyYW1zLmNvbHVtbjtcbiAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXMudmFsdWU7XG4gICAgICAgIGNvbnN0IG1heCA9IHBhcmFtcy5tYXg7XG4gICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uSWQgPSBwYXJhbXMudHJhbnNhY3Rpb25JZDtcbiAgICAgICAgaWYgKHR5cGVvZiBkYXRhYmFzZUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJkYXRhYmFzZUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRhYmxlSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRhYmxlSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm93SWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvd0lkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGNvbHVtbiA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwiY29sdW1uXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90YWJsZXNkYi97ZGF0YWJhc2VJZH0vdGFibGVzL3t0YWJsZUlkfS9yb3dzL3tyb3dJZH0ve2NvbHVtbn0vaW5jcmVtZW50Jy5yZXBsYWNlKCd7ZGF0YWJhc2VJZH0nLCBkYXRhYmFzZUlkKS5yZXBsYWNlKCd7dGFibGVJZH0nLCB0YWJsZUlkKS5yZXBsYWNlKCd7cm93SWR9Jywgcm93SWQpLnJlcGxhY2UoJ3tjb2x1bW59JywgY29sdW1uKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndmFsdWUnXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWF4ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbWF4J10gPSBtYXg7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0cmFuc2FjdGlvbklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndHJhbnNhY3Rpb25JZCddID0gdHJhbnNhY3Rpb25JZDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3BhdGNoJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbmNsYXNzIFRlYW1zIHtcbiAgICBjb25zdHJ1Y3RvcihjbGllbnQpIHtcbiAgICAgICAgdGhpcy5jbGllbnQgPSBjbGllbnQ7XG4gICAgfVxuICAgIGxpc3QocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoIXBhcmFtc09yRmlyc3QgfHwgKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHF1ZXJpZXM6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgc2VhcmNoOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHRvdGFsOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHF1ZXJpZXMgPSBwYXJhbXMucXVlcmllcztcbiAgICAgICAgY29uc3Qgc2VhcmNoID0gcGFyYW1zLnNlYXJjaDtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwYXJhbXMudG90YWw7XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zJztcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHF1ZXJpZXMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydxdWVyaWVzJ10gPSBxdWVyaWVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VhcmNoICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VhcmNoJ10gPSBzZWFyY2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0b3RhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3RvdGFsJ10gPSB0b3RhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBjcmVhdGUocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBuYW1lOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHJvbGVzOiByZXN0WzFdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBwYXJhbXMubmFtZTtcbiAgICAgICAgY29uc3Qgcm9sZXMgPSBwYXJhbXMucm9sZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbmFtZSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwibmFtZVwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMnO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndGVhbUlkJ10gPSB0ZWFtSWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sZXMnXSA9IHJvbGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncG9zdCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldChwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHt9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZ2V0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTmFtZShwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbMF1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcIm5hbWVcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3B1dCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGRlbGV0ZShwYXJhbXNPckZpcnN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCk7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSB7fTtcbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdkZWxldGUnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBsaXN0TWVtYmVyc2hpcHMocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBxdWVyaWVzOiByZXN0WzBdLFxuICAgICAgICAgICAgICAgIHNlYXJjaDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB0b3RhbDogcmVzdFsyXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0ZWFtSWQgPSBwYXJhbXMudGVhbUlkO1xuICAgICAgICBjb25zdCBxdWVyaWVzID0gcGFyYW1zLnF1ZXJpZXM7XG4gICAgICAgIGNvbnN0IHNlYXJjaCA9IHBhcmFtcy5zZWFyY2g7XG4gICAgICAgIGNvbnN0IHRvdGFsID0gcGFyYW1zLnRvdGFsO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgcXVlcmllcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3F1ZXJpZXMnXSA9IHF1ZXJpZXM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBzZWFyY2ggIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICBwYXlsb2FkWydzZWFyY2gnXSA9IHNlYXJjaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHRvdGFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndG90YWwnXSA9IHRvdGFsO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGNyZWF0ZU1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICByb2xlczogcmVzdFswXSxcbiAgICAgICAgICAgICAgICBlbWFpbDogcmVzdFsxXSxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHJlc3RbMl0sXG4gICAgICAgICAgICAgICAgcGhvbmU6IHJlc3RbM10sXG4gICAgICAgICAgICAgICAgdXJsOiByZXN0WzRdLFxuICAgICAgICAgICAgICAgIG5hbWU6IHJlc3RbNV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3Qgcm9sZXMgPSBwYXJhbXMucm9sZXM7XG4gICAgICAgIGNvbnN0IGVtYWlsID0gcGFyYW1zLmVtYWlsO1xuICAgICAgICBjb25zdCB1c2VySWQgPSBwYXJhbXMudXNlcklkO1xuICAgICAgICBjb25zdCBwaG9uZSA9IHBhcmFtcy5waG9uZTtcbiAgICAgICAgY29uc3QgdXJsID0gcGFyYW1zLnVybDtcbiAgICAgICAgY29uc3QgbmFtZSA9IHBhcmFtcy5uYW1lO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJyb2xlc1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vbWVtYmVyc2hpcHMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGVtYWlsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnZW1haWwnXSA9IGVtYWlsO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXNlcklkJ10gPSB1c2VySWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBwaG9uZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3Bob25lJ10gPSBwaG9uZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sZXMnXSA9IHJvbGVzO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXJsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsndXJsJ10gPSB1cmw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBuYW1lICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnbmFtZSddID0gbmFtZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge1xuICAgICAgICAgICAgJ2NvbnRlbnQtdHlwZSc6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ3Bvc3QnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBnZXRNZW1iZXJzaGlwKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbWVtYmVyc2hpcElkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IG1lbWJlcnNoaXBJZCA9IHBhcmFtcy5tZW1iZXJzaGlwSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7fTtcbiAgICAgICAgcmV0dXJuIHRoaXMuY2xpZW50LmNhbGwoJ2dldCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIHVwZGF0ZU1lbWJlcnNoaXAocGFyYW1zT3JGaXJzdCwgLi4ucmVzdCkge1xuICAgICAgICBsZXQgcGFyYW1zO1xuICAgICAgICBpZiAoKHBhcmFtc09yRmlyc3QgJiYgdHlwZW9mIHBhcmFtc09yRmlyc3QgPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KHBhcmFtc09yRmlyc3QpKSkge1xuICAgICAgICAgICAgcGFyYW1zID0gKHBhcmFtc09yRmlyc3QgfHwge30pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIHRlYW1JZDogcGFyYW1zT3JGaXJzdCxcbiAgICAgICAgICAgICAgICBtZW1iZXJzaGlwSWQ6IHJlc3RbMF0sXG4gICAgICAgICAgICAgICAgcm9sZXM6IHJlc3RbMV1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgY29uc3QgbWVtYmVyc2hpcElkID0gcGFyYW1zLm1lbWJlcnNoaXBJZDtcbiAgICAgICAgY29uc3Qgcm9sZXMgPSBwYXJhbXMucm9sZXM7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygcm9sZXMgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInJvbGVzXCInKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcGlQYXRoID0gJy90ZWFtcy97dGVhbUlkfS9tZW1iZXJzaGlwcy97bWVtYmVyc2hpcElkfScucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHJvbGVzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncm9sZXMnXSA9IHJvbGVzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncGF0Y2gnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICBkZWxldGVNZW1iZXJzaGlwKHBhcmFtc09yRmlyc3QsIC4uLnJlc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3QsXG4gICAgICAgICAgICAgICAgbWVtYmVyc2hpcElkOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IG1lbWJlcnNoaXBJZCA9IHBhcmFtcy5tZW1iZXJzaGlwSWQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9Jy5yZXBsYWNlKCd7dGVhbUlkfScsIHRlYW1JZCkucmVwbGFjZSgne21lbWJlcnNoaXBJZH0nLCBtZW1iZXJzaGlwSWQpO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0ge307XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgnZGVsZXRlJywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG4gICAgdXBkYXRlTWVtYmVyc2hpcFN0YXR1cyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIG1lbWJlcnNoaXBJZDogcmVzdFswXSxcbiAgICAgICAgICAgICAgICB1c2VySWQ6IHJlc3RbMV0sXG4gICAgICAgICAgICAgICAgc2VjcmV0OiByZXN0WzJdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IG1lbWJlcnNoaXBJZCA9IHBhcmFtcy5tZW1iZXJzaGlwSWQ7XG4gICAgICAgIGNvbnN0IHVzZXJJZCA9IHBhcmFtcy51c2VySWQ7XG4gICAgICAgIGNvbnN0IHNlY3JldCA9IHBhcmFtcy5zZWNyZXQ7XG4gICAgICAgIGlmICh0eXBlb2YgdGVhbUlkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ0ZWFtSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgbWVtYmVyc2hpcElkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJtZW1iZXJzaGlwSWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdXNlcklkID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJ1c2VySWRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJzZWNyZXRcIicpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFwaVBhdGggPSAnL3RlYW1zL3t0ZWFtSWR9L21lbWJlcnNoaXBzL3ttZW1iZXJzaGlwSWR9L3N0YXR1cycucmVwbGFjZSgne3RlYW1JZH0nLCB0ZWFtSWQpLnJlcGxhY2UoJ3ttZW1iZXJzaGlwSWR9JywgbWVtYmVyc2hpcElkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHVzZXJJZCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHBheWxvYWRbJ3VzZXJJZCddID0gdXNlcklkO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VjcmV0ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsnc2VjcmV0J10gPSBzZWNyZXQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJpID0gbmV3IFVSTCh0aGlzLmNsaWVudC5jb25maWcuZW5kcG9pbnQgKyBhcGlQYXRoKTtcbiAgICAgICAgY29uc3QgYXBpSGVhZGVycyA9IHtcbiAgICAgICAgICAgICdjb250ZW50LXR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdwYXRjaCcsIHVyaSwgYXBpSGVhZGVycywgcGF5bG9hZCk7XG4gICAgfVxuICAgIGdldFByZWZzKHBhcmFtc09yRmlyc3QpIHtcbiAgICAgICAgbGV0IHBhcmFtcztcbiAgICAgICAgaWYgKChwYXJhbXNPckZpcnN0ICYmIHR5cGVvZiBwYXJhbXNPckZpcnN0ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXNPckZpcnN0KSkpIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IChwYXJhbXNPckZpcnN0IHx8IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICB0ZWFtSWQ6IHBhcmFtc09yRmlyc3RcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGVhbUlkID0gcGFyYW1zLnRlYW1JZDtcbiAgICAgICAgaWYgKHR5cGVvZiB0ZWFtSWQgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcmVxdWlyZWQgcGFyYW1ldGVyOiBcInRlYW1JZFwiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vcHJlZnMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBjb25zdCB1cmkgPSBuZXcgVVJMKHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCArIGFwaVBhdGgpO1xuICAgICAgICBjb25zdCBhcGlIZWFkZXJzID0ge307XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5jYWxsKCdnZXQnLCB1cmksIGFwaUhlYWRlcnMsIHBheWxvYWQpO1xuICAgIH1cbiAgICB1cGRhdGVQcmVmcyhwYXJhbXNPckZpcnN0LCAuLi5yZXN0KSB7XG4gICAgICAgIGxldCBwYXJhbXM7XG4gICAgICAgIGlmICgocGFyYW1zT3JGaXJzdCAmJiB0eXBlb2YgcGFyYW1zT3JGaXJzdCA9PT0gJ29iamVjdCcgJiYgIUFycmF5LmlzQXJyYXkocGFyYW1zT3JGaXJzdCkpKSB7XG4gICAgICAgICAgICBwYXJhbXMgPSAocGFyYW1zT3JGaXJzdCB8fCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgdGVhbUlkOiBwYXJhbXNPckZpcnN0LFxuICAgICAgICAgICAgICAgIHByZWZzOiByZXN0WzBdXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRlYW1JZCA9IHBhcmFtcy50ZWFtSWQ7XG4gICAgICAgIGNvbnN0IHByZWZzID0gcGFyYW1zLnByZWZzO1xuICAgICAgICBpZiAodHlwZW9mIHRlYW1JZCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbignTWlzc2luZyByZXF1aXJlZCBwYXJhbWV0ZXI6IFwidGVhbUlkXCInKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHByZWZzID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEFwcHdyaXRlRXhjZXB0aW9uKCdNaXNzaW5nIHJlcXVpcmVkIHBhcmFtZXRlcjogXCJwcmVmc1wiJyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpUGF0aCA9ICcvdGVhbXMve3RlYW1JZH0vcHJlZnMnLnJlcGxhY2UoJ3t0ZWFtSWR9JywgdGVhbUlkKTtcbiAgICAgICAgY29uc3QgcGF5bG9hZCA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIHByZWZzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgcGF5bG9hZFsncHJlZnMnXSA9IHByZWZzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVyaSA9IG5ldyBVUkwodGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50ICsgYXBpUGF0aCk7XG4gICAgICAgIGNvbnN0IGFwaUhlYWRlcnMgPSB7XG4gICAgICAgICAgICAnY29udGVudC10eXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdGhpcy5jbGllbnQuY2FsbCgncHV0JywgdXJpLCBhcGlIZWFkZXJzLCBwYXlsb2FkKTtcbiAgICB9XG59XG5cbnZhciBSZWFsdGltZUNvZGU7XG4oZnVuY3Rpb24gKFJlYWx0aW1lQ29kZSkge1xuICAgIFJlYWx0aW1lQ29kZVtSZWFsdGltZUNvZGVbXCJOT1JNQUxfQ0xPU1VSRVwiXSA9IDEwMDBdID0gXCJOT1JNQUxfQ0xPU1VSRVwiO1xuICAgIFJlYWx0aW1lQ29kZVtSZWFsdGltZUNvZGVbXCJQT0xJQ1lfVklPTEFUSU9OXCJdID0gMTAwOF0gPSBcIlBPTElDWV9WSU9MQVRJT05cIjtcbiAgICBSZWFsdGltZUNvZGVbUmVhbHRpbWVDb2RlW1wiVU5LTk9XTl9FUlJPUlwiXSA9IC0xXSA9IFwiVU5LTk9XTl9FUlJPUlwiO1xufSkoUmVhbHRpbWVDb2RlIHx8IChSZWFsdGltZUNvZGUgPSB7fSkpO1xuY2xhc3MgUmVhbHRpbWUge1xuICAgIGNvbnN0cnVjdG9yKGNsaWVudCkge1xuICAgICAgICB0aGlzLlRZUEVfRVJST1IgPSAnZXJyb3InO1xuICAgICAgICB0aGlzLlRZUEVfRVZFTlQgPSAnZXZlbnQnO1xuICAgICAgICB0aGlzLlRZUEVfUE9ORyA9ICdwb25nJztcbiAgICAgICAgdGhpcy5UWVBFX0NPTk5FQ1RFRCA9ICdjb25uZWN0ZWQnO1xuICAgICAgICB0aGlzLkRFQk9VTkNFX01TID0gMTtcbiAgICAgICAgdGhpcy5IRUFSVEJFQVRfSU5URVJWQUwgPSAyMDAwMDsgLy8gMjAgc2Vjb25kcyBpbiBtaWxsaXNlY29uZHNcbiAgICAgICAgdGhpcy5hY3RpdmVDaGFubmVscyA9IG5ldyBTZXQoKTtcbiAgICAgICAgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLnN1YkNhbGxEZXB0aCA9IDA7XG4gICAgICAgIHRoaXMucmVjb25uZWN0QXR0ZW1wdHMgPSAwO1xuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnNDb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5yZWNvbm5lY3QgPSB0cnVlO1xuICAgICAgICB0aGlzLm9uRXJyb3JDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgdGhpcy5vbkNsb3NlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMub25PcGVuQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuY2xpZW50ID0gY2xpZW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWdpc3RlciBhIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGJlIGNhbGxlZCB3aGVuIGFuIGVycm9yIG9jY3Vyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBDYWxsYmFjayBmdW5jdGlvbiB0byBoYW5kbGUgZXJyb3JzXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgb25FcnJvcihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uRXJyb3JDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gY2xvc2VzXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIENhbGxiYWNrIGZ1bmN0aW9uIHRvIGhhbmRsZSBjb25uZWN0aW9uIGNsb3NlXG4gICAgICogQHJldHVybnMge3ZvaWR9XG4gICAgICovXG4gICAgb25DbG9zZShjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uQ2xvc2VDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlZ2lzdGVyIGEgY2FsbGJhY2sgZnVuY3Rpb24gdG8gYmUgY2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gb3BlbnNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gQ2FsbGJhY2sgZnVuY3Rpb24gdG8gaGFuZGxlIGNvbm5lY3Rpb24gb3BlblxuICAgICAqIEByZXR1cm5zIHt2b2lkfVxuICAgICAqL1xuICAgIG9uT3BlbihjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm9uT3BlbkNhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgc3RhcnRIZWFydGJlYXQoKSB7XG4gICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xuICAgICAgICB0aGlzLmhlYXJ0YmVhdFRpbWVyID0gd2luZG93LnNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldCAmJiB0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkoeyB0eXBlOiAncGluZycgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLkhFQVJUQkVBVF9JTlRFUlZBTCk7XG4gICAgfVxuICAgIHN0b3BIZWFydGJlYXQoKSB7XG4gICAgICAgIGlmICh0aGlzLmhlYXJ0YmVhdFRpbWVyKSB7XG4gICAgICAgICAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbCh0aGlzLmhlYXJ0YmVhdFRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuaGVhcnRiZWF0VGltZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY3JlYXRlU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWN0aXZlQ2hhbm5lbHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jbG9zZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2plY3RJZCA9IHRoaXMuY2xpZW50LmNvbmZpZy5wcm9qZWN0O1xuICAgICAgICAgICAgaWYgKCFwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgQXBwd3JpdGVFeGNlcHRpb24oJ01pc3NpbmcgcHJvamVjdCBJRCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHF1ZXJ5UGFyYW1zID0gYHByb2plY3Q9JHtwcm9qZWN0SWR9YDtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiB0aGlzLmFjdGl2ZUNoYW5uZWxzKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXMgKz0gYCZjaGFubmVsc1tdPSR7ZW5jb2RlVVJJQ29tcG9uZW50KGNoYW5uZWwpfWA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludFJlYWx0aW1lICE9PSAnJ1xuICAgICAgICAgICAgICAgID8gdGhpcy5jbGllbnQuY29uZmlnLmVuZHBvaW50UmVhbHRpbWVcbiAgICAgICAgICAgICAgICA6IHRoaXMuY2xpZW50LmNvbmZpZy5lbmRwb2ludCB8fCAnJztcbiAgICAgICAgICAgIGNvbnN0IHJlYWx0aW1lRW5kcG9pbnQgPSBlbmRwb2ludFxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdodHRwczovLycsICd3c3M6Ly8nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKCdodHRwOi8vJywgJ3dzOi8vJyk7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHtyZWFsdGltZUVuZHBvaW50fS9yZWFsdGltZT8ke3F1ZXJ5UGFyYW1zfWA7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuY2xvc2VTb2NrZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQgPSBuZXcgV2ViU29ja2V0KHVybCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ29wZW4nLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlY29ubmVjdEF0dGVtcHRzID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25PcGVuQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0YXJ0SGVhcnRiZWF0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNvY2tldC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBtZXNzYWdlOicsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKGV2ZW50KSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0b3BIZWFydGJlYXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMub25DbG9zZUNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnJlY29ubmVjdCB8fCBldmVudC5jb2RlID09PSBSZWFsdGltZUNvZGUuUE9MSUNZX1ZJT0xBVElPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVjb25uZWN0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5nZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUmVhbHRpbWUgZGlzY29ubmVjdGVkLiBSZS1jb25uZWN0aW5nIGluICR7dGltZW91dCAvIDEwMDB9IHNlY29uZHMuYCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLnNsZWVwKHRpbWVvdXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RBdHRlbXB0cysrO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignRmFpbGVkIHRvIHJlY29ubmVjdDonLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RvcEhlYXJ0YmVhdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IoJ1dlYlNvY2tldCBlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignV2ViU29ja2V0IGVycm9yOicsIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5vbkVycm9yQ2FsbGJhY2tzLmZvckVhY2goY2FsbGJhY2sgPT4gY2FsbGJhY2soZXJyb3IpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNsb3NlU29ja2V0KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5zdG9wSGVhcnRiZWF0KCk7XG4gICAgICAgICAgICBpZiAodGhpcy5zb2NrZXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLnNvY2tldCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTiB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIHsgb25jZTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc29ja2V0LmNsb3NlKFJlYWx0aW1lQ29kZS5OT1JNQUxfQ0xPU1VSRSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRpbWVvdXQoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgNSkge1xuICAgICAgICAgICAgcmV0dXJuIDEwMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5yZWNvbm5lY3RBdHRlbXB0cyA8IDE1KSB7XG4gICAgICAgICAgICByZXR1cm4gNTAwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnJlY29ubmVjdEF0dGVtcHRzIDwgMTAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMTAwMDA7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gNjAwMDA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2xlZXAobXMpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCBtcykpO1xuICAgIH1cbiAgICBzdWJzY3JpYmUoY2hhbm5lbHNPckNoYW5uZWwsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IEFycmF5LmlzQXJyYXkoY2hhbm5lbHNPckNoYW5uZWwpXG4gICAgICAgICAgICAgICAgPyBuZXcgU2V0KGNoYW5uZWxzT3JDaGFubmVsKVxuICAgICAgICAgICAgICAgIDogbmV3IFNldChbY2hhbm5lbHNPckNoYW5uZWxdKTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9uc0NvdW50ZXIrKztcbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gdGhpcy5zdWJzY3JpcHRpb25zQ291bnRlcjtcbiAgICAgICAgICAgIGZvciAoY29uc3QgY2hhbm5lbCBvZiBjaGFubmVscykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlQ2hhbm5lbHMuYWRkKGNoYW5uZWwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zLnNldChjb3VudCwge1xuICAgICAgICAgICAgICAgIGNoYW5uZWxzLFxuICAgICAgICAgICAgICAgIGNhbGxiYWNrXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuc3ViQ2FsbERlcHRoKys7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLnNsZWVwKHRoaXMuREVCT1VOQ0VfTVMpO1xuICAgICAgICAgICAgaWYgKHRoaXMuc3ViQ2FsbERlcHRoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgeWllbGQgdGhpcy5jcmVhdGVTb2NrZXQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuc3ViQ2FsbERlcHRoLS07XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGNsb3NlOiAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlU3Vic2NyaXB0aW9ucy5kZWxldGUoY291bnQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFuVXAoY2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCB0aGlzLmNyZWF0ZVNvY2tldCgpO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY2xlYW5VcChjaGFubmVscykge1xuICAgICAgICB0aGlzLmFjdGl2ZUNoYW5uZWxzID0gbmV3IFNldChBcnJheS5mcm9tKHRoaXMuYWN0aXZlQ2hhbm5lbHMpLmZpbHRlcihjaGFubmVsID0+IHtcbiAgICAgICAgICAgIGlmICghY2hhbm5lbHMuaGFzKGNoYW5uZWwpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJzV2l0aENoYW5uZWwgPSBBcnJheS5mcm9tKHRoaXMuYWN0aXZlU3Vic2NyaXB0aW9ucy52YWx1ZXMoKSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKHN1YiA9PiBzdWIuY2hhbm5lbHMuaGFzKGNoYW5uZWwpKTtcbiAgICAgICAgICAgIHJldHVybiBzdWJzV2l0aENoYW5uZWwubGVuZ3RoID4gMDtcbiAgICAgICAgfSkpO1xuICAgIH1cbiAgICBoYW5kbGVNZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKCFtZXNzYWdlLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSB0aGlzLlRZUEVfQ09OTkVDVEVEOlxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzcG9uc2VDb25uZWN0ZWQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVFlQRV9FUlJPUjpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlRXJyb3IobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVFlQRV9FVkVOVDpcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZVJlc3BvbnNlRXZlbnQobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIHRoaXMuVFlQRV9QT05HOlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBwb25nIHJlc3BvbnNlIGlmIG5lZWRlZFxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJlc3BvbnNlQ29ubmVjdGVkKG1lc3NhZ2UpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZXNzYWdlRGF0YSA9IG1lc3NhZ2UuZGF0YTtcbiAgICAgICAgbGV0IHNlc3Npb24gPSB0aGlzLmNsaWVudC5jb25maWcuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCFzZXNzaW9uKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvb2tpZSA9IEpTT04ucGFyc2UoKF9hID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKCdjb29raWVGYWxsYmFjaycpKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiAne30nKTtcbiAgICAgICAgICAgICAgICBzZXNzaW9uID0gY29va2llID09PSBudWxsIHx8IGNvb2tpZSA9PT0gdm9pZCAwID8gdm9pZCAwIDogY29va2llW2BhX3Nlc3Npb25fJHt0aGlzLmNsaWVudC5jb25maWcucHJvamVjdH1gXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBjb29raWUgZmFsbGJhY2s6JywgZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZXNzaW9uICYmICFtZXNzYWdlRGF0YS51c2VyKSB7XG4gICAgICAgICAgICAoX2IgPSB0aGlzLnNvY2tldCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNlbmQoSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6ICdhdXRoZW50aWNhdGlvbicsXG4gICAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVJlc3BvbnNlRXJyb3IobWVzc2FnZSkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBBcHB3cml0ZUV4Y2VwdGlvbigoKF9hID0gbWVzc2FnZS5kYXRhKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubWVzc2FnZSkgfHwgJ1Vua25vd24gZXJyb3InKTtcbiAgICAgICAgY29uc3Qgc3RhdHVzQ29kZSA9IChfYiA9IG1lc3NhZ2UuZGF0YSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNvZGU7XG4gICAgICAgIHRoaXMub25FcnJvckNhbGxiYWNrcy5mb3JFYWNoKGNhbGxiYWNrID0+IGNhbGxiYWNrKGVycm9yLCBzdGF0dXNDb2RlKSk7XG4gICAgfVxuICAgIGhhbmRsZVJlc3BvbnNlRXZlbnQobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBkYXRhID0gbWVzc2FnZS5kYXRhO1xuICAgICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjaGFubmVscyA9IGRhdGEuY2hhbm5lbHM7XG4gICAgICAgIGNvbnN0IGV2ZW50cyA9IGRhdGEuZXZlbnRzO1xuICAgICAgICBjb25zdCBwYXlsb2FkID0gZGF0YS5wYXlsb2FkO1xuICAgICAgICBjb25zdCB0aW1lc3RhbXAgPSBkYXRhLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKCFjaGFubmVscyB8fCAhZXZlbnRzIHx8ICFwYXlsb2FkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGFzQWN0aXZlQ2hhbm5lbCA9IGNoYW5uZWxzLnNvbWUoY2hhbm5lbCA9PiB0aGlzLmFjdGl2ZUNoYW5uZWxzLmhhcyhjaGFubmVsKSk7XG4gICAgICAgIGlmICghaGFzQWN0aXZlQ2hhbm5lbCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgW18sIHN1YnNjcmlwdGlvbl0gb2YgdGhpcy5hY3RpdmVTdWJzY3JpcHRpb25zKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNTdWJzY3JpYmVkQ2hhbm5lbCA9IGNoYW5uZWxzLnNvbWUoY2hhbm5lbCA9PiBzdWJzY3JpcHRpb24uY2hhbm5lbHMuaGFzKGNoYW5uZWwpKTtcbiAgICAgICAgICAgIGlmIChoYXNTdWJzY3JpYmVkQ2hhbm5lbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlID0ge1xuICAgICAgICAgICAgICAgICAgICBldmVudHMsXG4gICAgICAgICAgICAgICAgICAgIGNoYW5uZWxzLFxuICAgICAgICAgICAgICAgICAgICB0aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIHBheWxvYWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHN1YnNjcmlwdGlvbi5jYWxsYmFjayhyZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIHBlcm1pc3Npb24gc3RyaW5ncyBmb3IgcmVzb3VyY2VzLlxuICovXG5jbGFzcyBQZXJtaXNzaW9uIHtcbn1cbi8qKlxuICogR2VuZXJhdGUgcmVhZCBwZXJtaXNzaW9uIHN0cmluZyBmb3IgdGhlIHByb3ZpZGVkIHJvbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBlcm1pc3Npb24ucmVhZCA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGByZWFkKFwiJHtyb2xlfVwiKWA7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSB3cml0ZSBwZXJtaXNzaW9uIHN0cmluZyBmb3IgdGhlIHByb3ZpZGVkIHJvbGUuXG4gKlxuICogVGhpcyBpcyBhbiBhbGlhcyBvZiB1cGRhdGUsIGRlbGV0ZSwgYW5kIHBvc3NpYmx5IGNyZWF0ZS5cbiAqIERvbid0IHVzZSB3cml0ZSBpbiBjb21iaW5hdGlvbiB3aXRoIHVwZGF0ZSwgZGVsZXRlLCBvciBjcmVhdGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBlcm1pc3Npb24ud3JpdGUgPSAocm9sZSkgPT4ge1xuICAgIHJldHVybiBgd3JpdGUoXCIke3JvbGV9XCIpYDtcbn07XG4vKipcbiAqIEdlbmVyYXRlIGNyZWF0ZSBwZXJtaXNzaW9uIHN0cmluZyBmb3IgdGhlIHByb3ZpZGVkIHJvbGUuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cblBlcm1pc3Npb24uY3JlYXRlID0gKHJvbGUpID0+IHtcbiAgICByZXR1cm4gYGNyZWF0ZShcIiR7cm9sZX1cIilgO1xufTtcbi8qKlxuICogR2VuZXJhdGUgdXBkYXRlIHBlcm1pc3Npb24gc3RyaW5nIGZvciB0aGUgcHJvdmlkZWQgcm9sZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gcm9sZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuUGVybWlzc2lvbi51cGRhdGUgPSAocm9sZSkgPT4ge1xuICAgIHJldHVybiBgdXBkYXRlKFwiJHtyb2xlfVwiKWA7XG59O1xuLyoqXG4gKiBHZW5lcmF0ZSBkZWxldGUgcGVybWlzc2lvbiBzdHJpbmcgZm9yIHRoZSBwcm92aWRlZCByb2xlLlxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSByb2xlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5QZXJtaXNzaW9uLmRlbGV0ZSA9IChyb2xlKSA9PiB7XG4gICAgcmV0dXJuIGBkZWxldGUoXCIke3JvbGV9XCIpYDtcbn07XG5cbi8qKlxuICogSGVscGVyIGNsYXNzIHRvIGdlbmVyYXRlIHJvbGUgc3RyaW5ncyBmb3IgYFBlcm1pc3Npb25gLlxuICovXG5jbGFzcyBSb2xlIHtcbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGFueW9uZS5cbiAgICAgKlxuICAgICAqIFRoaXMgaW5jbHVkZXMgYXV0aGVudGljYXRlZCBhbmQgdW5hdXRoZW50aWNhdGVkIHVzZXJzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgYW55KCkge1xuICAgICAgICByZXR1cm4gJ2FueSc7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYSBzcGVjaWZpYyB1c2VyIGJ5IHVzZXIgSUQuXG4gICAgICpcbiAgICAgKiBZb3UgY2FuIG9wdGlvbmFsbHkgcGFzcyB2ZXJpZmllZCBvciB1bnZlcmlmaWVkIGZvclxuICAgICAqIGBzdGF0dXNgIHRvIHRhcmdldCBzcGVjaWZpYyB0eXBlcyBvZiB1c2Vycy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdGF0dXNcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB1c2VyKGlkLCBzdGF0dXMgPSAnJykge1xuICAgICAgICBpZiAoc3RhdHVzID09PSAnJykge1xuICAgICAgICAgICAgcmV0dXJuIGB1c2VyOiR7aWR9YDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHVzZXI6JHtpZH0vJHtzdGF0dXN9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhbnkgYXV0aGVudGljYXRlZCBvciBhbm9ueW1vdXMgdXNlci5cbiAgICAgKlxuICAgICAqIFlvdSBjYW4gb3B0aW9uYWxseSBwYXNzIHZlcmlmaWVkIG9yIHVudmVyaWZpZWQgZm9yXG4gICAgICogYHN0YXR1c2AgdG8gdGFyZ2V0IHNwZWNpZmljIHR5cGVzIG9mIHVzZXJzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0YXR1c1xuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIHVzZXJzKHN0YXR1cyA9ICcnKSB7XG4gICAgICAgIGlmIChzdGF0dXMgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gJ3VzZXJzJztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYHVzZXJzLyR7c3RhdHVzfWA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdyYW50cyBhY2Nlc3MgdG8gYW55IGd1ZXN0IHVzZXIgd2l0aG91dCBhIHNlc3Npb24uXG4gICAgICpcbiAgICAgKiBBdXRoZW50aWNhdGVkIHVzZXJzIGRvbid0IGhhdmUgYWNjZXNzIHRvIHRoaXMgcm9sZS5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGd1ZXN0cygpIHtcbiAgICAgICAgcmV0dXJuICdndWVzdHMnO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgdGVhbSBieSB0ZWFtIElELlxuICAgICAqXG4gICAgICogWW91IGNhbiBvcHRpb25hbGx5IHBhc3MgYSByb2xlIGZvciBgcm9sZWAgdG8gdGFyZ2V0XG4gICAgICogdGVhbSBtZW1iZXJzIHdpdGggdGhlIHNwZWNpZmllZCByb2xlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGlkXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHJvbGVcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyB0ZWFtKGlkLCByb2xlID0gJycpIHtcbiAgICAgICAgaWYgKHJvbGUgPT09ICcnKSB7XG4gICAgICAgICAgICByZXR1cm4gYHRlYW06JHtpZH1gO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBgdGVhbToke2lkfS8ke3JvbGV9YDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR3JhbnRzIGFjY2VzcyB0byBhIHNwZWNpZmljIG1lbWJlciBvZiBhIHRlYW0uXG4gICAgICpcbiAgICAgKiBXaGVuIHRoZSBtZW1iZXIgaXMgcmVtb3ZlZCBmcm9tIHRoZSB0ZWFtLCB0aGV5IHdpbGxcbiAgICAgKiBubyBsb25nZXIgaGF2ZSBhY2Nlc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBtZW1iZXIoaWQpIHtcbiAgICAgICAgcmV0dXJuIGBtZW1iZXI6JHtpZH1gO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHcmFudHMgYWNjZXNzIHRvIGEgdXNlciB3aXRoIHRoZSBzcGVjaWZpZWQgbGFiZWwuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEByZXR1cm5zICB7c3RyaW5nfVxuICAgICAqL1xuICAgIHN0YXRpYyBsYWJlbChuYW1lKSB7XG4gICAgICAgIHJldHVybiBgbGFiZWw6JHtuYW1lfWA7XG4gICAgfVxufVxuXG52YXIgX2EsIF9JRF9oZXhUaW1lc3RhbXA7XG4vKipcbiAqIEhlbHBlciBjbGFzcyB0byBnZW5lcmF0ZSBJRCBzdHJpbmdzIGZvciByZXNvdXJjZXMuXG4gKi9cbmNsYXNzIElEIHtcbiAgICAvKipcbiAgICAgKiBVc2VzIHRoZSBwcm92aWRlZCBJRCBhcyB0aGUgSUQgZm9yIHRoZSByZXNvdXJjZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBpZFxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgc3RhdGljIGN1c3RvbShpZCkge1xuICAgICAgICByZXR1cm4gaWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEhhdmUgQXBwd3JpdGUgZ2VuZXJhdGUgYSB1bmlxdWUgSUQgZm9yIHlvdS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nLiBEZWZhdWx0IGlzIDcuXG4gICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgKi9cbiAgICBzdGF0aWMgdW5pcXVlKHBhZGRpbmcgPSA3KSB7XG4gICAgICAgIC8vIEdlbmVyYXRlIGEgdW5pcXVlIElEIHdpdGggcGFkZGluZyB0byBoYXZlIGEgbG9uZ2VyIElEXG4gICAgICAgIGNvbnN0IGJhc2VJZCA9IF9fY2xhc3NQcml2YXRlRmllbGRHZXQoSUQsIF9hLCBcIm1cIiwgX0lEX2hleFRpbWVzdGFtcCkuY2FsbChJRCk7XG4gICAgICAgIGxldCByYW5kb21QYWRkaW5nID0gJyc7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFkZGluZzsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCByYW5kb21IZXhEaWdpdCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDE2KS50b1N0cmluZygxNik7XG4gICAgICAgICAgICByYW5kb21QYWRkaW5nICs9IHJhbmRvbUhleERpZ2l0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlSWQgKyByYW5kb21QYWRkaW5nO1xuICAgIH1cbn1cbl9hID0gSUQsIF9JRF9oZXhUaW1lc3RhbXAgPSBmdW5jdGlvbiBfSURfaGV4VGltZXN0YW1wKCkge1xuICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3Qgc2VjID0gTWF0aC5mbG9vcihub3cuZ2V0VGltZSgpIC8gMTAwMCk7XG4gICAgY29uc3QgbXNlYyA9IG5vdy5nZXRNaWxsaXNlY29uZHMoKTtcbiAgICAvLyBDb252ZXJ0IHRvIGhleGFkZWNpbWFsXG4gICAgY29uc3QgaGV4VGltZXN0YW1wID0gc2VjLnRvU3RyaW5nKDE2KSArIG1zZWMudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDUsICcwJyk7XG4gICAgcmV0dXJuIGhleFRpbWVzdGFtcDtcbn07XG5cbnZhciBDb25kaXRpb247XG4oZnVuY3Rpb24gKENvbmRpdGlvbikge1xuICAgIENvbmRpdGlvbltcIkVxdWFsXCJdID0gXCJlcXVhbFwiO1xuICAgIENvbmRpdGlvbltcIk5vdEVxdWFsXCJdID0gXCJub3RFcXVhbFwiO1xuICAgIENvbmRpdGlvbltcIkdyZWF0ZXJUaGFuXCJdID0gXCJncmVhdGVyVGhhblwiO1xuICAgIENvbmRpdGlvbltcIkdyZWF0ZXJUaGFuRXF1YWxcIl0gPSBcImdyZWF0ZXJUaGFuRXF1YWxcIjtcbiAgICBDb25kaXRpb25bXCJMZXNzVGhhblwiXSA9IFwibGVzc1RoYW5cIjtcbiAgICBDb25kaXRpb25bXCJMZXNzVGhhbkVxdWFsXCJdID0gXCJsZXNzVGhhbkVxdWFsXCI7XG4gICAgQ29uZGl0aW9uW1wiQ29udGFpbnNcIl0gPSBcImNvbnRhaW5zXCI7XG4gICAgQ29uZGl0aW9uW1wiSXNOdWxsXCJdID0gXCJpc051bGxcIjtcbiAgICBDb25kaXRpb25bXCJJc05vdE51bGxcIl0gPSBcImlzTm90TnVsbFwiO1xufSkoQ29uZGl0aW9uIHx8IChDb25kaXRpb24gPSB7fSkpO1xuLyoqXG4gKiBIZWxwZXIgY2xhc3MgdG8gZ2VuZXJhdGUgb3BlcmF0b3Igc3RyaW5ncyBmb3IgYXRvbWljIG9wZXJhdGlvbnMuXG4gKi9cbmNsYXNzIE9wZXJhdG9yIHtcbiAgICAvKipcbiAgICAgKiBDb25zdHJ1Y3RvciBmb3IgT3BlcmF0b3IgY2xhc3MuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbWV0aG9kXG4gICAgICogQHBhcmFtIHtPcGVyYXRvclZhbHVlc30gdmFsdWVzXG4gICAgICovXG4gICAgY29uc3RydWN0b3IobWV0aG9kLCB2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIGlmICh2YWx1ZXMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICAgICAgICAgIHRoaXMudmFsdWVzID0gdmFsdWVzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZXMgPSBbdmFsdWVzXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0IHRoZSBvcGVyYXRvciBvYmplY3QgdG8gYSBKU09OIHN0cmluZy5cbiAgICAgKlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9XG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBtZXRob2Q6IHRoaXMubWV0aG9kLFxuICAgICAgICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlcyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuLyoqXG4gKiBJbmNyZW1lbnQgYSBudW1lcmljIGF0dHJpYnV0ZSBieSBhIHNwZWNpZmllZCB2YWx1ZS5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmluY3JlbWVudCA9ICh2YWx1ZSA9IDEsIG1heCkgPT4ge1xuICAgIGlmIChpc05hTih2YWx1ZSkgfHwgIWlzRmluaXRlKHZhbHVlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJWYWx1ZSBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQgJiYgKGlzTmFOKG1heCkgfHwgIWlzRmluaXRlKG1heCkpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1heCBjYW5ub3QgYmUgTmFOIG9yIEluZmluaXR5XCIpO1xuICAgIH1cbiAgICBjb25zdCB2YWx1ZXMgPSBbdmFsdWVdO1xuICAgIGlmIChtYXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YWx1ZXMucHVzaChtYXgpO1xuICAgIH1cbiAgICByZXR1cm4gbmV3IE9wZXJhdG9yKFwiaW5jcmVtZW50XCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIERlY3JlbWVudCBhIG51bWVyaWMgYXR0cmlidXRlIGJ5IGEgc3BlY2lmaWVkIHZhbHVlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICogQHBhcmFtIHtudW1iZXJ9IG1pblxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuZGVjcmVtZW50ID0gKHZhbHVlID0gMSwgbWluKSA9PiB7XG4gICAgaWYgKGlzTmFOKHZhbHVlKSB8fCAhaXNGaW5pdGUodmFsdWUpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlZhbHVlIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiAoaXNOYU4obWluKSB8fCAhaXNGaW5pdGUobWluKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWluIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IFt2YWx1ZV07XG4gICAgaWYgKG1pbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG1pbik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3BlcmF0b3IoXCJkZWNyZW1lbnRcIiwgdmFsdWVzKS50b1N0cmluZygpO1xufTtcbi8qKlxuICogTXVsdGlwbHkgYSBudW1lcmljIGF0dHJpYnV0ZSBieSBhIHNwZWNpZmllZCBmYWN0b3IuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvclxuICogQHBhcmFtIHtudW1iZXJ9IG1heFxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IubXVsdGlwbHkgPSAoZmFjdG9yLCBtYXgpID0+IHtcbiAgICBpZiAoaXNOYU4oZmFjdG9yKSB8fCAhaXNGaW5pdGUoZmFjdG9yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWN0b3IgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXggY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW2ZhY3Rvcl07XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhbHVlcy5wdXNoKG1heCk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3BlcmF0b3IoXCJtdWx0aXBseVwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBEaXZpZGUgYSBudW1lcmljIGF0dHJpYnV0ZSBieSBhIHNwZWNpZmllZCBkaXZpc29yLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yXG4gKiBAcGFyYW0ge251bWJlcn0gbWluXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5kaXZpZGUgPSAoZGl2aXNvciwgbWluKSA9PiB7XG4gICAgaWYgKGlzTmFOKGRpdmlzb3IpIHx8ICFpc0Zpbml0ZShkaXZpc29yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc29yIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGlmIChtaW4gIT09IHVuZGVmaW5lZCAmJiAoaXNOYU4obWluKSB8fCAhaXNGaW5pdGUobWluKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWluIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmlzb3IgY2Fubm90IGJlIHplcm9cIik7XG4gICAgfVxuICAgIGNvbnN0IHZhbHVlcyA9IFtkaXZpc29yXTtcbiAgICBpZiAobWluICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVzLnB1c2gobWluKTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcImRpdmlkZVwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBBcHBseSBtb2R1bG8gb3BlcmF0aW9uIG9uIGEgbnVtZXJpYyBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRpdmlzb3JcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLm1vZHVsbyA9IChkaXZpc29yKSA9PiB7XG4gICAgaWYgKGlzTmFOKGRpdmlzb3IpIHx8ICFpc0Zpbml0ZShkaXZpc29yKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEaXZpc29yIGNhbm5vdCBiZSBOYU4gb3IgSW5maW5pdHlcIik7XG4gICAgfVxuICAgIGlmIChkaXZpc29yID09PSAwKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkRpdmlzb3IgY2Fubm90IGJlIHplcm9cIik7XG4gICAgfVxuICAgIHJldHVybiBuZXcgT3BlcmF0b3IoXCJtb2R1bG9cIiwgW2Rpdmlzb3JdKS50b1N0cmluZygpO1xufTtcbi8qKlxuICogUmFpc2UgYSBudW1lcmljIGF0dHJpYnV0ZSB0byBhIHNwZWNpZmllZCBwb3dlci5cbiAqXG4gKiBAcGFyYW0ge251bWJlcn0gZXhwb25lbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtYXhcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLnBvd2VyID0gKGV4cG9uZW50LCBtYXgpID0+IHtcbiAgICBpZiAoaXNOYU4oZXhwb25lbnQpIHx8ICFpc0Zpbml0ZShleHBvbmVudCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRXhwb25lbnQgY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgaWYgKG1heCAhPT0gdW5kZWZpbmVkICYmIChpc05hTihtYXgpIHx8ICFpc0Zpbml0ZShtYXgpKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJNYXggY2Fubm90IGJlIE5hTiBvciBJbmZpbml0eVwiKTtcbiAgICB9XG4gICAgY29uc3QgdmFsdWVzID0gW2V4cG9uZW50XTtcbiAgICBpZiAobWF4ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdmFsdWVzLnB1c2gobWF4KTtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBPcGVyYXRvcihcInBvd2VyXCIsIHZhbHVlcykudG9TdHJpbmcoKTtcbn07XG4vKipcbiAqIEFwcGVuZCB2YWx1ZXMgdG8gYW4gYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuYXJyYXlBcHBlbmQgPSAodmFsdWVzKSA9PiBuZXcgT3BlcmF0b3IoXCJhcnJheUFwcGVuZFwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFByZXBlbmQgdmFsdWVzIHRvIGFuIGFycmF5IGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge2FueVtdfSB2YWx1ZXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmFycmF5UHJlcGVuZCA9ICh2YWx1ZXMpID0+IG5ldyBPcGVyYXRvcihcImFycmF5UHJlcGVuZFwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG4vKipcbiAqIEluc2VydCBhIHZhbHVlIGF0IGEgc3BlY2lmaWMgaW5kZXggaW4gYW4gYXJyYXkgYXR0cmlidXRlLlxuICpcbiAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleFxuICogQHBhcmFtIHthbnl9IHZhbHVlXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheUluc2VydCA9IChpbmRleCwgdmFsdWUpID0+IG5ldyBPcGVyYXRvcihcImFycmF5SW5zZXJ0XCIsIFtpbmRleCwgdmFsdWVdKS50b1N0cmluZygpO1xuLyoqXG4gKiBSZW1vdmUgYSB2YWx1ZSBmcm9tIGFuIGFycmF5IGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmFycmF5UmVtb3ZlID0gKHZhbHVlKSA9PiBuZXcgT3BlcmF0b3IoXCJhcnJheVJlbW92ZVwiLCBbdmFsdWVdKS50b1N0cmluZygpO1xuLyoqXG4gKiBSZW1vdmUgZHVwbGljYXRlIHZhbHVlcyBmcm9tIGFuIGFycmF5IGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheVVuaXF1ZSA9ICgpID0+IG5ldyBPcGVyYXRvcihcImFycmF5VW5pcXVlXCIsIFtdKS50b1N0cmluZygpO1xuLyoqXG4gKiBLZWVwIG9ubHkgdmFsdWVzIHRoYXQgZXhpc3QgaW4gYm90aCB0aGUgY3VycmVudCBhcnJheSBhbmQgdGhlIHByb3ZpZGVkIGFycmF5LlxuICpcbiAqIEBwYXJhbSB7YW55W119IHZhbHVlc1xuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuYXJyYXlJbnRlcnNlY3QgPSAodmFsdWVzKSA9PiBuZXcgT3BlcmF0b3IoXCJhcnJheUludGVyc2VjdFwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJlbW92ZSB2YWx1ZXMgZnJvbSB0aGUgYXJyYXkgdGhhdCBleGlzdCBpbiB0aGUgcHJvdmlkZWQgYXJyYXkuXG4gKlxuICogQHBhcmFtIHthbnlbXX0gdmFsdWVzXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5hcnJheURpZmYgPSAodmFsdWVzKSA9PiBuZXcgT3BlcmF0b3IoXCJhcnJheURpZmZcIiwgdmFsdWVzKS50b1N0cmluZygpO1xuLyoqXG4gKiBGaWx0ZXIgYXJyYXkgdmFsdWVzIGJhc2VkIG9uIGEgY29uZGl0aW9uLlxuICpcbiAqIEBwYXJhbSB7Q29uZGl0aW9ufSBjb25kaXRpb25cbiAqIEBwYXJhbSB7YW55fSB2YWx1ZVxuICogQHJldHVybnMge3N0cmluZ31cbiAqL1xuT3BlcmF0b3IuYXJyYXlGaWx0ZXIgPSAoY29uZGl0aW9uLCB2YWx1ZSkgPT4ge1xuICAgIGNvbnN0IHZhbHVlcyA9IFtjb25kaXRpb24sIHZhbHVlID09PSB1bmRlZmluZWQgPyBudWxsIDogdmFsdWVdO1xuICAgIHJldHVybiBuZXcgT3BlcmF0b3IoXCJhcnJheUZpbHRlclwiLCB2YWx1ZXMpLnRvU3RyaW5nKCk7XG59O1xuLyoqXG4gKiBDb25jYXRlbmF0ZSBhIHZhbHVlIHRvIGEgc3RyaW5nIG9yIGFycmF5IGF0dHJpYnV0ZS5cbiAqXG4gKiBAcGFyYW0ge2FueX0gdmFsdWVcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLnN0cmluZ0NvbmNhdCA9ICh2YWx1ZSkgPT4gbmV3IE9wZXJhdG9yKFwic3RyaW5nQ29uY2F0XCIsIFt2YWx1ZV0pLnRvU3RyaW5nKCk7XG4vKipcbiAqIFJlcGxhY2Ugb2NjdXJyZW5jZXMgb2YgYSBzZWFyY2ggc3RyaW5nIHdpdGggYSByZXBsYWNlbWVudCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHNlYXJjaFxuICogQHBhcmFtIHtzdHJpbmd9IHJlcGxhY2VcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLnN0cmluZ1JlcGxhY2UgPSAoc2VhcmNoLCByZXBsYWNlKSA9PiBuZXcgT3BlcmF0b3IoXCJzdHJpbmdSZXBsYWNlXCIsIFtzZWFyY2gsIHJlcGxhY2VdKS50b1N0cmluZygpO1xuLyoqXG4gKiBUb2dnbGUgYSBib29sZWFuIGF0dHJpYnV0ZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci50b2dnbGUgPSAoKSA9PiBuZXcgT3BlcmF0b3IoXCJ0b2dnbGVcIiwgW10pLnRvU3RyaW5nKCk7XG4vKipcbiAqIEFkZCBkYXlzIHRvIGEgZGF0ZSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRheXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmRhdGVBZGREYXlzID0gKGRheXMpID0+IG5ldyBPcGVyYXRvcihcImRhdGVBZGREYXlzXCIsIFtkYXlzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogU3VidHJhY3QgZGF5cyBmcm9tIGEgZGF0ZSBhdHRyaWJ1dGUuXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGRheXNcbiAqIEByZXR1cm5zIHtzdHJpbmd9XG4gKi9cbk9wZXJhdG9yLmRhdGVTdWJEYXlzID0gKGRheXMpID0+IG5ldyBPcGVyYXRvcihcImRhdGVTdWJEYXlzXCIsIFtkYXlzXSkudG9TdHJpbmcoKTtcbi8qKlxuICogU2V0IGEgZGF0ZSBhdHRyaWJ1dGUgdG8gdGhlIGN1cnJlbnQgZGF0ZSBhbmQgdGltZS5cbiAqXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxuICovXG5PcGVyYXRvci5kYXRlU2V0Tm93ID0gKCkgPT4gbmV3IE9wZXJhdG9yKFwiZGF0ZVNldE5vd1wiLCBbXSkudG9TdHJpbmcoKTtcblxudmFyIEF1dGhlbnRpY2F0b3JUeXBlO1xuKGZ1bmN0aW9uIChBdXRoZW50aWNhdG9yVHlwZSkge1xuICAgIEF1dGhlbnRpY2F0b3JUeXBlW1wiVG90cFwiXSA9IFwidG90cFwiO1xufSkoQXV0aGVudGljYXRvclR5cGUgfHwgKEF1dGhlbnRpY2F0b3JUeXBlID0ge30pKTtcblxudmFyIEF1dGhlbnRpY2F0aW9uRmFjdG9yO1xuKGZ1bmN0aW9uIChBdXRoZW50aWNhdGlvbkZhY3Rvcikge1xuICAgIEF1dGhlbnRpY2F0aW9uRmFjdG9yW1wiRW1haWxcIl0gPSBcImVtYWlsXCI7XG4gICAgQXV0aGVudGljYXRpb25GYWN0b3JbXCJQaG9uZVwiXSA9IFwicGhvbmVcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlRvdHBcIl0gPSBcInRvdHBcIjtcbiAgICBBdXRoZW50aWNhdGlvbkZhY3RvcltcIlJlY292ZXJ5Y29kZVwiXSA9IFwicmVjb3Zlcnljb2RlXCI7XG59KShBdXRoZW50aWNhdGlvbkZhY3RvciB8fCAoQXV0aGVudGljYXRpb25GYWN0b3IgPSB7fSkpO1xuXG52YXIgT0F1dGhQcm92aWRlcjtcbihmdW5jdGlvbiAoT0F1dGhQcm92aWRlcikge1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBbWF6b25cIl0gPSBcImFtYXpvblwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJBcHBsZVwiXSA9IFwiYXBwbGVcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQXV0aDBcIl0gPSBcImF1dGgwXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkF1dGhlbnRpa1wiXSA9IFwiYXV0aGVudGlrXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkF1dG9kZXNrXCJdID0gXCJhdXRvZGVza1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCaXRidWNrZXRcIl0gPSBcImJpdGJ1Y2tldFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJCaXRseVwiXSA9IFwiYml0bHlcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiQm94XCJdID0gXCJib3hcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGFpbHltb3Rpb25cIl0gPSBcImRhaWx5bW90aW9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkRpc2NvcmRcIl0gPSBcImRpc2NvcmRcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRGlzcXVzXCJdID0gXCJkaXNxdXNcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiRHJvcGJveFwiXSA9IFwiZHJvcGJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJFdHN5XCJdID0gXCJldHN5XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIkZhY2Vib29rXCJdID0gXCJmYWNlYm9va1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJGaWdtYVwiXSA9IFwiZmlnbWFcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR2l0aHViXCJdID0gXCJnaXRodWJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR2l0bGFiXCJdID0gXCJnaXRsYWJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiR29vZ2xlXCJdID0gXCJnb29nbGVcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiTGlua2VkaW5cIl0gPSBcImxpbmtlZGluXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk1pY3Jvc29mdFwiXSA9IFwibWljcm9zb2Z0XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk5vdGlvblwiXSA9IFwibm90aW9uXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk9pZGNcIl0gPSBcIm9pZGNcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiT2t0YVwiXSA9IFwib2t0YVwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJQYXlwYWxcIl0gPSBcInBheXBhbFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJQYXlwYWxTYW5kYm94XCJdID0gXCJwYXlwYWxTYW5kYm94XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlBvZGlvXCJdID0gXCJwb2Rpb1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTYWxlc2ZvcmNlXCJdID0gXCJzYWxlc2ZvcmNlXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlNsYWNrXCJdID0gXCJzbGFja1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJTcG90aWZ5XCJdID0gXCJzcG90aWZ5XCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlN0cmlwZVwiXSA9IFwic3RyaXBlXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIlRyYWRlc2hpZnRcIl0gPSBcInRyYWRlc2hpZnRcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiVHJhZGVzaGlmdEJveFwiXSA9IFwidHJhZGVzaGlmdEJveFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJUd2l0Y2hcIl0gPSBcInR3aXRjaFwiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJXb3JkcHJlc3NcIl0gPSBcIndvcmRwcmVzc1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJZYWhvb1wiXSA9IFwieWFob29cIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWWFtbWVyXCJdID0gXCJ5YW1tZXJcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWWFuZGV4XCJdID0gXCJ5YW5kZXhcIjtcbiAgICBPQXV0aFByb3ZpZGVyW1wiWm9ob1wiXSA9IFwiem9ob1wiO1xuICAgIE9BdXRoUHJvdmlkZXJbXCJab29tXCJdID0gXCJ6b29tXCI7XG4gICAgT0F1dGhQcm92aWRlcltcIk1vY2tcIl0gPSBcIm1vY2tcIjtcbn0pKE9BdXRoUHJvdmlkZXIgfHwgKE9BdXRoUHJvdmlkZXIgPSB7fSkpO1xuXG52YXIgQnJvd3NlcjtcbihmdW5jdGlvbiAoQnJvd3Nlcikge1xuICAgIEJyb3dzZXJbXCJBdmFudEJyb3dzZXJcIl0gPSBcImFhXCI7XG4gICAgQnJvd3NlcltcIkFuZHJvaWRXZWJWaWV3QmV0YVwiXSA9IFwiYW5cIjtcbiAgICBCcm93c2VyW1wiR29vZ2xlQ2hyb21lXCJdID0gXCJjaFwiO1xuICAgIEJyb3dzZXJbXCJHb29nbGVDaHJvbWVJT1NcIl0gPSBcImNpXCI7XG4gICAgQnJvd3NlcltcIkdvb2dsZUNocm9tZU1vYmlsZVwiXSA9IFwiY21cIjtcbiAgICBCcm93c2VyW1wiQ2hyb21pdW1cIl0gPSBcImNyXCI7XG4gICAgQnJvd3NlcltcIk1vemlsbGFGaXJlZm94XCJdID0gXCJmZlwiO1xuICAgIEJyb3dzZXJbXCJTYWZhcmlcIl0gPSBcInNmXCI7XG4gICAgQnJvd3NlcltcIk1vYmlsZVNhZmFyaVwiXSA9IFwibWZcIjtcbiAgICBCcm93c2VyW1wiTWljcm9zb2Z0RWRnZVwiXSA9IFwicHNcIjtcbiAgICBCcm93c2VyW1wiTWljcm9zb2Z0RWRnZUlPU1wiXSA9IFwib2lcIjtcbiAgICBCcm93c2VyW1wiT3BlcmFNaW5pXCJdID0gXCJvbVwiO1xuICAgIEJyb3dzZXJbXCJPcGVyYVwiXSA9IFwib3BcIjtcbiAgICBCcm93c2VyW1wiT3BlcmFOZXh0XCJdID0gXCJvblwiO1xufSkoQnJvd3NlciB8fCAoQnJvd3NlciA9IHt9KSk7XG5cbnZhciBDcmVkaXRDYXJkO1xuKGZ1bmN0aW9uIChDcmVkaXRDYXJkKSB7XG4gICAgQ3JlZGl0Q2FyZFtcIkFtZXJpY2FuRXhwcmVzc1wiXSA9IFwiYW1leFwiO1xuICAgIENyZWRpdENhcmRbXCJBcmdlbmNhcmRcIl0gPSBcImFyZ2VuY2FyZFwiO1xuICAgIENyZWRpdENhcmRbXCJDYWJhbFwiXSA9IFwiY2FiYWxcIjtcbiAgICBDcmVkaXRDYXJkW1wiQ2VuY29zdWRcIl0gPSBcImNlbmNvc3VkXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIkRpbmVyc0NsdWJcIl0gPSBcImRpbmVyc1wiO1xuICAgIENyZWRpdENhcmRbXCJEaXNjb3ZlclwiXSA9IFwiZGlzY292ZXJcIjtcbiAgICBDcmVkaXRDYXJkW1wiRWxvXCJdID0gXCJlbG9cIjtcbiAgICBDcmVkaXRDYXJkW1wiSGlwZXJjYXJkXCJdID0gXCJoaXBlcmNhcmRcIjtcbiAgICBDcmVkaXRDYXJkW1wiSkNCXCJdID0gXCJqY2JcIjtcbiAgICBDcmVkaXRDYXJkW1wiTWFzdGVyY2FyZFwiXSA9IFwibWFzdGVyY2FyZFwiO1xuICAgIENyZWRpdENhcmRbXCJOYXJhbmphXCJdID0gXCJuYXJhbmphXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlRhcmpldGFTaG9wcGluZ1wiXSA9IFwidGFyZ2V0YS1zaG9wcGluZ1wiO1xuICAgIENyZWRpdENhcmRbXCJVbmlvblBheVwiXSA9IFwidW5pb25wYXlcIjtcbiAgICBDcmVkaXRDYXJkW1wiVmlzYVwiXSA9IFwidmlzYVwiO1xuICAgIENyZWRpdENhcmRbXCJNSVJcIl0gPSBcIm1pclwiO1xuICAgIENyZWRpdENhcmRbXCJNYWVzdHJvXCJdID0gXCJtYWVzdHJvXCI7XG4gICAgQ3JlZGl0Q2FyZFtcIlJ1cGF5XCJdID0gXCJydXBheVwiO1xufSkoQ3JlZGl0Q2FyZCB8fCAoQ3JlZGl0Q2FyZCA9IHt9KSk7XG5cbnZhciBGbGFnO1xuKGZ1bmN0aW9uIChGbGFnKSB7XG4gICAgRmxhZ1tcIkFmZ2hhbmlzdGFuXCJdID0gXCJhZlwiO1xuICAgIEZsYWdbXCJBbmdvbGFcIl0gPSBcImFvXCI7XG4gICAgRmxhZ1tcIkFsYmFuaWFcIl0gPSBcImFsXCI7XG4gICAgRmxhZ1tcIkFuZG9ycmFcIl0gPSBcImFkXCI7XG4gICAgRmxhZ1tcIlVuaXRlZEFyYWJFbWlyYXRlc1wiXSA9IFwiYWVcIjtcbiAgICBGbGFnW1wiQXJnZW50aW5hXCJdID0gXCJhclwiO1xuICAgIEZsYWdbXCJBcm1lbmlhXCJdID0gXCJhbVwiO1xuICAgIEZsYWdbXCJBbnRpZ3VhQW5kQmFyYnVkYVwiXSA9IFwiYWdcIjtcbiAgICBGbGFnW1wiQXVzdHJhbGlhXCJdID0gXCJhdVwiO1xuICAgIEZsYWdbXCJBdXN0cmlhXCJdID0gXCJhdFwiO1xuICAgIEZsYWdbXCJBemVyYmFpamFuXCJdID0gXCJhelwiO1xuICAgIEZsYWdbXCJCdXJ1bmRpXCJdID0gXCJiaVwiO1xuICAgIEZsYWdbXCJCZWxnaXVtXCJdID0gXCJiZVwiO1xuICAgIEZsYWdbXCJCZW5pblwiXSA9IFwiYmpcIjtcbiAgICBGbGFnW1wiQnVya2luYUZhc29cIl0gPSBcImJmXCI7XG4gICAgRmxhZ1tcIkJhbmdsYWRlc2hcIl0gPSBcImJkXCI7XG4gICAgRmxhZ1tcIkJ1bGdhcmlhXCJdID0gXCJiZ1wiO1xuICAgIEZsYWdbXCJCYWhyYWluXCJdID0gXCJiaFwiO1xuICAgIEZsYWdbXCJCYWhhbWFzXCJdID0gXCJic1wiO1xuICAgIEZsYWdbXCJCb3NuaWFBbmRIZXJ6ZWdvdmluYVwiXSA9IFwiYmFcIjtcbiAgICBGbGFnW1wiQmVsYXJ1c1wiXSA9IFwiYnlcIjtcbiAgICBGbGFnW1wiQmVsaXplXCJdID0gXCJielwiO1xuICAgIEZsYWdbXCJCb2xpdmlhXCJdID0gXCJib1wiO1xuICAgIEZsYWdbXCJCcmF6aWxcIl0gPSBcImJyXCI7XG4gICAgRmxhZ1tcIkJhcmJhZG9zXCJdID0gXCJiYlwiO1xuICAgIEZsYWdbXCJCcnVuZWlEYXJ1c3NhbGFtXCJdID0gXCJiblwiO1xuICAgIEZsYWdbXCJCaHV0YW5cIl0gPSBcImJ0XCI7XG4gICAgRmxhZ1tcIkJvdHN3YW5hXCJdID0gXCJid1wiO1xuICAgIEZsYWdbXCJDZW50cmFsQWZyaWNhblJlcHVibGljXCJdID0gXCJjZlwiO1xuICAgIEZsYWdbXCJDYW5hZGFcIl0gPSBcImNhXCI7XG4gICAgRmxhZ1tcIlN3aXR6ZXJsYW5kXCJdID0gXCJjaFwiO1xuICAgIEZsYWdbXCJDaGlsZVwiXSA9IFwiY2xcIjtcbiAgICBGbGFnW1wiQ2hpbmFcIl0gPSBcImNuXCI7XG4gICAgRmxhZ1tcIkNvdGVESXZvaXJlXCJdID0gXCJjaVwiO1xuICAgIEZsYWdbXCJDYW1lcm9vblwiXSA9IFwiY21cIjtcbiAgICBGbGFnW1wiRGVtb2NyYXRpY1JlcHVibGljT2ZUaGVDb25nb1wiXSA9IFwiY2RcIjtcbiAgICBGbGFnW1wiUmVwdWJsaWNPZlRoZUNvbmdvXCJdID0gXCJjZ1wiO1xuICAgIEZsYWdbXCJDb2xvbWJpYVwiXSA9IFwiY29cIjtcbiAgICBGbGFnW1wiQ29tb3Jvc1wiXSA9IFwia21cIjtcbiAgICBGbGFnW1wiQ2FwZVZlcmRlXCJdID0gXCJjdlwiO1xuICAgIEZsYWdbXCJDb3N0YVJpY2FcIl0gPSBcImNyXCI7XG4gICAgRmxhZ1tcIkN1YmFcIl0gPSBcImN1XCI7XG4gICAgRmxhZ1tcIkN5cHJ1c1wiXSA9IFwiY3lcIjtcbiAgICBGbGFnW1wiQ3plY2hSZXB1YmxpY1wiXSA9IFwiY3pcIjtcbiAgICBGbGFnW1wiR2VybWFueVwiXSA9IFwiZGVcIjtcbiAgICBGbGFnW1wiRGppYm91dGlcIl0gPSBcImRqXCI7XG4gICAgRmxhZ1tcIkRvbWluaWNhXCJdID0gXCJkbVwiO1xuICAgIEZsYWdbXCJEZW5tYXJrXCJdID0gXCJka1wiO1xuICAgIEZsYWdbXCJEb21pbmljYW5SZXB1YmxpY1wiXSA9IFwiZG9cIjtcbiAgICBGbGFnW1wiQWxnZXJpYVwiXSA9IFwiZHpcIjtcbiAgICBGbGFnW1wiRWN1YWRvclwiXSA9IFwiZWNcIjtcbiAgICBGbGFnW1wiRWd5cHRcIl0gPSBcImVnXCI7XG4gICAgRmxhZ1tcIkVyaXRyZWFcIl0gPSBcImVyXCI7XG4gICAgRmxhZ1tcIlNwYWluXCJdID0gXCJlc1wiO1xuICAgIEZsYWdbXCJFc3RvbmlhXCJdID0gXCJlZVwiO1xuICAgIEZsYWdbXCJFdGhpb3BpYVwiXSA9IFwiZXRcIjtcbiAgICBGbGFnW1wiRmlubGFuZFwiXSA9IFwiZmlcIjtcbiAgICBGbGFnW1wiRmlqaVwiXSA9IFwiZmpcIjtcbiAgICBGbGFnW1wiRnJhbmNlXCJdID0gXCJmclwiO1xuICAgIEZsYWdbXCJNaWNyb25lc2lhRmVkZXJhdGVkU3RhdGVzT2ZcIl0gPSBcImZtXCI7XG4gICAgRmxhZ1tcIkdhYm9uXCJdID0gXCJnYVwiO1xuICAgIEZsYWdbXCJVbml0ZWRLaW5nZG9tXCJdID0gXCJnYlwiO1xuICAgIEZsYWdbXCJHZW9yZ2lhXCJdID0gXCJnZVwiO1xuICAgIEZsYWdbXCJHaGFuYVwiXSA9IFwiZ2hcIjtcbiAgICBGbGFnW1wiR3VpbmVhXCJdID0gXCJnblwiO1xuICAgIEZsYWdbXCJHYW1iaWFcIl0gPSBcImdtXCI7XG4gICAgRmxhZ1tcIkd1aW5lYUJpc3NhdVwiXSA9IFwiZ3dcIjtcbiAgICBGbGFnW1wiRXF1YXRvcmlhbEd1aW5lYVwiXSA9IFwiZ3FcIjtcbiAgICBGbGFnW1wiR3JlZWNlXCJdID0gXCJnclwiO1xuICAgIEZsYWdbXCJHcmVuYWRhXCJdID0gXCJnZFwiO1xuICAgIEZsYWdbXCJHdWF0ZW1hbGFcIl0gPSBcImd0XCI7XG4gICAgRmxhZ1tcIkd1eWFuYVwiXSA9IFwiZ3lcIjtcbiAgICBGbGFnW1wiSG9uZHVyYXNcIl0gPSBcImhuXCI7XG4gICAgRmxhZ1tcIkNyb2F0aWFcIl0gPSBcImhyXCI7XG4gICAgRmxhZ1tcIkhhaXRpXCJdID0gXCJodFwiO1xuICAgIEZsYWdbXCJIdW5nYXJ5XCJdID0gXCJodVwiO1xuICAgIEZsYWdbXCJJbmRvbmVzaWFcIl0gPSBcImlkXCI7XG4gICAgRmxhZ1tcIkluZGlhXCJdID0gXCJpblwiO1xuICAgIEZsYWdbXCJJcmVsYW5kXCJdID0gXCJpZVwiO1xuICAgIEZsYWdbXCJJcmFuSXNsYW1pY1JlcHVibGljT2ZcIl0gPSBcImlyXCI7XG4gICAgRmxhZ1tcIklyYXFcIl0gPSBcImlxXCI7XG4gICAgRmxhZ1tcIkljZWxhbmRcIl0gPSBcImlzXCI7XG4gICAgRmxhZ1tcIklzcmFlbFwiXSA9IFwiaWxcIjtcbiAgICBGbGFnW1wiSXRhbHlcIl0gPSBcIml0XCI7XG4gICAgRmxhZ1tcIkphbWFpY2FcIl0gPSBcImptXCI7XG4gICAgRmxhZ1tcIkpvcmRhblwiXSA9IFwiam9cIjtcbiAgICBGbGFnW1wiSmFwYW5cIl0gPSBcImpwXCI7XG4gICAgRmxhZ1tcIkthemFraHN0YW5cIl0gPSBcImt6XCI7XG4gICAgRmxhZ1tcIktlbnlhXCJdID0gXCJrZVwiO1xuICAgIEZsYWdbXCJLeXJneXpzdGFuXCJdID0gXCJrZ1wiO1xuICAgIEZsYWdbXCJDYW1ib2RpYVwiXSA9IFwia2hcIjtcbiAgICBGbGFnW1wiS2lyaWJhdGlcIl0gPSBcImtpXCI7XG4gICAgRmxhZ1tcIlNhaW50S2l0dHNBbmROZXZpc1wiXSA9IFwia25cIjtcbiAgICBGbGFnW1wiU291dGhLb3JlYVwiXSA9IFwia3JcIjtcbiAgICBGbGFnW1wiS3V3YWl0XCJdID0gXCJrd1wiO1xuICAgIEZsYWdbXCJMYW9QZW9wbGVTRGVtb2NyYXRpY1JlcHVibGljXCJdID0gXCJsYVwiO1xuICAgIEZsYWdbXCJMZWJhbm9uXCJdID0gXCJsYlwiO1xuICAgIEZsYWdbXCJMaWJlcmlhXCJdID0gXCJsclwiO1xuICAgIEZsYWdbXCJMaWJ5YVwiXSA9IFwibHlcIjtcbiAgICBGbGFnW1wiU2FpbnRMdWNpYVwiXSA9IFwibGNcIjtcbiAgICBGbGFnW1wiTGllY2h0ZW5zdGVpblwiXSA9IFwibGlcIjtcbiAgICBGbGFnW1wiU3JpTGFua2FcIl0gPSBcImxrXCI7XG4gICAgRmxhZ1tcIkxlc290aG9cIl0gPSBcImxzXCI7XG4gICAgRmxhZ1tcIkxpdGh1YW5pYVwiXSA9IFwibHRcIjtcbiAgICBGbGFnW1wiTHV4ZW1ib3VyZ1wiXSA9IFwibHVcIjtcbiAgICBGbGFnW1wiTGF0dmlhXCJdID0gXCJsdlwiO1xuICAgIEZsYWdbXCJNb3JvY2NvXCJdID0gXCJtYVwiO1xuICAgIEZsYWdbXCJNb25hY29cIl0gPSBcIm1jXCI7XG4gICAgRmxhZ1tcIk1vbGRvdmFcIl0gPSBcIm1kXCI7XG4gICAgRmxhZ1tcIk1hZGFnYXNjYXJcIl0gPSBcIm1nXCI7XG4gICAgRmxhZ1tcIk1hbGRpdmVzXCJdID0gXCJtdlwiO1xuICAgIEZsYWdbXCJNZXhpY29cIl0gPSBcIm14XCI7XG4gICAgRmxhZ1tcIk1hcnNoYWxsSXNsYW5kc1wiXSA9IFwibWhcIjtcbiAgICBGbGFnW1wiTm9ydGhNYWNlZG9uaWFcIl0gPSBcIm1rXCI7XG4gICAgRmxhZ1tcIk1hbGlcIl0gPSBcIm1sXCI7XG4gICAgRmxhZ1tcIk1hbHRhXCJdID0gXCJtdFwiO1xuICAgIEZsYWdbXCJNeWFubWFyXCJdID0gXCJtbVwiO1xuICAgIEZsYWdbXCJNb250ZW5lZ3JvXCJdID0gXCJtZVwiO1xuICAgIEZsYWdbXCJNb25nb2xpYVwiXSA9IFwibW5cIjtcbiAgICBGbGFnW1wiTW96YW1iaXF1ZVwiXSA9IFwibXpcIjtcbiAgICBGbGFnW1wiTWF1cml0YW5pYVwiXSA9IFwibXJcIjtcbiAgICBGbGFnW1wiTWF1cml0aXVzXCJdID0gXCJtdVwiO1xuICAgIEZsYWdbXCJNYWxhd2lcIl0gPSBcIm13XCI7XG4gICAgRmxhZ1tcIk1hbGF5c2lhXCJdID0gXCJteVwiO1xuICAgIEZsYWdbXCJOYW1pYmlhXCJdID0gXCJuYVwiO1xuICAgIEZsYWdbXCJOaWdlclwiXSA9IFwibmVcIjtcbiAgICBGbGFnW1wiTmlnZXJpYVwiXSA9IFwibmdcIjtcbiAgICBGbGFnW1wiTmljYXJhZ3VhXCJdID0gXCJuaVwiO1xuICAgIEZsYWdbXCJOZXRoZXJsYW5kc1wiXSA9IFwibmxcIjtcbiAgICBGbGFnW1wiTm9yd2F5XCJdID0gXCJub1wiO1xuICAgIEZsYWdbXCJOZXBhbFwiXSA9IFwibnBcIjtcbiAgICBGbGFnW1wiTmF1cnVcIl0gPSBcIm5yXCI7XG4gICAgRmxhZ1tcIk5ld1plYWxhbmRcIl0gPSBcIm56XCI7XG4gICAgRmxhZ1tcIk9tYW5cIl0gPSBcIm9tXCI7XG4gICAgRmxhZ1tcIlBha2lzdGFuXCJdID0gXCJwa1wiO1xuICAgIEZsYWdbXCJQYW5hbWFcIl0gPSBcInBhXCI7XG4gICAgRmxhZ1tcIlBlcnVcIl0gPSBcInBlXCI7XG4gICAgRmxhZ1tcIlBoaWxpcHBpbmVzXCJdID0gXCJwaFwiO1xuICAgIEZsYWdbXCJQYWxhdVwiXSA9IFwicHdcIjtcbiAgICBGbGFnW1wiUGFwdWFOZXdHdWluZWFcIl0gPSBcInBnXCI7XG4gICAgRmxhZ1tcIlBvbGFuZFwiXSA9IFwicGxcIjtcbiAgICBGbGFnW1wiRnJlbmNoUG9seW5lc2lhXCJdID0gXCJwZlwiO1xuICAgIEZsYWdbXCJOb3J0aEtvcmVhXCJdID0gXCJrcFwiO1xuICAgIEZsYWdbXCJQb3J0dWdhbFwiXSA9IFwicHRcIjtcbiAgICBGbGFnW1wiUGFyYWd1YXlcIl0gPSBcInB5XCI7XG4gICAgRmxhZ1tcIlFhdGFyXCJdID0gXCJxYVwiO1xuICAgIEZsYWdbXCJSb21hbmlhXCJdID0gXCJyb1wiO1xuICAgIEZsYWdbXCJSdXNzaWFcIl0gPSBcInJ1XCI7XG4gICAgRmxhZ1tcIlJ3YW5kYVwiXSA9IFwicndcIjtcbiAgICBGbGFnW1wiU2F1ZGlBcmFiaWFcIl0gPSBcInNhXCI7XG4gICAgRmxhZ1tcIlN1ZGFuXCJdID0gXCJzZFwiO1xuICAgIEZsYWdbXCJTZW5lZ2FsXCJdID0gXCJzblwiO1xuICAgIEZsYWdbXCJTaW5nYXBvcmVcIl0gPSBcInNnXCI7XG4gICAgRmxhZ1tcIlNvbG9tb25Jc2xhbmRzXCJdID0gXCJzYlwiO1xuICAgIEZsYWdbXCJTaWVycmFMZW9uZVwiXSA9IFwic2xcIjtcbiAgICBGbGFnW1wiRWxTYWx2YWRvclwiXSA9IFwic3ZcIjtcbiAgICBGbGFnW1wiU2FuTWFyaW5vXCJdID0gXCJzbVwiO1xuICAgIEZsYWdbXCJTb21hbGlhXCJdID0gXCJzb1wiO1xuICAgIEZsYWdbXCJTZXJiaWFcIl0gPSBcInJzXCI7XG4gICAgRmxhZ1tcIlNvdXRoU3VkYW5cIl0gPSBcInNzXCI7XG4gICAgRmxhZ1tcIlNhb1RvbWVBbmRQcmluY2lwZVwiXSA9IFwic3RcIjtcbiAgICBGbGFnW1wiU3VyaW5hbWVcIl0gPSBcInNyXCI7XG4gICAgRmxhZ1tcIlNsb3Zha2lhXCJdID0gXCJza1wiO1xuICAgIEZsYWdbXCJTbG92ZW5pYVwiXSA9IFwic2lcIjtcbiAgICBGbGFnW1wiU3dlZGVuXCJdID0gXCJzZVwiO1xuICAgIEZsYWdbXCJFc3dhdGluaVwiXSA9IFwic3pcIjtcbiAgICBGbGFnW1wiU2V5Y2hlbGxlc1wiXSA9IFwic2NcIjtcbiAgICBGbGFnW1wiU3lyaWFcIl0gPSBcInN5XCI7XG4gICAgRmxhZ1tcIkNoYWRcIl0gPSBcInRkXCI7XG4gICAgRmxhZ1tcIlRvZ29cIl0gPSBcInRnXCI7XG4gICAgRmxhZ1tcIlRoYWlsYW5kXCJdID0gXCJ0aFwiO1xuICAgIEZsYWdbXCJUYWppa2lzdGFuXCJdID0gXCJ0alwiO1xuICAgIEZsYWdbXCJUdXJrbWVuaXN0YW5cIl0gPSBcInRtXCI7XG4gICAgRmxhZ1tcIlRpbW9yTGVzdGVcIl0gPSBcInRsXCI7XG4gICAgRmxhZ1tcIlRvbmdhXCJdID0gXCJ0b1wiO1xuICAgIEZsYWdbXCJUcmluaWRhZEFuZFRvYmFnb1wiXSA9IFwidHRcIjtcbiAgICBGbGFnW1wiVHVuaXNpYVwiXSA9IFwidG5cIjtcbiAgICBGbGFnW1wiVHVya2V5XCJdID0gXCJ0clwiO1xuICAgIEZsYWdbXCJUdXZhbHVcIl0gPSBcInR2XCI7XG4gICAgRmxhZ1tcIlRhbnphbmlhXCJdID0gXCJ0elwiO1xuICAgIEZsYWdbXCJVZ2FuZGFcIl0gPSBcInVnXCI7XG4gICAgRmxhZ1tcIlVrcmFpbmVcIl0gPSBcInVhXCI7XG4gICAgRmxhZ1tcIlVydWd1YXlcIl0gPSBcInV5XCI7XG4gICAgRmxhZ1tcIlVuaXRlZFN0YXRlc1wiXSA9IFwidXNcIjtcbiAgICBGbGFnW1wiVXpiZWtpc3RhblwiXSA9IFwidXpcIjtcbiAgICBGbGFnW1wiVmF0aWNhbkNpdHlcIl0gPSBcInZhXCI7XG4gICAgRmxhZ1tcIlNhaW50VmluY2VudEFuZFRoZUdyZW5hZGluZXNcIl0gPSBcInZjXCI7XG4gICAgRmxhZ1tcIlZlbmV6dWVsYVwiXSA9IFwidmVcIjtcbiAgICBGbGFnW1wiVmlldG5hbVwiXSA9IFwidm5cIjtcbiAgICBGbGFnW1wiVmFudWF0dVwiXSA9IFwidnVcIjtcbiAgICBGbGFnW1wiU2Ftb2FcIl0gPSBcIndzXCI7XG4gICAgRmxhZ1tcIlllbWVuXCJdID0gXCJ5ZVwiO1xuICAgIEZsYWdbXCJTb3V0aEFmcmljYVwiXSA9IFwiemFcIjtcbiAgICBGbGFnW1wiWmFtYmlhXCJdID0gXCJ6bVwiO1xuICAgIEZsYWdbXCJaaW1iYWJ3ZVwiXSA9IFwiendcIjtcbn0pKEZsYWcgfHwgKEZsYWcgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uTWV0aG9kO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25NZXRob2QpIHtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJHRVRcIl0gPSBcIkdFVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBPU1RcIl0gPSBcIlBPU1RcIjtcbiAgICBFeGVjdXRpb25NZXRob2RbXCJQVVRcIl0gPSBcIlBVVFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIlBBVENIXCJdID0gXCJQQVRDSFwiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkRFTEVURVwiXSA9IFwiREVMRVRFXCI7XG4gICAgRXhlY3V0aW9uTWV0aG9kW1wiT1BUSU9OU1wiXSA9IFwiT1BUSU9OU1wiO1xuICAgIEV4ZWN1dGlvbk1ldGhvZFtcIkhFQURcIl0gPSBcIkhFQURcIjtcbn0pKEV4ZWN1dGlvbk1ldGhvZCB8fCAoRXhlY3V0aW9uTWV0aG9kID0ge30pKTtcblxudmFyIEltYWdlR3Jhdml0eTtcbihmdW5jdGlvbiAoSW1hZ2VHcmF2aXR5KSB7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQ2VudGVyXCJdID0gXCJjZW50ZXJcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJUb3BsZWZ0XCJdID0gXCJ0b3AtbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIlRvcFwiXSA9IFwidG9wXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiVG9wcmlnaHRcIl0gPSBcInRvcC1yaWdodFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkxlZnRcIl0gPSBcImxlZnRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJSaWdodFwiXSA9IFwicmlnaHRcIjtcbiAgICBJbWFnZUdyYXZpdHlbXCJCb3R0b21sZWZ0XCJdID0gXCJib3R0b20tbGVmdFwiO1xuICAgIEltYWdlR3Jhdml0eVtcIkJvdHRvbVwiXSA9IFwiYm90dG9tXCI7XG4gICAgSW1hZ2VHcmF2aXR5W1wiQm90dG9tcmlnaHRcIl0gPSBcImJvdHRvbS1yaWdodFwiO1xufSkoSW1hZ2VHcmF2aXR5IHx8IChJbWFnZUdyYXZpdHkgPSB7fSkpO1xuXG52YXIgSW1hZ2VGb3JtYXQ7XG4oZnVuY3Rpb24gKEltYWdlRm9ybWF0KSB7XG4gICAgSW1hZ2VGb3JtYXRbXCJKcGdcIl0gPSBcImpwZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiSnBlZ1wiXSA9IFwianBlZ1wiO1xuICAgIEltYWdlRm9ybWF0W1wiUG5nXCJdID0gXCJwbmdcIjtcbiAgICBJbWFnZUZvcm1hdFtcIldlYnBcIl0gPSBcIndlYnBcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkhlaWNcIl0gPSBcImhlaWNcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkF2aWZcIl0gPSBcImF2aWZcIjtcbiAgICBJbWFnZUZvcm1hdFtcIkdpZlwiXSA9IFwiZ2lmXCI7XG59KShJbWFnZUZvcm1hdCB8fCAoSW1hZ2VGb3JtYXQgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uVHJpZ2dlcjtcbihmdW5jdGlvbiAoRXhlY3V0aW9uVHJpZ2dlcikge1xuICAgIEV4ZWN1dGlvblRyaWdnZXJbXCJIdHRwXCJdID0gXCJodHRwXCI7XG4gICAgRXhlY3V0aW9uVHJpZ2dlcltcIlNjaGVkdWxlXCJdID0gXCJzY2hlZHVsZVwiO1xuICAgIEV4ZWN1dGlvblRyaWdnZXJbXCJFdmVudFwiXSA9IFwiZXZlbnRcIjtcbn0pKEV4ZWN1dGlvblRyaWdnZXIgfHwgKEV4ZWN1dGlvblRyaWdnZXIgPSB7fSkpO1xuXG52YXIgRXhlY3V0aW9uU3RhdHVzO1xuKGZ1bmN0aW9uIChFeGVjdXRpb25TdGF0dXMpIHtcbiAgICBFeGVjdXRpb25TdGF0dXNbXCJXYWl0aW5nXCJdID0gXCJ3YWl0aW5nXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW1wiUHJvY2Vzc2luZ1wiXSA9IFwicHJvY2Vzc2luZ1wiO1xuICAgIEV4ZWN1dGlvblN0YXR1c1tcIkNvbXBsZXRlZFwiXSA9IFwiY29tcGxldGVkXCI7XG4gICAgRXhlY3V0aW9uU3RhdHVzW1wiRmFpbGVkXCJdID0gXCJmYWlsZWRcIjtcbiAgICBFeGVjdXRpb25TdGF0dXNbXCJTY2hlZHVsZWRcIl0gPSBcInNjaGVkdWxlZFwiO1xufSkoRXhlY3V0aW9uU3RhdHVzIHx8IChFeGVjdXRpb25TdGF0dXMgPSB7fSkpO1xuXG5leHBvcnQgeyBBY2NvdW50LCBBcHB3cml0ZUV4Y2VwdGlvbiwgQXV0aGVudGljYXRpb25GYWN0b3IsIEF1dGhlbnRpY2F0b3JUeXBlLCBBdmF0YXJzLCBCcm93c2VyLCBDbGllbnQsIENvbmRpdGlvbiwgQ3JlZGl0Q2FyZCwgRGF0YWJhc2VzLCBFeGVjdXRpb25NZXRob2QsIEV4ZWN1dGlvblN0YXR1cywgRXhlY3V0aW9uVHJpZ2dlciwgRmxhZywgRnVuY3Rpb25zLCBHcmFwaHFsLCBJRCwgSW1hZ2VGb3JtYXQsIEltYWdlR3Jhdml0eSwgTG9jYWxlLCBNZXNzYWdpbmcsIE9BdXRoUHJvdmlkZXIsIE9wZXJhdG9yLCBQZXJtaXNzaW9uLCBRdWVyeSwgUmVhbHRpbWUsIFJvbGUsIFN0b3JhZ2UsIFRhYmxlc0RCLCBUZWFtcyB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2RrLmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/appwrite/dist/esm/sdk.js\n");

/***/ })

};
;