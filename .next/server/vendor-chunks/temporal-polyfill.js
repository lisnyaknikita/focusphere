"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/temporal-polyfill";
exports.ids = ["vendor-chunks/temporal-polyfill"];
exports.modules = {

/***/ "(rsc)/./node_modules/temporal-polyfill/chunks/classApi.js":
/*!***********************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/classApi.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTimeFormat: () => (/* binding */ _n),\n/* harmony export */   IntlExtended: () => (/* binding */ eo),\n/* harmony export */   Temporal: () => (/* binding */ Xn),\n/* harmony export */   toTemporalInstant: () => (/* binding */ toTemporalInstant)\n/* harmony export */ });\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal.js */ \"(rsc)/./node_modules/temporal-polyfill/chunks/internal.js\");\nfunction createSlotClass(i, l, s, c, u) {\n  function Class(...t) {\n    if (!(this instanceof Class)) {\n      throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n    }\n    un(this, l(...t));\n  }\n  function bindMethod(t, e) {\n    return Object.defineProperties((function(...e) {\n      return t.call(this, getSpecificSlots(this), ...e);\n    }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(e));\n  }\n  function getSpecificSlots(t) {\n    const e = cn(t);\n    if (!e || e.branding !== i) {\n      throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n    }\n    return e;\n  }\n  return Object.defineProperties(Class.prototype, {\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createGetterDescriptors)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)(bindMethod, s)),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)(bindMethod, c)),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal.\" + i)\n  }), Object.defineProperties(Class, {\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)(u),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(i)\n  }), [ Class, t => {\n    const e = Object.create(Class.prototype);\n    return un(e, t), e;\n  }, getSpecificSlots ];\n}\n\nfunction rejectInvalidBag(t) {\n  if (cn(t) || void 0 !== t.calendar || void 0 !== t.timeZone) {\n    throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidBag);\n  }\n  return t;\n}\n\nfunction getCalendarIdFromBag(t) {\n  return extractCalendarIdFromBag(t) || _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId;\n}\n\nfunction extractCalendarIdFromBag(t) {\n  const {calendar: e} = t;\n  if (void 0 !== e) {\n    return refineCalendarArg(e);\n  }\n}\n\nfunction refineCalendarArg(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const {calendar: e} = cn(t) || {};\n    if (!e) {\n      throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCalendar)(t));\n    }\n    return e;\n  }\n  return (t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.resolveCalendarId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseCalendarId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString)(t))))(t);\n}\n\nfunction createCalendarGetters(t) {\n  const e = {};\n  for (const n in t) {\n    e[n] = t => {\n      const {calendar: e} = t;\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(e)[n](t);\n    };\n  }\n  return e;\n}\n\nfunction neverValueOf() {\n  throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.forbiddenValueOf);\n}\n\nfunction refineTimeZoneArg(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const {timeZone: e} = cn(t) || {};\n    if (!e) {\n      throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidTimeZone)(t));\n    }\n    return e;\n  }\n  return (t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.resolveTimeZoneId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseTimeZoneId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString)(t))))(t);\n}\n\nfunction toDurationSlots(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const e = cn(t);\n    return e && e.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.DurationBranding ? e : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineDurationBag)(t);\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseDuration)(t);\n}\n\nfunction refinePublicRelativeTo(t) {\n  if (void 0 !== t) {\n    if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n      const e = cn(t) || {};\n      switch (e.branding) {\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n        return e;\n\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n        return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(e);\n      }\n      const n = getCalendarIdFromBag(t);\n      return {\n        ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineMaybeZonedDateTimeBag)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(n), t),\n        calendar: n\n      };\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseRelativeToSlots)(t);\n  }\n}\n\nfunction toPlainTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)(n);\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainTimeBag)(t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainTime)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction optionalToPlainTimeFields(t) {\n  return void 0 === t ? void 0 : toPlainTimeSlots(t);\n}\n\nfunction toPlainDateTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateTimeSlots)({\n        ...n,\n        ..._internal_js__WEBPACK_IMPORTED_MODULE_0__.isoTimeFieldDefaults\n      });\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainDateTimeBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainDateTime)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainMonthDaySlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    if (n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainMonthDayBranding) {\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n    }\n    const o = extractCalendarIdFromBag(t);\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainMonthDayBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(o || _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId), !o, t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainMonthDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainYearMonthSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    return n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainYearMonthBranding ? ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n) : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainYearMonthBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainDateSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(n);\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainDateBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainDate)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toZonedDateTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    if (n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding) {\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineZonedFieldOptions)(e), n;\n    }\n    const o = getCalendarIdFromBag(t);\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineZonedDateTimeBag)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(o), o, t, e);\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseZonedDateTime)(t, e);\n}\n\nfunction adaptDateMethods(t) {\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)((t => e => t(slotsToIso(e))), t);\n}\n\nfunction slotsToIso(t) {\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedEpochSlotsToIso)(t, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone);\n}\n\nfunction toInstantSlots(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const e = cn(t);\n    if (e) {\n      switch (e.branding) {\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.InstantBranding:\n        return e;\n\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n        return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)(e.epochNanoseconds);\n      }\n    }\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseInstant)(t);\n}\n\nfunction toTemporalInstant() {\n  const t = Date.prototype.valueOf.call(this);\n  return Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.numberToBigNano)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireNumberIsInteger)(t), _internal_js__WEBPACK_IMPORTED_MODULE_0__.nanoInMilli)));\n}\n\nfunction createDateTimeFormatClass() {\n  function DateTimeFormatFunc(t, e) {\n    return new DateTimeFormatNew(t, e);\n  }\n  function DateTimeFormatNew(t, e = Object.create(null)) {\n    to.set(this, ((t, e) => {\n      const n = new _internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat(t, e), o = n.resolvedOptions(), r = o.locale, a = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.pluckProps)(Object.keys(e), o), i = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.memoize)(createFormatPrepperForBranding), prepFormat = (t, ...e) => {\n        if (t) {\n          if (2 !== e.length) {\n            throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n          }\n          for (const t of e) {\n            if (void 0 === t) {\n              throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n            }\n          }\n        }\n        t || void 0 !== e[0] || (e = []);\n        const o = e.map((t => cn(t) || Number(t)));\n        let l, s = 0;\n        for (const t of o) {\n          const e = \"object\" == typeof t ? t.branding : void 0;\n          if (s++ && e !== l) {\n            throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n          }\n          l = e;\n        }\n        return l ? i(l)(r, a, ...o) : [ n, ...o ];\n      };\n      return prepFormat.X = n, prepFormat;\n    })(t, e));\n  }\n  const t = _internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat.prototype, e = Object.getOwnPropertyDescriptors(t), n = Object.getOwnPropertyDescriptors(_internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat);\n  for (const t in e) {\n    const n = e[t], o = t.startsWith(\"format\") && createFormatMethod(t);\n    \"function\" == typeof n.value ? n.value = \"constructor\" === t ? DateTimeFormatFunc : o || createProxiedMethod(t) : o && (n.get = function() {\n      if (!to.has(this)) {\n        throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n      }\n      return (...t) => o.apply(this, t);\n    }, Object.defineProperties(n.get, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(`get ${t}`)));\n  }\n  return n.prototype.value = DateTimeFormatNew.prototype = Object.create({}, e), Object.defineProperties(DateTimeFormatFunc, n), \n  DateTimeFormatFunc;\n}\n\nfunction createFormatMethod(t) {\n  return Object.defineProperties((function(...e) {\n    const n = to.get(this), [o, ...r] = n(t.includes(\"Range\"), ...e);\n    return o[t](...r);\n  }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(t));\n}\n\nfunction createProxiedMethod(t) {\n  return Object.defineProperties((function(...e) {\n    return to.get(this).X[t](...e);\n  }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(t));\n}\n\nfunction createFormatPrepperForBranding(t) {\n  const e = Cn[t];\n  if (!e) {\n    throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidFormatType)(t));\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(e, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.memoize)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatForPrep), 1);\n}\n\n\n\nconst sn = /*@__PURE__*/ new WeakMap, cn = /*@__PURE__*/ sn.get.bind(sn), un = /*@__PURE__*/ sn.set.bind(sn), fn = {\n  era: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireStringOrUndefined,\n  eraYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireIntegerOrUndefined,\n  year: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireInteger,\n  month: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  daysInMonth: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  daysInYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  inLeapYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireBoolean,\n  monthsInYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, mn = {\n  monthCode: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString\n}, dn = {\n  day: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, Sn = {\n  dayOfWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  dayOfYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  weekOfYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveIntegerOrUndefined,\n  yearOfWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireIntegerOrUndefined,\n  daysInWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, Tn = /*@__PURE__*/ createCalendarGetters(/*@__PURE__*/ Object.assign({}, fn, mn, dn, Sn)), hn = /*@__PURE__*/ createCalendarGetters({\n  ...fn,\n  ...mn\n}), Dn = /*@__PURE__*/ createCalendarGetters({\n  ...mn,\n  ...dn\n}), Pn = {\n  calendarId: t => t.calendar\n}, gn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapPropNames)((t => e => e[t]), _internal_js__WEBPACK_IMPORTED_MODULE_0__.durationFieldNamesAsc.concat(\"sign\")), pn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapPropNames)(((t, e) => t => t[_internal_js__WEBPACK_IMPORTED_MODULE_0__.isoTimeFieldNamesAsc[e]]), _internal_js__WEBPACK_IMPORTED_MODULE_0__.timeFieldNamesAsc), On = {\n  epochMilliseconds: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getEpochMilli,\n  epochNanoseconds: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getEpochNano\n}, [wn, In, vn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.DurationBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructDurationSlots, {\n  ...gn,\n  blank: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getDurationBlank\n}, {\n  with: (t, e) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.durationWithFields)(t, e)),\n  negated: t => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.negateDuration)(t)),\n  abs: t => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.absDuration)(t)),\n  add: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.addDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.addDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toDurationSlots(e), n)),\n  round: (t, e) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundDuration)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e)),\n  total: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.totalDuration)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toLocaleString(t, e, n) {\n    return Intl.DurationFormat ? new Intl.DurationFormat(e, n).format(this) : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso)(t);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: t => In(toDurationSlots(t)),\n  compare: (t, e, n) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, toDurationSlots(t), toDurationSlots(e), n)\n}), Cn = {\n  Instant: _internal_js__WEBPACK_IMPORTED_MODULE_0__.instantConfig,\n  PlainDateTime: _internal_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeConfig,\n  PlainDate: _internal_js__WEBPACK_IMPORTED_MODULE_0__.dateConfig,\n  PlainTime: _internal_js__WEBPACK_IMPORTED_MODULE_0__.timeConfig,\n  PlainYearMonth: _internal_js__WEBPACK_IMPORTED_MODULE_0__.yearMonthConfig,\n  PlainMonthDay: _internal_js__WEBPACK_IMPORTED_MODULE_0__.monthDayConfig\n}, bn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantConfig), Fn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedConfig), Mn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeConfig), Zn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.dateConfig), yn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.timeConfig), jn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.yearMonthConfig), Nn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.monthDayConfig), [An, Bn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainTimeBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainTimeSlots, pn, {\n  with(t, e, n) {\n    return Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainTimeWithFields)(this, rejectInvalidBag(e), n));\n  },\n  add: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainTime)(0, t, toDurationSlots(e))),\n  subtract: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainTime)(1, t, toDurationSlots(e))),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainTimes)(0, t, toPlainTimeSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainTimes)(1, t, toPlainTimeSlots(e), n)),\n  round: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundPlainTime)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainTimesEqual)(t, toPlainTimeSlots(e)),\n  toLocaleString(t, e, n) {\n    const [o, r] = yn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainTimeIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainTimeIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Bn(toPlainTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoTimeFields)(toPlainTimeSlots(t), toPlainTimeSlots(e))\n}), [Yn, En] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainDateTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Tn,\n  ...pn\n}, {\n  with: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  withPlainTime: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeWithPlainTime)(t, optionalToPlainTimeFields(e))),\n  add: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainDateTimeSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainDateTimeSlots(e), n)),\n  round: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundPlainDateTime)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimesEqual)(t, toPlainDateTimeSlots(e)),\n  toZonedDateTime: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeToZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, refineTimeZoneArg(e), n)),\n  toPlainDate: t => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(t)),\n  toPlainTime: t => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)(t)),\n  toLocaleString(t, e, n) {\n    const [o, r] = Mn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateTimeIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateTimeIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => En(toPlainDateTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateTimeFields)(toPlainDateTimeSlots(t), toPlainDateTimeSlots(e))\n}), [Ln, Vn, Jn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainMonthDayBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainMonthDaySlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Dn\n}, {\n  with: (t, e, n) => Vn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDayWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDaysEqual)(t, toPlainMonthDaySlots(e)),\n  toPlainDate(t, e) {\n    return Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDayToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this, e));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = Nn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainMonthDayIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainMonthDayIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Vn(toPlainMonthDaySlots(t, e))\n}), [kn, qn, Rn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainYearMonthBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainYearMonthSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...hn\n}, {\n  with: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  add: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainYearMonthSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainYearMonthSlots(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthsEqual)(t, toPlainYearMonthSlots(e)),\n  toPlainDate(t, e) {\n    return Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this, e));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = jn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainYearMonthIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainYearMonthIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => qn(toPlainYearMonthSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateFields)(toPlainYearMonthSlots(t), toPlainYearMonthSlots(e))\n}), [xn, Wn, Gn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainDateSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Tn\n}, {\n  with: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  add: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDates)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainDateSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDates)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainDateSlots(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDatesEqual)(t, toPlainDateSlots(e)),\n  toZonedDateTime(t, e) {\n    const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(e) ? e : {\n      timeZone: e\n    };\n    return $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToZonedDateTime)(refineTimeZoneArg, toPlainTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, n));\n  },\n  toPlainDateTime: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainDateTime)(t, optionalToPlainTimeFields(e))),\n  toPlainYearMonth(t) {\n    return qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this));\n  },\n  toPlainMonthDay(t) {\n    return Vn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainMonthDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = Zn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Wn(toPlainDateSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateFields)(toPlainDateSlots(t), toPlainDateSlots(e))\n}), [zn, $n] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructZonedDateTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineTimeZoneId), {\n  ...On,\n  ...Pn,\n  ...adaptDateMethods(Tn),\n  ...adaptDateMethods(pn),\n  offset: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatOffsetNano)(slotsToIso(t).offsetNanoseconds),\n  offsetNanoseconds: t => slotsToIso(t).offsetNanoseconds,\n  timeZoneId: t => t.timeZone,\n  hoursInDay: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.computeZonedHoursInDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)\n}, {\n  with: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  withTimeZone: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithTimeZoneId)(t, refineTimeZoneArg(e))),\n  withPlainTime: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeWithPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, optionalToPlainTimeFields(e))),\n  add: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createDurationSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffZonedDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toZonedDateTimeSlots(e), n))),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createDurationSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffZonedDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toZonedDateTimeSlots(e), n))),\n  round: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e)),\n  startOfDay: t => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.computeZonedStartOfDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimesEqual)(t, toZonedDateTimeSlots(e)),\n  toInstant: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToInstant)(t)),\n  toPlainDateTime: t => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toPlainDate: t => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toPlainTime: t => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toLocaleString(t, e, n = {}) {\n    const [o, r] = Fn(e, n, t);\n    return o.format(r);\n  },\n  toString: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatZonedDateTimeIso)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatZonedDateTimeIso)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t),\n  valueOf: neverValueOf,\n  getTimeZoneTransition(t, e) {\n    const {timeZone: n, epochNanoseconds: o} = t, r = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineDirectionOptions)(e), a = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(n).O(o, r);\n    return a ? $n({\n      ...t,\n      epochNanoseconds: a\n    }) : null;\n  }\n}, {\n  from: (t, e) => $n(toZonedDateTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareZonedDateTimes)(toZonedDateTimeSlots(t), toZonedDateTimeSlots(e))\n}), [Hn, Kn, Qn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.InstantBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructInstantSlots, On, {\n  add: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveInstant)(0, t, toDurationSlots(e))),\n  subtract: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveInstant)(1, t, toDurationSlots(e))),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffInstants)(0, t, toInstantSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffInstants)(1, t, toInstantSlots(e), n)),\n  round: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundInstant)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantsEqual)(t, toInstantSlots(e)),\n  toZonedDateTimeISO: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantToZonedDateTime)(t, refineTimeZoneArg(e))),\n  toLocaleString(t, e, n) {\n    const [o, r] = bn(e, n, t);\n    return o.format(r);\n  },\n  toString: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatInstantIso)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatInstantIso)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t),\n  valueOf: neverValueOf\n}, {\n  from: t => Kn(toInstantSlots(t)),\n  fromEpochMilliseconds: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.epochMilliToInstant)(t)),\n  fromEpochNanoseconds: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.epochNanoToInstant)(t)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareInstants)(toInstantSlots(t), toInstantSlots(e))\n}), Un = /*@__PURE__*/ Object.defineProperties({}, {\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal.Now\"),\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n    timeZoneId: () => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)(),\n    instant: () => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentEpochNano)())),\n    zonedDateTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createZonedDateTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentEpochNano)(), refineTimeZoneArg(t), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainDateTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t))), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainDateISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t))), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t)))))\n  })\n}), Xn = /*@__PURE__*/ Object.defineProperties({}, {\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal\"),\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n    PlainYearMonth: kn,\n    PlainMonthDay: Ln,\n    PlainDate: xn,\n    PlainTime: An,\n    PlainDateTime: Yn,\n    ZonedDateTime: zn,\n    Instant: Hn,\n    Duration: wn,\n    Now: Un\n  })\n}), _n = /*@__PURE__*/ createDateTimeFormatClass(), to = /*@__PURE__*/ new WeakMap, eo = /*@__PURE__*/ Object.defineProperties(Object.create(Intl), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  DateTimeFormat: _n\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvY2h1bmtzL2NsYXNzQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRyxtRUFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxRUFBQyxDQUFDLHNEQUFDO0FBQ1YsT0FBTyxtRUFBQyxDQUFDLHNEQUFDO0FBQ1YsT0FBTyx3RUFBQztBQUNSLEdBQUc7QUFDSCxPQUFPLG1FQUFDO0FBQ1IsT0FBTyxtRUFBQztBQUNSLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQUM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHVEQUFDO0FBQ3pDOztBQUVBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQLFdBQVcsYUFBYTtBQUN4QjtBQUNBLDBCQUEwQiw2REFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFDLENBQUMsNkRBQUMsQ0FBQywyREFBQztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLHFFQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMERBQUM7QUFDdkI7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1AsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsMEJBQTBCLDZEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQUMsQ0FBQyw2REFBQyxDQUFDLDJEQUFDO0FBQ3BCOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQO0FBQ0EsK0JBQStCLDBEQUFDLE9BQU8sK0RBQUM7QUFDeEM7QUFDQSxTQUFTLDJEQUFDO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFFBQVEsMERBQUM7QUFDVDtBQUNBO0FBQ0EsWUFBWSwrREFBQztBQUNiLFlBQVksMkRBQUM7QUFDYjs7QUFFQSxZQUFZLCtEQUFDO0FBQ2IsZUFBZSxrRUFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlFQUFDLG9CQUFvQiw2REFBQyxFQUFFLHFFQUFDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQUM7QUFDWjtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQO0FBQ0E7QUFDQSxVQUFVLDJEQUFFO0FBQ1osYUFBYSxtRUFBRTs7QUFFZixVQUFVLCtEQUFDO0FBQ1gsYUFBYSxtRUFBRSxLQUFLLGtFQUFFOztBQUV0QixVQUFVLCtEQUFDO0FBQ1gsYUFBYSxtRUFBRSxLQUFLLHNFQUFFLENBQUMsNkRBQUM7QUFDeEI7QUFDQSxXQUFXLGdFQUFFO0FBQ2I7QUFDQSxZQUFZLDREQUFFO0FBQ2QsU0FBUyxtRUFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBO0FBQ0EsVUFBVSwrREFBQztBQUNYLGFBQWEsbUVBQUU7O0FBRWYsVUFBVSwyREFBQztBQUNYLGFBQWEsbUVBQUUsS0FBSyxzRUFBRTtBQUN0QjtBQUNBLFdBQVcsOERBQUU7QUFDYixPQUFPOztBQUVQLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssMEVBQUUsQ0FBQyw2REFBQztBQUN4QjtBQUNBLFdBQVcsb0VBQUUsQ0FBQyxxRUFBQztBQUNmO0FBQ0EsWUFBWSxnRUFBRTtBQUNkLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLDRCQUE0QiwrREFBRTtBQUM5QixhQUFhLG1FQUFFO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsb0VBQUUsQ0FBQyxxRUFBQyxNQUFNLHVEQUFDO0FBQ3RCO0FBQ0EsWUFBWSxnRUFBRSxDQUFDLGlFQUFDO0FBQ2hCLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLCtCQUErQixnRUFBRSxJQUFJLG1FQUFFLFVBQVUscUVBQUUsQ0FBQyxxRUFBQztBQUNyRDtBQUNBLFlBQVksaUVBQUUsQ0FBQyxpRUFBQztBQUNoQixTQUFTLG1FQUFFO0FBQ1g7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1A7QUFDQTtBQUNBLFVBQVUsMkRBQUM7QUFDWCxhQUFhLG1FQUFFOztBQUVmLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssa0VBQUM7O0FBRXJCLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssc0VBQUUsQ0FBQyw2REFBQztBQUN4QjtBQUNBLFdBQVcsZ0VBQUUsQ0FBQyxxRUFBQztBQUNmO0FBQ0EsWUFBWSw0REFBRTtBQUNkLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLDRCQUE0QiwrREFBQztBQUM3QixhQUFhLHFFQUFFO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsb0VBQUUsb0JBQW9CLDZEQUFDLEVBQUUscUVBQUM7QUFDckM7QUFDQSxTQUFTLGdFQUFFO0FBQ1g7O0FBRUE7QUFDQSxTQUFTLHNEQUFDO0FBQ1Y7O0FBRUE7QUFDQSxTQUFTLGtFQUFFLElBQUksNkRBQUM7QUFDaEI7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBRTtBQUNkOztBQUVBLFlBQVksK0RBQUM7QUFDYixlQUFlLGdFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQUU7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnRUFBRSxDQUFDLDZEQUFFLENBQUMsb0VBQUUsS0FBSyxxREFBRTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQUUsbURBQW1ELHdEQUFFLHlCQUF5QixxREFBRTtBQUN0RztBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBRTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0VBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSwyREFBRSwwRkFBMEYsMkRBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQUM7QUFDN0I7QUFDQTtBQUNBLEtBQUssaUNBQWlDLG1FQUFDLFFBQVEsRUFBRTtBQUNqRDtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHLG1FQUFDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHLG1FQUFDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFFO0FBQzFCO0FBQ0EsU0FBUyxpRUFBQyxJQUFJLHFEQUFFLENBQUMsNkRBQUU7QUFDbkI7O0FBRWczSTs7QUFFaDNJO0FBQ0EsT0FBTyxrRUFBQztBQUNSLFdBQVcsbUVBQUM7QUFDWixRQUFRLHdEQUFDO0FBQ1QsU0FBUyxnRUFBQztBQUNWLGVBQWUsZ0VBQUM7QUFDaEIsY0FBYyxnRUFBQztBQUNmLGNBQWMsd0RBQUM7QUFDZixnQkFBZ0IsZ0VBQUM7QUFDakIsQ0FBQztBQUNELGFBQWEsdURBQUM7QUFDZCxDQUFDO0FBQ0QsT0FBTyxnRUFBQztBQUNSLENBQUM7QUFDRCxhQUFhLGdFQUFDO0FBQ2QsYUFBYSxnRUFBQztBQUNkLGNBQWMsMkVBQUM7QUFDZixjQUFjLG1FQUFDO0FBQ2YsY0FBYyxnRUFBQztBQUNmLENBQUMseUVBQXlFO0FBQzFFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMscUJBQXFCLDBEQUFDLG1CQUFtQiwrREFBQyxxQ0FBcUMsMERBQUMsbUJBQW1CLDhEQUFDLE9BQU8sMkRBQUM7QUFDN0cscUJBQXFCLHVEQUFDO0FBQ3RCLG9CQUFvQixzREFBQztBQUNyQixDQUFDLGlDQUFpQywwREFBQyxFQUFFLGdFQUFDO0FBQ3RDO0FBQ0EsU0FBUywwREFBQztBQUNWLENBQUM7QUFDRCxxQkFBcUIsZ0VBQUM7QUFDdEIsbUJBQW1CLDREQUFDO0FBQ3BCLGVBQWUseURBQUM7QUFDaEIsdUJBQXVCLDBEQUFDLHlCQUF5QixpRUFBQyxFQUFFLDZEQUFDO0FBQ3JELDRCQUE0QiwwREFBQyx5QkFBeUIsaUVBQUMsRUFBRSw2REFBQztBQUMxRCxzQkFBc0IsMkRBQUMseUJBQXlCLGlFQUFDLEVBQUUsNkRBQUM7QUFDcEQsbUJBQW1CLDJEQUFDLHlCQUF5QixpRUFBQyxFQUFFLDZEQUFDO0FBQ2pEO0FBQ0EsOEVBQThFLCtEQUFDO0FBQy9FLEdBQUc7QUFDSCxZQUFZLDJEQUFDO0FBQ2IsZUFBZSwrREFBQztBQUNoQjtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3Qiw4REFBQyx5QkFBeUIsaUVBQUMsRUFBRSw2REFBQztBQUN0RCxDQUFDO0FBQ0QsV0FBVyx1REFBQztBQUNaLGlCQUFpQix3REFBQztBQUNsQixhQUFhLG9EQUFDO0FBQ2QsYUFBYSxvREFBRTtBQUNmLGtCQUFrQix5REFBRTtBQUNwQixpQkFBaUIsd0RBQUU7QUFDbkIsQ0FBQyxxQkFBcUIsaUVBQUMsQ0FBQyx1REFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxxREFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx3REFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxvREFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxvREFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx5REFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx3REFBRSw4QkFBOEIsMkRBQUUsRUFBRSxpRUFBRTtBQUN2TjtBQUNBLGNBQWMsaUVBQUU7QUFDaEIsR0FBRztBQUNILG9CQUFvQiwyREFBRTtBQUN0Qix5QkFBeUIsMkRBQUU7QUFDM0IseUJBQXlCLDREQUFFO0FBQzNCLHlCQUF5Qiw0REFBRTtBQUMzQixzQkFBc0IsNERBQUU7QUFDeEIsb0JBQW9CLDZEQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFFO0FBQ2QsZUFBZSxnRUFBRTtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixrRUFBRTtBQUN2QixDQUFDLDhCQUE4QiwrREFBQyxFQUFFLHNEQUFFLENBQUMscUVBQUUsRUFBRSwwREFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLHFFQUFFLENBQUMsaUVBQUM7QUFDNUIsNkJBQTZCLGlFQUFFO0FBQy9CLDhCQUE4Qix3RUFBRTtBQUNoQyx1QkFBdUIsK0RBQUUsQ0FBQyxpRUFBQztBQUMzQiw0QkFBNEIsK0RBQUUsQ0FBQyxpRUFBQztBQUNoQyx5QkFBeUIsZ0VBQUUsQ0FBQyxpRUFBQztBQUM3Qix5QkFBeUIsZ0VBQUUsQ0FBQyxpRUFBQztBQUM3QixzQkFBc0IsZ0VBQUU7QUFDeEIsb0JBQW9CLGlFQUFFO0FBQ3RCLG1DQUFtQywwRUFBRSxDQUFDLDZEQUFDO0FBQ3ZDLHVCQUF1QixrRUFBQztBQUN4Qix1QkFBdUIsa0VBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksZ0VBQUU7QUFDZCxlQUFlLG9FQUFFO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLHNFQUFFO0FBQ3ZCLENBQUMsa0NBQWtDLCtEQUFFLEVBQUUsc0RBQUUsQ0FBQyxxRUFBRSxFQUFFLDBEQUFFO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLHFFQUFFLENBQUMsaUVBQUM7QUFDNUIsb0JBQW9CLGlFQUFFO0FBQ3RCO0FBQ0EsY0FBYyxzRUFBRSxDQUFDLGlFQUFDO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxnRUFBRTtBQUNkLGVBQWUsb0VBQUU7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDLGtDQUFrQyxnRUFBRSxFQUFFLHNEQUFFLENBQUMsc0VBQUUsRUFBRSwwREFBRTtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixzRUFBRSxDQUFDLGlFQUFDO0FBQzVCLHVCQUF1QixnRUFBRSxDQUFDLGlFQUFDO0FBQzNCLDRCQUE0QixnRUFBRSxDQUFDLGlFQUFDO0FBQ2hDLHlCQUF5QixnRUFBRSxDQUFDLGlFQUFDO0FBQzdCLHlCQUF5QixnRUFBRSxDQUFDLGlFQUFDO0FBQzdCLG9CQUFvQixrRUFBRTtBQUN0QjtBQUNBLGNBQWMsdUVBQUUsQ0FBQyxpRUFBQztBQUNsQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksaUVBQUU7QUFDZCxlQUFlLHFFQUFFO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLGtFQUFFO0FBQ3ZCLENBQUMsa0NBQWtDLDJEQUFDLEVBQUUsc0RBQUUsQ0FBQyxpRUFBRSxFQUFFLDBEQUFFO0FBQy9DO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLGlFQUFFLENBQUMsaUVBQUM7QUFDNUIsNkJBQTZCLGlFQUFFO0FBQy9CLHVCQUF1QiwyREFBRSxDQUFDLGlFQUFDO0FBQzNCLDRCQUE0QiwyREFBRSxDQUFDLGlFQUFDO0FBQ2hDLHlCQUF5Qiw0REFBRSxDQUFDLGlFQUFDO0FBQzdCLHlCQUF5Qiw0REFBRSxDQUFDLGlFQUFDO0FBQzdCLG9CQUFvQiw2REFBRTtBQUN0QjtBQUNBLGNBQWMsMERBQUM7QUFDZjtBQUNBO0FBQ0EsY0FBYyxzRUFBRSxzQ0FBc0MsNkRBQUM7QUFDdkQsR0FBRztBQUNILGdDQUFnQyxzRUFBRTtBQUNsQztBQUNBLGNBQWMsdUVBQUUsQ0FBQyxpRUFBQztBQUNsQixHQUFHO0FBQ0g7QUFDQSxjQUFjLHNFQUFFLENBQUMsaUVBQUM7QUFDbEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFFO0FBQ2QsZUFBZSxnRUFBRTtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixrRUFBRTtBQUN2QixDQUFDLDhCQUE4QiwrREFBQyxFQUFFLHNEQUFFLENBQUMscUVBQUUsRUFBRSwwREFBRSxFQUFFLDBEQUFFO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBRTtBQUNqQjtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFFLENBQUMsNkRBQUM7QUFDdkIsQ0FBQztBQUNELHdCQUF3QixxRUFBRSxDQUFDLGlFQUFDLEVBQUUsNkRBQUM7QUFDL0IsNkJBQTZCLGlFQUFFO0FBQy9CLDZCQUE2QixpRUFBRTtBQUMvQiw4QkFBOEIsd0VBQUUsQ0FBQyw2REFBQztBQUNsQyx1QkFBdUIsK0RBQUUsQ0FBQyxpRUFBQyxFQUFFLDZEQUFDO0FBQzlCLDRCQUE0QiwrREFBRSxDQUFDLGlFQUFDLEVBQUUsNkRBQUM7QUFDbkMseUJBQXlCLGlFQUFFLENBQUMsZ0VBQUUsQ0FBQyxpRUFBQyxFQUFFLDZEQUFDO0FBQ25DLHlCQUF5QixpRUFBRSxDQUFDLGdFQUFFLENBQUMsaUVBQUMsRUFBRSw2REFBQztBQUNuQyxzQkFBc0IsZ0VBQUUsQ0FBQyw2REFBQztBQUMxQixzQkFBc0Isb0VBQUUsQ0FBQyw2REFBQztBQUMxQixvQkFBb0IsaUVBQUU7QUFDdEIscUJBQXFCLG9FQUFFO0FBQ3ZCLDJCQUEyQiwwRUFBRSxDQUFDLDZEQUFDO0FBQy9CLHVCQUF1QixzRUFBRSxDQUFDLDZEQUFDO0FBQzNCLHVCQUF1QixzRUFBRSxDQUFDLDZEQUFDO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixvRUFBRSxDQUFDLDZEQUFDO0FBQzFCLGVBQWUsb0VBQUUsQ0FBQyw2REFBQztBQUNuQjtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0MsU0FBUyxvRUFBRSxTQUFTLGlFQUFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtRUFBRTtBQUN2QixDQUFDLGtDQUFrQyx5REFBRSxFQUFFLCtEQUFFO0FBQ3pDLG9CQUFvQix5REFBRTtBQUN0Qix5QkFBeUIseURBQUU7QUFDM0IseUJBQXlCLDBEQUFFO0FBQzNCLHlCQUF5QiwwREFBRTtBQUMzQixzQkFBc0IsMERBQUU7QUFDeEIsb0JBQW9CLDJEQUFFO0FBQ3RCLG1DQUFtQyxvRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDhEQUFFLG9CQUFvQiw2REFBQztBQUM3QyxlQUFlLDhEQUFFLG9CQUFvQiw2REFBQztBQUN0QztBQUNBLENBQUM7QUFDRDtBQUNBLGlDQUFpQyxpRUFBRTtBQUNuQyxnQ0FBZ0MsZ0VBQUU7QUFDbEMscUJBQXFCLDZEQUFFO0FBQ3ZCLENBQUMsZ0RBQWdEO0FBQ2pELEtBQUssd0VBQUM7QUFDTixLQUFLLG1FQUFDO0FBQ04sc0JBQXNCLGtFQUFFO0FBQ3hCLHNCQUFzQixnRUFBRSxDQUFDLGlFQUFFO0FBQzNCLDJCQUEyQixrRUFBRSxVQUFVLHNFQUFFLENBQUMsaUVBQUUsMEJBQTBCLHVEQUFDO0FBQ3ZFLDJCQUEyQixrRUFBRSxVQUFVLHNFQUFFLENBQUMsbUVBQUUsQ0FBQyxpRUFBQyx5QkFBeUIsdURBQUM7QUFDeEUsdUJBQXVCLGtFQUFFLFVBQVUsa0VBQUMsQ0FBQyxtRUFBRSxDQUFDLGlFQUFDLHlCQUF5Qix1REFBQztBQUNuRSx1QkFBdUIsa0VBQUUsVUFBVSxrRUFBRSxDQUFDLG1FQUFFLENBQUMsaUVBQUM7QUFDMUMsR0FBRztBQUNILENBQUMsZ0RBQWdEO0FBQ2pELEtBQUssd0VBQUM7QUFDTixLQUFLLG1FQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsbUpBQW1KLG1FQUFDO0FBQ3JKO0FBQ0EsQ0FBQzs7QUFFc0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWtpdGEvRGVza3RvcC9mb2N1c3BoZXJlL25vZGVfbW9kdWxlcy90ZW1wb3JhbC1wb2x5ZmlsbC9jaHVua3MvY2xhc3NBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY3JlYXRlU2xvdENsYXNzKGksIGwsIHMsIGMsIHUpIHtcbiAgZnVuY3Rpb24gQ2xhc3MoLi4udCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYSk7XG4gICAgfVxuICAgIHVuKHRoaXMsIGwoLi4udCkpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRNZXRob2QodCwgZSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcygoZnVuY3Rpb24oLi4uZSkge1xuICAgICAgcmV0dXJuIHQuY2FsbCh0aGlzLCBnZXRTcGVjaWZpY1Nsb3RzKHRoaXMpLCAuLi5lKTtcbiAgICB9KSwgcihlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3BlY2lmaWNTbG90cyh0KSB7XG4gICAgY29uc3QgZSA9IGNuKHQpO1xuICAgIGlmICghZSB8fCBlLmJyYW5kaW5nICE9PSBpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGEpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgLi4udChlKGJpbmRNZXRob2QsIHMpKSxcbiAgICAuLi5uKGUoYmluZE1ldGhvZCwgYykpLFxuICAgIC4uLm8oXCJUZW1wb3JhbC5cIiArIGkpXG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDbGFzcywge1xuICAgIC4uLm4odSksXG4gICAgLi4ucihpKVxuICB9KSwgWyBDbGFzcywgdCA9PiB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlKTtcbiAgICByZXR1cm4gdW4oZSwgdCksIGU7XG4gIH0sIGdldFNwZWNpZmljU2xvdHMgXTtcbn1cblxuZnVuY3Rpb24gcmVqZWN0SW52YWxpZEJhZyh0KSB7XG4gIGlmIChjbih0KSB8fCB2b2lkIDAgIT09IHQuY2FsZW5kYXIgfHwgdm9pZCAwICE9PSB0LnRpbWVab25lKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihpKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJJZEZyb21CYWcodCkge1xuICByZXR1cm4gZXh0cmFjdENhbGVuZGFySWRGcm9tQmFnKHQpIHx8IGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RDYWxlbmRhcklkRnJvbUJhZyh0KSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogZX0gPSB0O1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgcmV0dXJuIHJlZmluZUNhbGVuZGFyQXJnKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNhbGVuZGFyQXJnKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCB7Y2FsZW5kYXI6IGV9ID0gY24odCkgfHwge307XG4gICAgaWYgKCFlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGModCkpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gKHQgPT4gdShmKG0odCkpKSkodCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyR2V0dGVycyh0KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIHQpIHtcbiAgICBlW25dID0gdCA9PiB7XG4gICAgICBjb25zdCB7Y2FsZW5kYXI6IGV9ID0gdDtcbiAgICAgIHJldHVybiBDKGUpW25dKHQpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIG5ldmVyVmFsdWVPZigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihiKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lVGltZVpvbmVBcmcodCkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IHt0aW1lWm9uZTogZX0gPSBjbih0KSB8fCB7fTtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRih0KSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiAodCA9PiBNKFoobSh0KSkpKSh0KTtcbn1cblxuZnVuY3Rpb24gdG9EdXJhdGlvblNsb3RzKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCBlID0gY24odCk7XG4gICAgcmV0dXJuIGUgJiYgZS5icmFuZGluZyA9PT0gTiA/IGUgOiBxKHQpO1xuICB9XG4gIHJldHVybiBSKHQpO1xufVxuXG5mdW5jdGlvbiByZWZpbmVQdWJsaWNSZWxhdGl2ZVRvKHQpIHtcbiAgaWYgKHZvaWQgMCAhPT0gdCkge1xuICAgIGlmIChzKHQpKSB7XG4gICAgICBjb25zdCBlID0gY24odCkgfHwge307XG4gICAgICBzd2l0Y2ggKGUuYnJhbmRpbmcpIHtcbiAgICAgICBjYXNlIHo6XG4gICAgICAgY2FzZSBHOlxuICAgICAgICByZXR1cm4gZTtcblxuICAgICAgIGNhc2UgeDpcbiAgICAgICAgcmV0dXJuIFcoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gZ2V0Q2FsZW5kYXJJZEZyb21CYWcodCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi4kKHJlZmluZVRpbWVab25lQXJnLCBMLCBDKG4pLCB0KSxcbiAgICAgICAgY2FsZW5kYXI6IG5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBIKHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvUGxhaW5UaW1lU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KSB8fCB7fTtcbiAgICBzd2l0Y2ggKG4uYnJhbmRpbmcpIHtcbiAgICAgY2FzZSBmdDpcbiAgICAgIHJldHVybiBtdChlKSwgbjtcblxuICAgICBjYXNlIHg6XG4gICAgICByZXR1cm4gbXQoZSksIFN0KG4pO1xuXG4gICAgIGNhc2UgejpcbiAgICAgIHJldHVybiBtdChlKSwgZHQoTCwgbik7XG4gICAgfVxuICAgIHJldHVybiBUdCh0LCBlKTtcbiAgfVxuICBjb25zdCBuID0gaHQodCk7XG4gIHJldHVybiBtdChlKSwgbjtcbn1cblxuZnVuY3Rpb24gb3B0aW9uYWxUb1BsYWluVGltZUZpZWxkcyh0KSB7XG4gIHJldHVybiB2b2lkIDAgPT09IHQgPyB2b2lkIDAgOiB0b1BsYWluVGltZVNsb3RzKHQpO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluRGF0ZVRpbWVTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpIHx8IHt9O1xuICAgIHN3aXRjaCAobi5icmFuZGluZykge1xuICAgICBjYXNlIHg6XG4gICAgICByZXR1cm4gbXQoZSksIG47XG5cbiAgICAgY2FzZSBHOlxuICAgICAgcmV0dXJuIG10KGUpLCBqdCh7XG4gICAgICAgIC4uLm4sXG4gICAgICAgIC4uLk50XG4gICAgICB9KTtcblxuICAgICBjYXNlIHo6XG4gICAgICByZXR1cm4gbXQoZSksIHl0KEwsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gQXQoQyhnZXRDYWxlbmRhcklkRnJvbUJhZyh0KSksIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSBCdCh0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluTW9udGhEYXlTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpO1xuICAgIGlmIChuICYmIG4uYnJhbmRpbmcgPT09IHF0KSB7XG4gICAgICByZXR1cm4gbXQoZSksIG47XG4gICAgfVxuICAgIGNvbnN0IG8gPSBleHRyYWN0Q2FsZW5kYXJJZEZyb21CYWcodCk7XG4gICAgcmV0dXJuIFJ0KEMobyB8fCBsKSwgIW8sIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSB4dChDLCB0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluWWVhck1vbnRoU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KTtcbiAgICByZXR1cm4gbiAmJiBuLmJyYW5kaW5nID09PSBVdCA/IChtdChlKSwgbikgOiBYdChDKGdldENhbGVuZGFySWRGcm9tQmFnKHQpKSwgdCwgZSk7XG4gIH1cbiAgY29uc3QgbiA9IF90KEMsIHQpO1xuICByZXR1cm4gbXQoZSksIG47XG59XG5cbmZ1bmN0aW9uIHRvUGxhaW5EYXRlU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KSB8fCB7fTtcbiAgICBzd2l0Y2ggKG4uYnJhbmRpbmcpIHtcbiAgICAgY2FzZSBHOlxuICAgICAgcmV0dXJuIG10KGUpLCBuO1xuXG4gICAgIGNhc2UgeDpcbiAgICAgIHJldHVybiBtdChlKSwgVyhuKTtcblxuICAgICBjYXNlIHo6XG4gICAgICByZXR1cm4gbXQoZSksIGZlKEwsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gbWUoQyhnZXRDYWxlbmRhcklkRnJvbUJhZyh0KSksIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSBkZSh0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWVTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpO1xuICAgIGlmIChuICYmIG4uYnJhbmRpbmcgPT09IHopIHtcbiAgICAgIHJldHVybiBqZShlKSwgbjtcbiAgICB9XG4gICAgY29uc3QgbyA9IGdldENhbGVuZGFySWRGcm9tQmFnKHQpO1xuICAgIHJldHVybiBOZShyZWZpbmVUaW1lWm9uZUFyZywgTCwgQyhvKSwgbywgdCwgZSk7XG4gIH1cbiAgcmV0dXJuIEFlKHQsIGUpO1xufVxuXG5mdW5jdGlvbiBhZGFwdERhdGVNZXRob2RzKHQpIHtcbiAgcmV0dXJuIGUoKHQgPT4gZSA9PiB0KHNsb3RzVG9Jc28oZSkpKSwgdCk7XG59XG5cbmZ1bmN0aW9uIHNsb3RzVG9Jc28odCkge1xuICByZXR1cm4gaGUodCwgTCk7XG59XG5cbmZ1bmN0aW9uIHRvSW5zdGFudFNsb3RzKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCBlID0gY24odCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIHN3aXRjaCAoZS5icmFuZGluZykge1xuICAgICAgIGNhc2UgUmU6XG4gICAgICAgIHJldHVybiBlO1xuXG4gICAgICAgY2FzZSB6OlxuICAgICAgICByZXR1cm4geGUoZS5lcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdlKHQpO1xufVxuXG5mdW5jdGlvbiB0b1RlbXBvcmFsSW5zdGFudCgpIHtcbiAgY29uc3QgdCA9IERhdGUucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh0aGlzKTtcbiAgcmV0dXJuIEtuKHhlKEdlKHplKHQpLCBRZSkpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZVRpbWVGb3JtYXRDbGFzcygpIHtcbiAgZnVuY3Rpb24gRGF0ZVRpbWVGb3JtYXRGdW5jKHQsIGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0TmV3KHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0TmV3KHQsIGUgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG4gICAgdG8uc2V0KHRoaXMsICgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgbiA9IG5ldyBlbih0LCBlKSwgbyA9IG4ucmVzb2x2ZWRPcHRpb25zKCksIHIgPSBvLmxvY2FsZSwgYSA9IG5uKE9iamVjdC5rZXlzKGUpLCBvKSwgaSA9IG9uKGNyZWF0ZUZvcm1hdFByZXBwZXJGb3JCcmFuZGluZyksIHByZXBGb3JtYXQgPSAodCwgLi4uZSkgPT4ge1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGlmICgyICE9PSBlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBlKSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSB0KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0IHx8IHZvaWQgMCAhPT0gZVswXSB8fCAoZSA9IFtdKTtcbiAgICAgICAgY29uc3QgbyA9IGUubWFwKCh0ID0+IGNuKHQpIHx8IE51bWJlcih0KSkpO1xuICAgICAgICBsZXQgbCwgcyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBvKSB7XG4gICAgICAgICAgY29uc3QgZSA9IFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgPyB0LmJyYW5kaW5nIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChzKysgJiYgZSAhPT0gbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGwgPSBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsID8gaShsKShyLCBhLCAuLi5vKSA6IFsgbiwgLi4ubyBdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwcmVwRm9ybWF0LlggPSBuLCBwcmVwRm9ybWF0O1xuICAgIH0pKHQsIGUpKTtcbiAgfVxuICBjb25zdCB0ID0gZW4ucHJvdG90eXBlLCBlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCksIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhlbik7XG4gIGZvciAoY29uc3QgdCBpbiBlKSB7XG4gICAgY29uc3QgbiA9IGVbdF0sIG8gPSB0LnN0YXJ0c1dpdGgoXCJmb3JtYXRcIikgJiYgY3JlYXRlRm9ybWF0TWV0aG9kKHQpO1xuICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygbi52YWx1ZSA/IG4udmFsdWUgPSBcImNvbnN0cnVjdG9yXCIgPT09IHQgPyBEYXRlVGltZUZvcm1hdEZ1bmMgOiBvIHx8IGNyZWF0ZVByb3hpZWRNZXRob2QodCkgOiBvICYmIChuLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0by5oYXModGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoLi4udCkgPT4gby5hcHBseSh0aGlzLCB0KTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLmdldCwgcihgZ2V0ICR7dH1gKSkpO1xuICB9XG4gIHJldHVybiBuLnByb3RvdHlwZS52YWx1ZSA9IERhdGVUaW1lRm9ybWF0TmV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoe30sIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhEYXRlVGltZUZvcm1hdEZ1bmMsIG4pLCBcbiAgRGF0ZVRpbWVGb3JtYXRGdW5jO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRNZXRob2QodCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKGZ1bmN0aW9uKC4uLmUpIHtcbiAgICBjb25zdCBuID0gdG8uZ2V0KHRoaXMpLCBbbywgLi4ucl0gPSBuKHQuaW5jbHVkZXMoXCJSYW5nZVwiKSwgLi4uZSk7XG4gICAgcmV0dXJuIG9bdF0oLi4ucik7XG4gIH0pLCByKHQpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveGllZE1ldGhvZCh0KSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcygoZnVuY3Rpb24oLi4uZSkge1xuICAgIHJldHVybiB0by5nZXQodGhpcykuWFt0XSguLi5lKTtcbiAgfSksIHIodCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRQcmVwcGVyRm9yQnJhbmRpbmcodCkge1xuICBjb25zdCBlID0gQ25bdF07XG4gIGlmICghZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iocm4odCkpO1xuICB9XG4gIHJldHVybiBRKGUsIG9uKGFuKSwgMSk7XG59XG5cbmltcG9ydCB7IGNyZWF0ZUdldHRlckRlc2NyaXB0b3JzIGFzIHQsIG1hcFByb3BzIGFzIGUsIGNyZWF0ZVByb3BEZXNjcmlwdG9ycyBhcyBuLCBjcmVhdGVTdHJpbmdUYWdEZXNjcmlwdG9ycyBhcyBvLCBjcmVhdGVOYW1lRGVzY3JpcHRvcnMgYXMgciwgaW52YWxpZENhbGxpbmdDb250ZXh0IGFzIGEsIGludmFsaWRCYWcgYXMgaSwgaXNvQ2FsZW5kYXJJZCBhcyBsLCBpc09iamVjdExpa2UgYXMgcywgaW52YWxpZENhbGVuZGFyIGFzIGMsIHJlc29sdmVDYWxlbmRhcklkIGFzIHUsIHBhcnNlQ2FsZW5kYXJJZCBhcyBmLCByZXF1aXJlU3RyaW5nIGFzIG0sIHJlcXVpcmVTdHJpbmdPclVuZGVmaW5lZCBhcyBkLCByZXF1aXJlSW50ZWdlck9yVW5kZWZpbmVkIGFzIFMsIHJlcXVpcmVJbnRlZ2VyIGFzIFQsIHJlcXVpcmVQb3NpdGl2ZUludGVnZXIgYXMgaCwgcmVxdWlyZUJvb2xlYW4gYXMgRCwgcmVxdWlyZVBvc2l0aXZlSW50ZWdlck9yVW5kZWZpbmVkIGFzIFAsIG1hcFByb3BOYW1lcyBhcyBnLCBkdXJhdGlvbkZpZWxkTmFtZXNBc2MgYXMgcCwgdGltZUZpZWxkTmFtZXNBc2MgYXMgTywgaXNvVGltZUZpZWxkTmFtZXNBc2MgYXMgdywgZ2V0RXBvY2hNaWxsaSBhcyBJLCBnZXRFcG9jaE5hbm8gYXMgdiwgY3JlYXRlTmF0aXZlU3RhbmRhcmRPcHMgYXMgQywgZm9yYmlkZGVuVmFsdWVPZiBhcyBiLCBpbnZhbGlkVGltZVpvbmUgYXMgRiwgcmVzb2x2ZVRpbWVab25lSWQgYXMgTSwgcGFyc2VUaW1lWm9uZUlkIGFzIFosIGdldER1cmF0aW9uQmxhbmsgYXMgeSwgY29uc3RydWN0RHVyYXRpb25TbG90cyBhcyBqLCBEdXJhdGlvbkJyYW5kaW5nIGFzIE4sIGR1cmF0aW9uV2l0aEZpZWxkcyBhcyBBLCBuZWdhdGVEdXJhdGlvbiBhcyBCLCBhYnNEdXJhdGlvbiBhcyBZLCBhZGREdXJhdGlvbnMgYXMgRSwgcXVlcnlOYXRpdmVUaW1lWm9uZSBhcyBMLCByb3VuZER1cmF0aW9uIGFzIFYsIHRvdGFsRHVyYXRpb24gYXMgSiwgZm9ybWF0RHVyYXRpb25Jc28gYXMgaywgcmVmaW5lRHVyYXRpb25CYWcgYXMgcSwgcGFyc2VEdXJhdGlvbiBhcyBSLCBQbGFpbkRhdGVUaW1lQnJhbmRpbmcgYXMgeCwgY3JlYXRlUGxhaW5EYXRlU2xvdHMgYXMgVywgUGxhaW5EYXRlQnJhbmRpbmcgYXMgRywgWm9uZWREYXRlVGltZUJyYW5kaW5nIGFzIHosIHJlZmluZU1heWJlWm9uZWREYXRlVGltZUJhZyBhcyAkLCBwYXJzZVJlbGF0aXZlVG9TbG90cyBhcyBILCBjb21wYXJlRHVyYXRpb25zIGFzIEssIGNyZWF0ZUZvcm1hdFByZXBwZXIgYXMgUSwgaW5zdGFudENvbmZpZyBhcyBVLCBkYXRlVGltZUNvbmZpZyBhcyBYLCBkYXRlQ29uZmlnIGFzIF8sIHRpbWVDb25maWcgYXMgdHQsIHllYXJNb250aENvbmZpZyBhcyBldCwgbW9udGhEYXlDb25maWcgYXMgbnQsIHpvbmVkQ29uZmlnIGFzIG90LCBwbGFpblRpbWVXaXRoRmllbGRzIGFzIHJ0LCBtb3ZlUGxhaW5UaW1lIGFzIGF0LCBkaWZmUGxhaW5UaW1lcyBhcyBpdCwgcm91bmRQbGFpblRpbWUgYXMgbHQsIHBsYWluVGltZXNFcXVhbCBhcyBzdCwgZm9ybWF0UGxhaW5UaW1lSXNvIGFzIGN0LCBjb25zdHJ1Y3RQbGFpblRpbWVTbG90cyBhcyB1dCwgUGxhaW5UaW1lQnJhbmRpbmcgYXMgZnQsIHJlZmluZU92ZXJmbG93T3B0aW9ucyBhcyBtdCwgem9uZWREYXRlVGltZVRvUGxhaW5UaW1lIGFzIGR0LCBjcmVhdGVQbGFpblRpbWVTbG90cyBhcyBTdCwgcmVmaW5lUGxhaW5UaW1lQmFnIGFzIFR0LCBwYXJzZVBsYWluVGltZSBhcyBodCwgY29tcGFyZUlzb1RpbWVGaWVsZHMgYXMgRHQsIGJpbmRBcmdzIGFzIFB0LCBwbGFpbkRhdGVUaW1lV2l0aEZpZWxkcyBhcyBndCwgc2xvdHNXaXRoQ2FsZW5kYXJJZCBhcyBwdCwgcGxhaW5EYXRlVGltZVdpdGhQbGFpblRpbWUgYXMgT3QsIG1vdmVQbGFpbkRhdGVUaW1lIGFzIHd0LCBkaWZmUGxhaW5EYXRlVGltZXMgYXMgSXQsIHJvdW5kUGxhaW5EYXRlVGltZSBhcyB2dCwgcGxhaW5EYXRlVGltZXNFcXVhbCBhcyBDdCwgcGxhaW5EYXRlVGltZVRvWm9uZWREYXRlVGltZSBhcyBidCwgZm9ybWF0UGxhaW5EYXRlVGltZUlzbyBhcyBGdCwgcmVmaW5lQ2FsZW5kYXJJZCBhcyBNdCwgY29uc3RydWN0UGxhaW5EYXRlVGltZVNsb3RzIGFzIFp0LCB6b25lZERhdGVUaW1lVG9QbGFpbkRhdGVUaW1lIGFzIHl0LCBjcmVhdGVQbGFpbkRhdGVUaW1lU2xvdHMgYXMganQsIGlzb1RpbWVGaWVsZERlZmF1bHRzIGFzIE50LCByZWZpbmVQbGFpbkRhdGVUaW1lQmFnIGFzIEF0LCBwYXJzZVBsYWluRGF0ZVRpbWUgYXMgQnQsIGNvbXBhcmVJc29EYXRlVGltZUZpZWxkcyBhcyBZdCwgcGxhaW5Nb250aERheVdpdGhGaWVsZHMgYXMgRXQsIHBsYWluTW9udGhEYXlzRXF1YWwgYXMgTHQsIHBsYWluTW9udGhEYXlUb1BsYWluRGF0ZSBhcyBWdCwgZm9ybWF0UGxhaW5Nb250aERheUlzbyBhcyBKdCwgY29uc3RydWN0UGxhaW5Nb250aERheVNsb3RzIGFzIGt0LCBQbGFpbk1vbnRoRGF5QnJhbmRpbmcgYXMgcXQsIHJlZmluZVBsYWluTW9udGhEYXlCYWcgYXMgUnQsIHBhcnNlUGxhaW5Nb250aERheSBhcyB4dCwgcGxhaW5ZZWFyTW9udGhXaXRoRmllbGRzIGFzIFd0LCBtb3ZlUGxhaW5ZZWFyTW9udGggYXMgR3QsIGRpZmZQbGFpblllYXJNb250aCBhcyB6dCwgcGxhaW5ZZWFyTW9udGhzRXF1YWwgYXMgJHQsIHBsYWluWWVhck1vbnRoVG9QbGFpbkRhdGUgYXMgSHQsIGZvcm1hdFBsYWluWWVhck1vbnRoSXNvIGFzIEt0LCBjb25zdHJ1Y3RQbGFpblllYXJNb250aFNsb3RzIGFzIFF0LCBQbGFpblllYXJNb250aEJyYW5kaW5nIGFzIFV0LCByZWZpbmVQbGFpblllYXJNb250aEJhZyBhcyBYdCwgcGFyc2VQbGFpblllYXJNb250aCBhcyBfdCwgY29tcGFyZUlzb0RhdGVGaWVsZHMgYXMgdGUsIHBsYWluRGF0ZVdpdGhGaWVsZHMgYXMgZWUsIG1vdmVQbGFpbkRhdGUgYXMgbmUsIGRpZmZQbGFpbkRhdGVzIGFzIG9lLCBwbGFpbkRhdGVzRXF1YWwgYXMgcmUsIHBsYWluRGF0ZVRvWm9uZWREYXRlVGltZSBhcyBhZSwgcGxhaW5EYXRlVG9QbGFpbkRhdGVUaW1lIGFzIGllLCBwbGFpbkRhdGVUb1BsYWluWWVhck1vbnRoIGFzIGxlLCBwbGFpbkRhdGVUb1BsYWluTW9udGhEYXkgYXMgc2UsIGZvcm1hdFBsYWluRGF0ZUlzbyBhcyBjZSwgY29uc3RydWN0UGxhaW5EYXRlU2xvdHMgYXMgdWUsIHpvbmVkRGF0ZVRpbWVUb1BsYWluRGF0ZSBhcyBmZSwgcmVmaW5lUGxhaW5EYXRlQmFnIGFzIG1lLCBwYXJzZVBsYWluRGF0ZSBhcyBkZSwgZm9ybWF0T2Zmc2V0TmFubyBhcyBTZSwgY29tcHV0ZVpvbmVkSG91cnNJbkRheSBhcyBUZSwgem9uZWRFcG9jaFNsb3RzVG9Jc28gYXMgaGUsIHpvbmVkRGF0ZVRpbWVXaXRoRmllbGRzIGFzIERlLCBzbG90c1dpdGhUaW1lWm9uZUlkIGFzIFBlLCB6b25lZERhdGVUaW1lV2l0aFBsYWluVGltZSBhcyBnZSwgbW92ZVpvbmVkRGF0ZVRpbWUgYXMgcGUsIGNyZWF0ZUR1cmF0aW9uU2xvdHMgYXMgT2UsIGRpZmZab25lZERhdGVUaW1lcyBhcyB3ZSwgcm91bmRab25lZERhdGVUaW1lIGFzIEllLCBjb21wdXRlWm9uZWRTdGFydE9mRGF5IGFzIHZlLCB6b25lZERhdGVUaW1lc0VxdWFsIGFzIENlLCB6b25lZERhdGVUaW1lVG9JbnN0YW50IGFzIGJlLCBmb3JtYXRab25lZERhdGVUaW1lSXNvIGFzIEZlLCByZWZpbmVEaXJlY3Rpb25PcHRpb25zIGFzIE1lLCByZWZpbmVUaW1lWm9uZUlkIGFzIFplLCBjb25zdHJ1Y3Rab25lZERhdGVUaW1lU2xvdHMgYXMgeWUsIHJlZmluZVpvbmVkRmllbGRPcHRpb25zIGFzIGplLCByZWZpbmVab25lZERhdGVUaW1lQmFnIGFzIE5lLCBwYXJzZVpvbmVkRGF0ZVRpbWUgYXMgQWUsIGNvbXBhcmVab25lZERhdGVUaW1lcyBhcyBCZSwgbW92ZUluc3RhbnQgYXMgWWUsIGRpZmZJbnN0YW50cyBhcyBFZSwgcm91bmRJbnN0YW50IGFzIExlLCBpbnN0YW50c0VxdWFsIGFzIFZlLCBpbnN0YW50VG9ab25lZERhdGVUaW1lIGFzIEplLCBmb3JtYXRJbnN0YW50SXNvIGFzIGtlLCBjb25zdHJ1Y3RJbnN0YW50U2xvdHMgYXMgcWUsIEluc3RhbnRCcmFuZGluZyBhcyBSZSwgY3JlYXRlSW5zdGFudFNsb3RzIGFzIHhlLCBwYXJzZUluc3RhbnQgYXMgV2UsIG51bWJlclRvQmlnTmFubyBhcyBHZSwgcmVxdWlyZU51bWJlcklzSW50ZWdlciBhcyB6ZSwgZXBvY2hNaWxsaVRvSW5zdGFudCBhcyAkZSwgZXBvY2hOYW5vVG9JbnN0YW50IGFzIEhlLCBjb21wYXJlSW5zdGFudHMgYXMgS2UsIG5hbm9Jbk1pbGxpIGFzIFFlLCBnZXRDdXJyZW50VGltZVpvbmVJZCBhcyBVZSwgZ2V0Q3VycmVudEVwb2NoTmFubyBhcyBYZSwgY3JlYXRlWm9uZWREYXRlVGltZVNsb3RzIGFzIF9lLCBnZXRDdXJyZW50SXNvRGF0ZVRpbWUgYXMgdG4sIFJhd0RhdGVUaW1lRm9ybWF0IGFzIGVuLCBwbHVja1Byb3BzIGFzIG5uLCBtZW1vaXplIGFzIG9uLCBpbnZhbGlkRm9ybWF0VHlwZSBhcyBybiwgY3JlYXRlRm9ybWF0Rm9yUHJlcCBhcyBhbiwgbWlzbWF0Y2hpbmdGb3JtYXRUeXBlcyBhcyBsbiB9IGZyb20gXCIuL2ludGVybmFsLmpzXCI7XG5cbmNvbnN0IHNuID0gLypAX19QVVJFX18qLyBuZXcgV2Vha01hcCwgY24gPSAvKkBfX1BVUkVfXyovIHNuLmdldC5iaW5kKHNuKSwgdW4gPSAvKkBfX1BVUkVfXyovIHNuLnNldC5iaW5kKHNuKSwgZm4gPSB7XG4gIGVyYTogZCxcbiAgZXJhWWVhcjogUyxcbiAgeWVhcjogVCxcbiAgbW9udGg6IGgsXG4gIGRheXNJbk1vbnRoOiBoLFxuICBkYXlzSW5ZZWFyOiBoLFxuICBpbkxlYXBZZWFyOiBELFxuICBtb250aHNJblllYXI6IGhcbn0sIG1uID0ge1xuICBtb250aENvZGU6IG1cbn0sIGRuID0ge1xuICBkYXk6IGhcbn0sIFNuID0ge1xuICBkYXlPZldlZWs6IGgsXG4gIGRheU9mWWVhcjogaCxcbiAgd2Vla09mWWVhcjogUCxcbiAgeWVhck9mV2VlazogUyxcbiAgZGF5c0luV2VlazogaFxufSwgVG4gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNhbGVuZGFyR2V0dGVycygvKkBfX1BVUkVfXyovIE9iamVjdC5hc3NpZ24oe30sIGZuLCBtbiwgZG4sIFNuKSksIGhuID0gLypAX19QVVJFX18qLyBjcmVhdGVDYWxlbmRhckdldHRlcnMoe1xuICAuLi5mbixcbiAgLi4ubW5cbn0pLCBEbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ2FsZW5kYXJHZXR0ZXJzKHtcbiAgLi4ubW4sXG4gIC4uLmRuXG59KSwgUG4gPSB7XG4gIGNhbGVuZGFySWQ6IHQgPT4gdC5jYWxlbmRhclxufSwgZ24gPSAvKkBfX1BVUkVfXyovIGcoKHQgPT4gZSA9PiBlW3RdKSwgcC5jb25jYXQoXCJzaWduXCIpKSwgcG4gPSAvKkBfX1BVUkVfXyovIGcoKCh0LCBlKSA9PiB0ID0+IHRbd1tlXV0pLCBPKSwgT24gPSB7XG4gIGVwb2NoTWlsbGlzZWNvbmRzOiBJLFxuICBlcG9jaE5hbm9zZWNvbmRzOiB2XG59LCBbd24sIEluLCB2bl0gPSBjcmVhdGVTbG90Q2xhc3MoTiwgaiwge1xuICAuLi5nbixcbiAgYmxhbms6IHlcbn0sIHtcbiAgd2l0aDogKHQsIGUpID0+IEluKEEodCwgZSkpLFxuICBuZWdhdGVkOiB0ID0+IEluKEIodCkpLFxuICBhYnM6IHQgPT4gSW4oWSh0KSksXG4gIGFkZDogKHQsIGUsIG4pID0+IEluKEUocmVmaW5lUHVibGljUmVsYXRpdmVUbywgQywgTCwgMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHN1YnRyYWN0OiAodCwgZSwgbikgPT4gSW4oRShyZWZpbmVQdWJsaWNSZWxhdGl2ZVRvLCBDLCBMLCAxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgcm91bmQ6ICh0LCBlKSA9PiBJbihWKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHQsIGUpKSxcbiAgdG90YWw6ICh0LCBlKSA9PiBKKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHQsIGUpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgcmV0dXJuIEludGwuRHVyYXRpb25Gb3JtYXQgPyBuZXcgSW50bC5EdXJhdGlvbkZvcm1hdChlLCBuKS5mb3JtYXQodGhpcykgOiBrKHQpO1xuICB9LFxuICB0b1N0cmluZzogayxcbiAgdG9KU09OOiB0ID0+IGsodCksXG4gIHZhbHVlT2Y6IG5ldmVyVmFsdWVPZlxufSwge1xuICBmcm9tOiB0ID0+IEluKHRvRHVyYXRpb25TbG90cyh0KSksXG4gIGNvbXBhcmU6ICh0LCBlLCBuKSA9PiBLKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHRvRHVyYXRpb25TbG90cyh0KSwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKVxufSksIENuID0ge1xuICBJbnN0YW50OiBVLFxuICBQbGFpbkRhdGVUaW1lOiBYLFxuICBQbGFpbkRhdGU6IF8sXG4gIFBsYWluVGltZTogdHQsXG4gIFBsYWluWWVhck1vbnRoOiBldCxcbiAgUGxhaW5Nb250aERheTogbnRcbn0sIGJuID0gLypAX19QVVJFX18qLyBRKFUpLCBGbiA9IC8qQF9fUFVSRV9fKi8gUShvdCksIE1uID0gLypAX19QVVJFX18qLyBRKFgpLCBabiA9IC8qQF9fUFVSRV9fKi8gUShfKSwgeW4gPSAvKkBfX1BVUkVfXyovIFEodHQpLCBqbiA9IC8qQF9fUFVSRV9fKi8gUShldCksIE5uID0gLypAX19QVVJFX18qLyBRKG50KSwgW0FuLCBCbl0gPSBjcmVhdGVTbG90Q2xhc3MoZnQsIHV0LCBwbiwge1xuICB3aXRoKHQsIGUsIG4pIHtcbiAgICByZXR1cm4gQm4ocnQodGhpcywgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpO1xuICB9LFxuICBhZGQ6ICh0LCBlKSA9PiBCbihhdCgwLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSkpKSxcbiAgc3VidHJhY3Q6ICh0LCBlKSA9PiBCbihhdCgxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSkpKSxcbiAgdW50aWw6ICh0LCBlLCBuKSA9PiBJbihpdCgwLCB0LCB0b1BsYWluVGltZVNsb3RzKGUpLCBuKSksXG4gIHNpbmNlOiAodCwgZSwgbikgPT4gSW4oaXQoMSwgdCwgdG9QbGFpblRpbWVTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEJuKGx0KHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gc3QodCwgdG9QbGFpblRpbWVTbG90cyhlKSksXG4gIHRvTG9jYWxlU3RyaW5nKHQsIGUsIG4pIHtcbiAgICBjb25zdCBbbywgcl0gPSB5bihlLCBuLCB0KTtcbiAgICByZXR1cm4gby5mb3JtYXQocik7XG4gIH0sXG4gIHRvU3RyaW5nOiBjdCxcbiAgdG9KU09OOiB0ID0+IGN0KHQpLFxuICB2YWx1ZU9mOiBuZXZlclZhbHVlT2Zcbn0sIHtcbiAgZnJvbTogKHQsIGUpID0+IEJuKHRvUGxhaW5UaW1lU2xvdHModCwgZSkpLFxuICBjb21wYXJlOiAodCwgZSkgPT4gRHQodG9QbGFpblRpbWVTbG90cyh0KSwgdG9QbGFpblRpbWVTbG90cyhlKSlcbn0pLCBbWW4sIEVuXSA9IGNyZWF0ZVNsb3RDbGFzcyh4LCBQdChadCwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5UbixcbiAgLi4ucG5cbn0sIHtcbiAgd2l0aDogKHQsIGUsIG4pID0+IEVuKGd0KEMsIHQsIHJlamVjdEludmFsaWRCYWcoZSksIG4pKSxcbiAgd2l0aENhbGVuZGFyOiAodCwgZSkgPT4gRW4ocHQodCwgcmVmaW5lQ2FsZW5kYXJBcmcoZSkpKSxcbiAgd2l0aFBsYWluVGltZTogKHQsIGUpID0+IEVuKE90KHQsIG9wdGlvbmFsVG9QbGFpblRpbWVGaWVsZHMoZSkpKSxcbiAgYWRkOiAodCwgZSwgbikgPT4gRW4od3QoQywgMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHN1YnRyYWN0OiAodCwgZSwgbikgPT4gRW4od3QoQywgMSwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHVudGlsOiAodCwgZSwgbikgPT4gSW4oSXQoQywgMCwgdCwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSksIG4pKSxcbiAgc2luY2U6ICh0LCBlLCBuKSA9PiBJbihJdChDLCAxLCB0LCB0b1BsYWluRGF0ZVRpbWVTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEVuKHZ0KHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gQ3QodCwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSkpLFxuICB0b1pvbmVkRGF0ZVRpbWU6ICh0LCBlLCBuKSA9PiAkbihidChMLCB0LCByZWZpbmVUaW1lWm9uZUFyZyhlKSwgbikpLFxuICB0b1BsYWluRGF0ZTogdCA9PiBXbihXKHQpKSxcbiAgdG9QbGFpblRpbWU6IHQgPT4gQm4oU3QodCkpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gTW4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogRnQsXG4gIHRvSlNPTjogdCA9PiBGdCh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBFbih0b1BsYWluRGF0ZVRpbWVTbG90cyh0LCBlKSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBZdCh0b1BsYWluRGF0ZVRpbWVTbG90cyh0KSwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSkpXG59KSwgW0xuLCBWbiwgSm5dID0gY3JlYXRlU2xvdENsYXNzKHF0LCBQdChrdCwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5EblxufSwge1xuICB3aXRoOiAodCwgZSwgbikgPT4gVm4oRXQoQywgdCwgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiBMdCh0LCB0b1BsYWluTW9udGhEYXlTbG90cyhlKSksXG4gIHRvUGxhaW5EYXRlKHQsIGUpIHtcbiAgICByZXR1cm4gV24oVnQoQywgdCwgdGhpcywgZSkpO1xuICB9LFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gTm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogSnQsXG4gIHRvSlNPTjogdCA9PiBKdCh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBWbih0b1BsYWluTW9udGhEYXlTbG90cyh0LCBlKSlcbn0pLCBba24sIHFuLCBSbl0gPSBjcmVhdGVTbG90Q2xhc3MoVXQsIFB0KFF0LCBNdCksIHtcbiAgLi4uUG4sXG4gIC4uLmhuXG59LCB7XG4gIHdpdGg6ICh0LCBlLCBuKSA9PiBxbihXdChDLCB0LCByZWplY3RJbnZhbGlkQmFnKGUpLCBuKSksXG4gIGFkZDogKHQsIGUsIG4pID0+IHFuKEd0KEMsIDAsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICBzdWJ0cmFjdDogKHQsIGUsIG4pID0+IHFuKEd0KEMsIDEsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICB1bnRpbDogKHQsIGUsIG4pID0+IEluKHp0KEMsIDAsIHQsIHRvUGxhaW5ZZWFyTW9udGhTbG90cyhlKSwgbikpLFxuICBzaW5jZTogKHQsIGUsIG4pID0+IEluKHp0KEMsIDEsIHQsIHRvUGxhaW5ZZWFyTW9udGhTbG90cyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiAkdCh0LCB0b1BsYWluWWVhck1vbnRoU2xvdHMoZSkpLFxuICB0b1BsYWluRGF0ZSh0LCBlKSB7XG4gICAgcmV0dXJuIFduKEh0KEMsIHQsIHRoaXMsIGUpKTtcbiAgfSxcbiAgdG9Mb2NhbGVTdHJpbmcodCwgZSwgbikge1xuICAgIGNvbnN0IFtvLCByXSA9IGpuKGUsIG4sIHQpO1xuICAgIHJldHVybiBvLmZvcm1hdChyKTtcbiAgfSxcbiAgdG9TdHJpbmc6IEt0LFxuICB0b0pTT046IHQgPT4gS3QodCksXG4gIHZhbHVlT2Y6IG5ldmVyVmFsdWVPZlxufSwge1xuICBmcm9tOiAodCwgZSkgPT4gcW4odG9QbGFpblllYXJNb250aFNsb3RzKHQsIGUpKSxcbiAgY29tcGFyZTogKHQsIGUpID0+IHRlKHRvUGxhaW5ZZWFyTW9udGhTbG90cyh0KSwgdG9QbGFpblllYXJNb250aFNsb3RzKGUpKVxufSksIFt4biwgV24sIEduXSA9IGNyZWF0ZVNsb3RDbGFzcyhHLCBQdCh1ZSwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5UblxufSwge1xuICB3aXRoOiAodCwgZSwgbikgPT4gV24oZWUoQywgdCwgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpLFxuICB3aXRoQ2FsZW5kYXI6ICh0LCBlKSA9PiBXbihwdCh0LCByZWZpbmVDYWxlbmRhckFyZyhlKSkpLFxuICBhZGQ6ICh0LCBlLCBuKSA9PiBXbihuZShDLCAwLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgc3VidHJhY3Q6ICh0LCBlLCBuKSA9PiBXbihuZShDLCAxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgdW50aWw6ICh0LCBlLCBuKSA9PiBJbihvZShDLCAwLCB0LCB0b1BsYWluRGF0ZVNsb3RzKGUpLCBuKSksXG4gIHNpbmNlOiAodCwgZSwgbikgPT4gSW4ob2UoQywgMSwgdCwgdG9QbGFpbkRhdGVTbG90cyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiByZSh0LCB0b1BsYWluRGF0ZVNsb3RzKGUpKSxcbiAgdG9ab25lZERhdGVUaW1lKHQsIGUpIHtcbiAgICBjb25zdCBuID0gcyhlKSA/IGUgOiB7XG4gICAgICB0aW1lWm9uZTogZVxuICAgIH07XG4gICAgcmV0dXJuICRuKGFlKHJlZmluZVRpbWVab25lQXJnLCB0b1BsYWluVGltZVNsb3RzLCBMLCB0LCBuKSk7XG4gIH0sXG4gIHRvUGxhaW5EYXRlVGltZTogKHQsIGUpID0+IEVuKGllKHQsIG9wdGlvbmFsVG9QbGFpblRpbWVGaWVsZHMoZSkpKSxcbiAgdG9QbGFpblllYXJNb250aCh0KSB7XG4gICAgcmV0dXJuIHFuKGxlKEMsIHQsIHRoaXMpKTtcbiAgfSxcbiAgdG9QbGFpbk1vbnRoRGF5KHQpIHtcbiAgICByZXR1cm4gVm4oc2UoQywgdCwgdGhpcykpO1xuICB9LFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gWm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogY2UsXG4gIHRvSlNPTjogdCA9PiBjZSh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBXbih0b1BsYWluRGF0ZVNsb3RzKHQsIGUpKSxcbiAgY29tcGFyZTogKHQsIGUpID0+IHRlKHRvUGxhaW5EYXRlU2xvdHModCksIHRvUGxhaW5EYXRlU2xvdHMoZSkpXG59KSwgW3puLCAkbl0gPSBjcmVhdGVTbG90Q2xhc3MoeiwgUHQoeWUsIE10LCBaZSksIHtcbiAgLi4uT24sXG4gIC4uLlBuLFxuICAuLi5hZGFwdERhdGVNZXRob2RzKFRuKSxcbiAgLi4uYWRhcHREYXRlTWV0aG9kcyhwbiksXG4gIG9mZnNldDogdCA9PiBTZShzbG90c1RvSXNvKHQpLm9mZnNldE5hbm9zZWNvbmRzKSxcbiAgb2Zmc2V0TmFub3NlY29uZHM6IHQgPT4gc2xvdHNUb0lzbyh0KS5vZmZzZXROYW5vc2Vjb25kcyxcbiAgdGltZVpvbmVJZDogdCA9PiB0LnRpbWVab25lLFxuICBob3Vyc0luRGF5OiB0ID0+IFRlKEwsIHQpXG59LCB7XG4gIHdpdGg6ICh0LCBlLCBuKSA9PiAkbihEZShDLCBMLCB0LCByZWplY3RJbnZhbGlkQmFnKGUpLCBuKSksXG4gIHdpdGhDYWxlbmRhcjogKHQsIGUpID0+ICRuKHB0KHQsIHJlZmluZUNhbGVuZGFyQXJnKGUpKSksXG4gIHdpdGhUaW1lWm9uZTogKHQsIGUpID0+ICRuKFBlKHQsIHJlZmluZVRpbWVab25lQXJnKGUpKSksXG4gIHdpdGhQbGFpblRpbWU6ICh0LCBlKSA9PiAkbihnZShMLCB0LCBvcHRpb25hbFRvUGxhaW5UaW1lRmllbGRzKGUpKSksXG4gIGFkZDogKHQsIGUsIG4pID0+ICRuKHBlKEMsIEwsIDAsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICBzdWJ0cmFjdDogKHQsIGUsIG4pID0+ICRuKHBlKEMsIEwsIDEsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICB1bnRpbDogKHQsIGUsIG4pID0+IEluKE9lKHdlKEMsIEwsIDAsIHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpLCBuKSkpLFxuICBzaW5jZTogKHQsIGUsIG4pID0+IEluKE9lKHdlKEMsIEwsIDEsIHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpLCBuKSkpLFxuICByb3VuZDogKHQsIGUpID0+ICRuKEllKEwsIHQsIGUpKSxcbiAgc3RhcnRPZkRheTogdCA9PiAkbih2ZShMLCB0KSksXG4gIGVxdWFsczogKHQsIGUpID0+IENlKHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpKSxcbiAgdG9JbnN0YW50OiB0ID0+IEtuKGJlKHQpKSxcbiAgdG9QbGFpbkRhdGVUaW1lOiB0ID0+IEVuKHl0KEwsIHQpKSxcbiAgdG9QbGFpbkRhdGU6IHQgPT4gV24oZmUoTCwgdCkpLFxuICB0b1BsYWluVGltZTogdCA9PiBCbihkdChMLCB0KSksXG4gIHRvTG9jYWxlU3RyaW5nKHQsIGUsIG4gPSB7fSkge1xuICAgIGNvbnN0IFtvLCByXSA9IEZuKGUsIG4sIHQpO1xuICAgIHJldHVybiBvLmZvcm1hdChyKTtcbiAgfSxcbiAgdG9TdHJpbmc6ICh0LCBlKSA9PiBGZShMLCB0LCBlKSxcbiAgdG9KU09OOiB0ID0+IEZlKEwsIHQpLFxuICB2YWx1ZU9mOiBuZXZlclZhbHVlT2YsXG4gIGdldFRpbWVab25lVHJhbnNpdGlvbih0LCBlKSB7XG4gICAgY29uc3Qge3RpbWVab25lOiBuLCBlcG9jaE5hbm9zZWNvbmRzOiBvfSA9IHQsIHIgPSBNZShlKSwgYSA9IEwobikuTyhvLCByKTtcbiAgICByZXR1cm4gYSA/ICRuKHtcbiAgICAgIC4uLnQsXG4gICAgICBlcG9jaE5hbm9zZWNvbmRzOiBhXG4gICAgfSkgOiBudWxsO1xuICB9XG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiAkbih0b1pvbmVkRGF0ZVRpbWVTbG90cyh0LCBlKSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBCZSh0b1pvbmVkRGF0ZVRpbWVTbG90cyh0KSwgdG9ab25lZERhdGVUaW1lU2xvdHMoZSkpXG59KSwgW0huLCBLbiwgUW5dID0gY3JlYXRlU2xvdENsYXNzKFJlLCBxZSwgT24sIHtcbiAgYWRkOiAodCwgZSkgPT4gS24oWWUoMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpKSksXG4gIHN1YnRyYWN0OiAodCwgZSkgPT4gS24oWWUoMSwgdCwgdG9EdXJhdGlvblNsb3RzKGUpKSksXG4gIHVudGlsOiAodCwgZSwgbikgPT4gSW4oRWUoMCwgdCwgdG9JbnN0YW50U2xvdHMoZSksIG4pKSxcbiAgc2luY2U6ICh0LCBlLCBuKSA9PiBJbihFZSgxLCB0LCB0b0luc3RhbnRTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEtuKExlKHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gVmUodCwgdG9JbnN0YW50U2xvdHMoZSkpLFxuICB0b1pvbmVkRGF0ZVRpbWVJU086ICh0LCBlKSA9PiAkbihKZSh0LCByZWZpbmVUaW1lWm9uZUFyZyhlKSkpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gYm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogKHQsIGUpID0+IGtlKHJlZmluZVRpbWVab25lQXJnLCBMLCB0LCBlKSxcbiAgdG9KU09OOiB0ID0+IGtlKHJlZmluZVRpbWVab25lQXJnLCBMLCB0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206IHQgPT4gS24odG9JbnN0YW50U2xvdHModCkpLFxuICBmcm9tRXBvY2hNaWxsaXNlY29uZHM6IHQgPT4gS24oJGUodCkpLFxuICBmcm9tRXBvY2hOYW5vc2Vjb25kczogdCA9PiBLbihIZSh0KSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBLZSh0b0luc3RhbnRTbG90cyh0KSwgdG9JbnN0YW50U2xvdHMoZSkpXG59KSwgVW4gPSAvKkBfX1BVUkVfXyovIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gIC4uLm8oXCJUZW1wb3JhbC5Ob3dcIiksXG4gIC4uLm4oe1xuICAgIHRpbWVab25lSWQ6ICgpID0+IFVlKCksXG4gICAgaW5zdGFudDogKCkgPT4gS24oeGUoWGUoKSkpLFxuICAgIHpvbmVkRGF0ZVRpbWVJU086ICh0ID0gVWUoKSkgPT4gJG4oX2UoWGUoKSwgcmVmaW5lVGltZVpvbmVBcmcodCksIGwpKSxcbiAgICBwbGFpbkRhdGVUaW1lSVNPOiAodCA9IFVlKCkpID0+IEVuKGp0KHRuKEwocmVmaW5lVGltZVpvbmVBcmcodCkpKSwgbCkpLFxuICAgIHBsYWluRGF0ZUlTTzogKHQgPSBVZSgpKSA9PiBXbihXKHRuKEwocmVmaW5lVGltZVpvbmVBcmcodCkpKSwgbCkpLFxuICAgIHBsYWluVGltZUlTTzogKHQgPSBVZSgpKSA9PiBCbihTdCh0bihMKHJlZmluZVRpbWVab25lQXJnKHQpKSkpKVxuICB9KVxufSksIFhuID0gLypAX19QVVJFX18qLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAuLi5vKFwiVGVtcG9yYWxcIiksXG4gIC4uLm4oe1xuICAgIFBsYWluWWVhck1vbnRoOiBrbixcbiAgICBQbGFpbk1vbnRoRGF5OiBMbixcbiAgICBQbGFpbkRhdGU6IHhuLFxuICAgIFBsYWluVGltZTogQW4sXG4gICAgUGxhaW5EYXRlVGltZTogWW4sXG4gICAgWm9uZWREYXRlVGltZTogem4sXG4gICAgSW5zdGFudDogSG4sXG4gICAgRHVyYXRpb246IHduLFxuICAgIE5vdzogVW5cbiAgfSlcbn0pLCBfbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlRGF0ZVRpbWVGb3JtYXRDbGFzcygpLCB0byA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAsIGVvID0gLypAX19QVVJFX18qLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPYmplY3QuY3JlYXRlKEludGwpLCBuKHtcbiAgRGF0ZVRpbWVGb3JtYXQ6IF9uXG59KSk7XG5cbmV4cG9ydCB7IF9uIGFzIERhdGVUaW1lRm9ybWF0LCBlbyBhcyBJbnRsRXh0ZW5kZWQsIFhuIGFzIFRlbXBvcmFsLCB0b1RlbXBvcmFsSW5zdGFudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/temporal-polyfill/chunks/classApi.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/temporal-polyfill/chunks/internal.js":
/*!***********************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/internal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DurationBranding: () => (/* binding */ N),\n/* harmony export */   InstantBranding: () => (/* binding */ Re),\n/* harmony export */   PlainDateBranding: () => (/* binding */ G),\n/* harmony export */   PlainDateTimeBranding: () => (/* binding */ x),\n/* harmony export */   PlainMonthDayBranding: () => (/* binding */ qt),\n/* harmony export */   PlainTimeBranding: () => (/* binding */ ft),\n/* harmony export */   PlainYearMonthBranding: () => (/* binding */ Ut),\n/* harmony export */   RawDateTimeFormat: () => (/* binding */ en),\n/* harmony export */   ZonedDateTimeBranding: () => (/* binding */ z),\n/* harmony export */   absDuration: () => (/* binding */ Y),\n/* harmony export */   addDurations: () => (/* binding */ E),\n/* harmony export */   bindArgs: () => (/* binding */ Pt),\n/* harmony export */   compareDurations: () => (/* binding */ K),\n/* harmony export */   compareInstants: () => (/* binding */ Ke),\n/* harmony export */   compareIsoDateFields: () => (/* binding */ te),\n/* harmony export */   compareIsoDateTimeFields: () => (/* binding */ Yt),\n/* harmony export */   compareIsoTimeFields: () => (/* binding */ Dt),\n/* harmony export */   compareZonedDateTimes: () => (/* binding */ Be),\n/* harmony export */   computeZonedHoursInDay: () => (/* binding */ Te),\n/* harmony export */   computeZonedStartOfDay: () => (/* binding */ ve),\n/* harmony export */   constructDurationSlots: () => (/* binding */ j),\n/* harmony export */   constructInstantSlots: () => (/* binding */ qe),\n/* harmony export */   constructPlainDateSlots: () => (/* binding */ ue),\n/* harmony export */   constructPlainDateTimeSlots: () => (/* binding */ Zt),\n/* harmony export */   constructPlainMonthDaySlots: () => (/* binding */ kt),\n/* harmony export */   constructPlainTimeSlots: () => (/* binding */ ut),\n/* harmony export */   constructPlainYearMonthSlots: () => (/* binding */ Qt),\n/* harmony export */   constructZonedDateTimeSlots: () => (/* binding */ ye),\n/* harmony export */   createDurationSlots: () => (/* binding */ Oe),\n/* harmony export */   createFormatForPrep: () => (/* binding */ an),\n/* harmony export */   createFormatPrepper: () => (/* binding */ Q),\n/* harmony export */   createGetterDescriptors: () => (/* binding */ t),\n/* harmony export */   createInstantSlots: () => (/* binding */ xe),\n/* harmony export */   createNameDescriptors: () => (/* binding */ r),\n/* harmony export */   createNativeStandardOps: () => (/* binding */ C),\n/* harmony export */   createPlainDateSlots: () => (/* binding */ W),\n/* harmony export */   createPlainDateTimeSlots: () => (/* binding */ jt),\n/* harmony export */   createPlainTimeSlots: () => (/* binding */ St),\n/* harmony export */   createPropDescriptors: () => (/* binding */ n),\n/* harmony export */   createStringTagDescriptors: () => (/* binding */ o),\n/* harmony export */   createZonedDateTimeSlots: () => (/* binding */ _e),\n/* harmony export */   dateConfig: () => (/* binding */ _),\n/* harmony export */   dateTimeConfig: () => (/* binding */ X),\n/* harmony export */   diffInstants: () => (/* binding */ Ee),\n/* harmony export */   diffPlainDateTimes: () => (/* binding */ It),\n/* harmony export */   diffPlainDates: () => (/* binding */ oe),\n/* harmony export */   diffPlainTimes: () => (/* binding */ it),\n/* harmony export */   diffPlainYearMonth: () => (/* binding */ zt),\n/* harmony export */   diffZonedDateTimes: () => (/* binding */ we),\n/* harmony export */   durationFieldNamesAsc: () => (/* binding */ p),\n/* harmony export */   durationWithFields: () => (/* binding */ A),\n/* harmony export */   epochMilliToInstant: () => (/* binding */ $e),\n/* harmony export */   epochNanoToInstant: () => (/* binding */ He),\n/* harmony export */   forbiddenValueOf: () => (/* binding */ b),\n/* harmony export */   formatDurationIso: () => (/* binding */ k),\n/* harmony export */   formatInstantIso: () => (/* binding */ ke),\n/* harmony export */   formatOffsetNano: () => (/* binding */ Se),\n/* harmony export */   formatPlainDateIso: () => (/* binding */ ce),\n/* harmony export */   formatPlainDateTimeIso: () => (/* binding */ Ft),\n/* harmony export */   formatPlainMonthDayIso: () => (/* binding */ Jt),\n/* harmony export */   formatPlainTimeIso: () => (/* binding */ ct),\n/* harmony export */   formatPlainYearMonthIso: () => (/* binding */ Kt),\n/* harmony export */   formatZonedDateTimeIso: () => (/* binding */ Fe),\n/* harmony export */   getCurrentEpochNano: () => (/* binding */ Xe),\n/* harmony export */   getCurrentIsoDateTime: () => (/* binding */ tn),\n/* harmony export */   getCurrentTimeZoneId: () => (/* binding */ Ue),\n/* harmony export */   getDurationBlank: () => (/* binding */ y),\n/* harmony export */   getEpochMilli: () => (/* binding */ I),\n/* harmony export */   getEpochNano: () => (/* binding */ v),\n/* harmony export */   instantConfig: () => (/* binding */ U),\n/* harmony export */   instantToZonedDateTime: () => (/* binding */ Je),\n/* harmony export */   instantsEqual: () => (/* binding */ Ve),\n/* harmony export */   invalidBag: () => (/* binding */ i),\n/* harmony export */   invalidCalendar: () => (/* binding */ c),\n/* harmony export */   invalidCallingContext: () => (/* binding */ a),\n/* harmony export */   invalidFormatType: () => (/* binding */ rn),\n/* harmony export */   invalidTimeZone: () => (/* binding */ F),\n/* harmony export */   isObjectLike: () => (/* binding */ s),\n/* harmony export */   isoCalendarId: () => (/* binding */ l),\n/* harmony export */   isoTimeFieldDefaults: () => (/* binding */ Nt),\n/* harmony export */   isoTimeFieldNamesAsc: () => (/* binding */ w),\n/* harmony export */   mapPropNames: () => (/* binding */ g),\n/* harmony export */   mapProps: () => (/* binding */ e),\n/* harmony export */   memoize: () => (/* binding */ on),\n/* harmony export */   mismatchingFormatTypes: () => (/* binding */ ln),\n/* harmony export */   monthDayConfig: () => (/* binding */ nt),\n/* harmony export */   moveInstant: () => (/* binding */ Ye),\n/* harmony export */   movePlainDate: () => (/* binding */ ne),\n/* harmony export */   movePlainDateTime: () => (/* binding */ wt),\n/* harmony export */   movePlainTime: () => (/* binding */ at),\n/* harmony export */   movePlainYearMonth: () => (/* binding */ Gt),\n/* harmony export */   moveZonedDateTime: () => (/* binding */ pe),\n/* harmony export */   nanoInMilli: () => (/* binding */ Qe),\n/* harmony export */   negateDuration: () => (/* binding */ B),\n/* harmony export */   numberToBigNano: () => (/* binding */ Ge),\n/* harmony export */   parseCalendarId: () => (/* binding */ f),\n/* harmony export */   parseDuration: () => (/* binding */ R),\n/* harmony export */   parseInstant: () => (/* binding */ We),\n/* harmony export */   parsePlainDate: () => (/* binding */ de),\n/* harmony export */   parsePlainDateTime: () => (/* binding */ Bt),\n/* harmony export */   parsePlainMonthDay: () => (/* binding */ xt),\n/* harmony export */   parsePlainTime: () => (/* binding */ ht),\n/* harmony export */   parsePlainYearMonth: () => (/* binding */ _t),\n/* harmony export */   parseRelativeToSlots: () => (/* binding */ H),\n/* harmony export */   parseTimeZoneId: () => (/* binding */ Z),\n/* harmony export */   parseZonedDateTime: () => (/* binding */ Ae),\n/* harmony export */   plainDateTimeToZonedDateTime: () => (/* binding */ bt),\n/* harmony export */   plainDateTimeWithFields: () => (/* binding */ gt),\n/* harmony export */   plainDateTimeWithPlainTime: () => (/* binding */ Ot),\n/* harmony export */   plainDateTimesEqual: () => (/* binding */ Ct),\n/* harmony export */   plainDateToPlainDateTime: () => (/* binding */ ie),\n/* harmony export */   plainDateToPlainMonthDay: () => (/* binding */ se),\n/* harmony export */   plainDateToPlainYearMonth: () => (/* binding */ le),\n/* harmony export */   plainDateToZonedDateTime: () => (/* binding */ ae),\n/* harmony export */   plainDateWithFields: () => (/* binding */ ee),\n/* harmony export */   plainDatesEqual: () => (/* binding */ re),\n/* harmony export */   plainMonthDayToPlainDate: () => (/* binding */ Vt),\n/* harmony export */   plainMonthDayWithFields: () => (/* binding */ Et),\n/* harmony export */   plainMonthDaysEqual: () => (/* binding */ Lt),\n/* harmony export */   plainTimeWithFields: () => (/* binding */ rt),\n/* harmony export */   plainTimesEqual: () => (/* binding */ st),\n/* harmony export */   plainYearMonthToPlainDate: () => (/* binding */ Ht),\n/* harmony export */   plainYearMonthWithFields: () => (/* binding */ Wt),\n/* harmony export */   plainYearMonthsEqual: () => (/* binding */ $t),\n/* harmony export */   pluckProps: () => (/* binding */ nn),\n/* harmony export */   queryNativeTimeZone: () => (/* binding */ L),\n/* harmony export */   refineCalendarId: () => (/* binding */ Mt),\n/* harmony export */   refineDirectionOptions: () => (/* binding */ Me),\n/* harmony export */   refineDurationBag: () => (/* binding */ q),\n/* harmony export */   refineMaybeZonedDateTimeBag: () => (/* binding */ $),\n/* harmony export */   refineOverflowOptions: () => (/* binding */ mt),\n/* harmony export */   refinePlainDateBag: () => (/* binding */ me),\n/* harmony export */   refinePlainDateTimeBag: () => (/* binding */ At),\n/* harmony export */   refinePlainMonthDayBag: () => (/* binding */ Rt),\n/* harmony export */   refinePlainTimeBag: () => (/* binding */ Tt),\n/* harmony export */   refinePlainYearMonthBag: () => (/* binding */ Xt),\n/* harmony export */   refineTimeZoneId: () => (/* binding */ Ze),\n/* harmony export */   refineZonedDateTimeBag: () => (/* binding */ Ne),\n/* harmony export */   refineZonedFieldOptions: () => (/* binding */ je),\n/* harmony export */   requireBoolean: () => (/* binding */ D),\n/* harmony export */   requireInteger: () => (/* binding */ T),\n/* harmony export */   requireIntegerOrUndefined: () => (/* binding */ S),\n/* harmony export */   requireNumberIsInteger: () => (/* binding */ ze),\n/* harmony export */   requirePositiveInteger: () => (/* binding */ h),\n/* harmony export */   requirePositiveIntegerOrUndefined: () => (/* binding */ P),\n/* harmony export */   requireString: () => (/* binding */ m),\n/* harmony export */   requireStringOrUndefined: () => (/* binding */ d),\n/* harmony export */   resolveCalendarId: () => (/* binding */ u),\n/* harmony export */   resolveTimeZoneId: () => (/* binding */ M),\n/* harmony export */   roundDuration: () => (/* binding */ V),\n/* harmony export */   roundInstant: () => (/* binding */ Le),\n/* harmony export */   roundPlainDateTime: () => (/* binding */ vt),\n/* harmony export */   roundPlainTime: () => (/* binding */ lt),\n/* harmony export */   roundZonedDateTime: () => (/* binding */ Ie),\n/* harmony export */   slotsWithCalendarId: () => (/* binding */ pt),\n/* harmony export */   slotsWithTimeZoneId: () => (/* binding */ Pe),\n/* harmony export */   timeConfig: () => (/* binding */ tt),\n/* harmony export */   timeFieldNamesAsc: () => (/* binding */ O),\n/* harmony export */   totalDuration: () => (/* binding */ J),\n/* harmony export */   yearMonthConfig: () => (/* binding */ et),\n/* harmony export */   zonedConfig: () => (/* binding */ ot),\n/* harmony export */   zonedDateTimeToInstant: () => (/* binding */ be),\n/* harmony export */   zonedDateTimeToPlainDate: () => (/* binding */ fe),\n/* harmony export */   zonedDateTimeToPlainDateTime: () => (/* binding */ yt),\n/* harmony export */   zonedDateTimeToPlainTime: () => (/* binding */ dt),\n/* harmony export */   zonedDateTimeWithFields: () => (/* binding */ De),\n/* harmony export */   zonedDateTimeWithPlainTime: () => (/* binding */ ge),\n/* harmony export */   zonedDateTimesEqual: () => (/* binding */ Ce),\n/* harmony export */   zonedEpochSlotsToIso: () => (/* binding */ he)\n/* harmony export */ });\nfunction clampProp(e, n, t, o, r) {\n  return clampEntity(n, ((e, n) => {\n    const t = e[n];\n    if (void 0 === t) {\n      throw new TypeError(missingField(n));\n    }\n    return t;\n  })(e, n), t, o, r);\n}\n\nfunction clampEntity(e, n, t, o, r, i) {\n  const a = clampNumber(n, t, o);\n  if (r && n !== a) {\n    throw new RangeError(numberOutOfRange(e, n, t, o, i));\n  }\n  return a;\n}\n\nfunction s(e) {\n  return null !== e && /object|function/.test(typeof e);\n}\n\nfunction on(e, n = Map) {\n  const t = new n;\n  return (n, ...o) => {\n    if (t.has(n)) {\n      return t.get(n);\n    }\n    const r = e(n, ...o);\n    return t.set(n, r), r;\n  };\n}\n\nfunction r(e) {\n  return n({\n    name: e\n  }, 1);\n}\n\nfunction n(n, t) {\n  return e((e => ({\n    value: e,\n    configurable: 1,\n    writable: !t\n  })), n);\n}\n\nfunction t(n) {\n  return e((e => ({\n    get: e,\n    configurable: 1\n  })), n);\n}\n\nfunction o(e) {\n  return {\n    [Symbol.toStringTag]: {\n      value: e,\n      configurable: 1\n    }\n  };\n}\n\nfunction zipProps(e, n) {\n  const t = {};\n  let o = e.length;\n  for (const r of n) {\n    t[e[--o]] = r;\n  }\n  return t;\n}\n\nfunction e(e, n, t) {\n  const o = {};\n  for (const r in n) {\n    o[r] = e(n[r], r, t);\n  }\n  return o;\n}\n\nfunction g(e, n, t) {\n  const o = {};\n  for (let r = 0; r < n.length; r++) {\n    const i = n[r];\n    o[i] = e(i, r, t);\n  }\n  return o;\n}\n\nfunction remapProps(e, n, t) {\n  const o = {};\n  for (let r = 0; r < e.length; r++) {\n    o[n[r]] = t[e[r]];\n  }\n  return o;\n}\n\nfunction nn(e, n) {\n  const t = Object.create(null);\n  for (const o of e) {\n    t[o] = n[o];\n  }\n  return t;\n}\n\nfunction hasAnyPropsByName(e, n) {\n  for (const t of n) {\n    if (t in e) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nfunction allPropsEqual(e, n, t) {\n  for (const o of e) {\n    if (n[o] !== t[o]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nfunction zeroOutProps(e, n, t) {\n  const o = {\n    ...t\n  };\n  for (let t = 0; t < n; t++) {\n    o[e[t]] = 0;\n  }\n  return o;\n}\n\nfunction Pt(e, ...n) {\n  return (...t) => e(...n, ...t);\n}\n\nfunction capitalize(e) {\n  return e[0].toUpperCase() + e.substring(1);\n}\n\nfunction sortStrings(e) {\n  return e.slice().sort();\n}\n\nfunction padNumber(e, n) {\n  return String(n).padStart(e, \"0\");\n}\n\nfunction compareNumbers(e, n) {\n  return Math.sign(e - n);\n}\n\nfunction clampNumber(e, n, t) {\n  return Math.min(Math.max(e, n), t);\n}\n\nfunction divModFloor(e, n) {\n  return [ Math.floor(e / n), modFloor(e, n) ];\n}\n\nfunction modFloor(e, n) {\n  return (e % n + n) % n;\n}\n\nfunction divModTrunc(e, n) {\n  return [ divTrunc(e, n), modTrunc(e, n) ];\n}\n\nfunction divTrunc(e, n) {\n  return Math.trunc(e / n) || 0;\n}\n\nfunction modTrunc(e, n) {\n  return e % n || 0;\n}\n\nfunction hasHalf(e) {\n  return .5 === Math.abs(e % 1);\n}\n\nfunction givenFieldsToBigNano(e, n, t) {\n  let o = 0, r = 0;\n  for (let i = 0; i <= n; i++) {\n    const n = e[t[i]], a = Ao[i], s = Uo / a, [c, u] = divModTrunc(n, s);\n    o += u * a, r += c;\n  }\n  const [i, a] = divModTrunc(o, Uo);\n  return [ r + i, a ];\n}\n\nfunction nanoToGivenFields(e, n, t) {\n  const o = {};\n  for (let r = n; r >= 0; r--) {\n    const n = Ao[r];\n    o[t[r]] = divTrunc(e, n), e = modTrunc(e, n);\n  }\n  return o;\n}\n\nfunction d(e) {\n  if (void 0 !== e) {\n    return m(e);\n  }\n}\n\nfunction P(e) {\n  if (void 0 !== e) {\n    return h(e);\n  }\n}\n\nfunction S(e) {\n  if (void 0 !== e) {\n    return T(e);\n  }\n}\n\nfunction h(e) {\n  return requireNumberIsPositive(T(e));\n}\n\nfunction T(e) {\n  return ze(cr(e));\n}\n\nfunction requirePropDefined(e, n) {\n  if (null == n) {\n    throw new RangeError(missingField(e));\n  }\n  return n;\n}\n\nfunction requireObjectLike(e) {\n  if (!s(e)) {\n    throw new TypeError(oo);\n  }\n  return e;\n}\n\nfunction requireType(e, n, t = e) {\n  if (typeof n !== e) {\n    throw new TypeError(invalidEntity(t, n));\n  }\n  return n;\n}\n\nfunction ze(e, n = \"number\") {\n  if (!Number.isInteger(e)) {\n    throw new RangeError(expectedInteger(n, e));\n  }\n  return e || 0;\n}\n\nfunction requireNumberIsPositive(e, n = \"number\") {\n  if (e <= 0) {\n    throw new RangeError(expectedPositive(n, e));\n  }\n  return e;\n}\n\nfunction toString(e) {\n  if (\"symbol\" == typeof e) {\n    throw new TypeError(no);\n  }\n  return String(e);\n}\n\nfunction toStringViaPrimitive(e, n) {\n  return s(e) ? String(e) : m(e, n);\n}\n\nfunction toBigInt(e) {\n  if (\"string\" == typeof e) {\n    return BigInt(e);\n  }\n  if (\"bigint\" != typeof e) {\n    throw new TypeError(invalidBigInt(e));\n  }\n  return e;\n}\n\nfunction toNumber(e, n = \"number\") {\n  if (\"bigint\" == typeof e) {\n    throw new TypeError(forbiddenBigIntToNumber(n));\n  }\n  if (e = Number(e), !Number.isFinite(e)) {\n    throw new RangeError(expectedFinite(n, e));\n  }\n  return e;\n}\n\nfunction toInteger(e, n) {\n  return Math.trunc(toNumber(e, n)) || 0;\n}\n\nfunction toStrictInteger(e, n) {\n  return ze(toNumber(e, n), n);\n}\n\nfunction toPositiveInteger(e, n) {\n  return requireNumberIsPositive(toInteger(e, n), n);\n}\n\nfunction createBigNano(e, n) {\n  let [t, o] = divModTrunc(n, Uo), r = e + t;\n  const i = Math.sign(r);\n  return i && i === -Math.sign(o) && (r -= i, o += i * Uo), [ r, o ];\n}\n\nfunction addBigNanos(e, n, t = 1) {\n  return createBigNano(e[0] + n[0] * t, e[1] + n[1] * t);\n}\n\nfunction moveBigNano(e, n) {\n  return createBigNano(e[0], e[1] + n);\n}\n\nfunction diffBigNanos(e, n) {\n  return addBigNanos(n, e, -1);\n}\n\nfunction compareBigNanos(e, n) {\n  return compareNumbers(e[0], n[0]) || compareNumbers(e[1], n[1]);\n}\n\nfunction bigNanoOutside(e, n, t) {\n  return -1 === compareBigNanos(e, n) || 1 === compareBigNanos(e, t);\n}\n\nfunction bigIntToBigNano(e, n = 1) {\n  const t = BigInt(Uo / n);\n  return [ Number(e / t), Number(e % t) * n ];\n}\n\nfunction Ge(e, n = 1) {\n  const t = Uo / n, [o, r] = divModTrunc(e, t);\n  return [ o, r * n ];\n}\n\nfunction bigNanoToNumber(e, n = 1, t) {\n  const [o, r] = e, [i, a] = divModTrunc(r, n);\n  return o * (Uo / n) + (i + (t ? a / n : 0));\n}\n\nfunction divModBigNano(e, n, t = divModFloor) {\n  const [o, r] = e, [i, a] = t(r, n);\n  return [ o * (Uo / n) + i, a ];\n}\n\nfunction checkIsoYearMonthInBounds(e) {\n  return clampProp(e, \"isoYear\", wr, Fr, 1), e.isoYear === wr ? clampProp(e, \"isoMonth\", 4, 12, 1) : e.isoYear === Fr && clampProp(e, \"isoMonth\", 1, 9, 1), \n  e;\n}\n\nfunction checkIsoDateInBounds(e) {\n  return checkIsoDateTimeInBounds({\n    ...e,\n    ...Nt,\n    isoHour: 12\n  }), e;\n}\n\nfunction checkIsoDateTimeInBounds(e) {\n  const n = clampProp(e, \"isoYear\", wr, Fr, 1), t = n === wr ? 1 : n === Fr ? -1 : 0;\n  return t && checkEpochNanoInBounds(isoToEpochNano({\n    ...e,\n    isoDay: e.isoDay + t,\n    isoNanosecond: e.isoNanosecond - t\n  })), e;\n}\n\nfunction checkEpochNanoInBounds(e) {\n  if (!e || bigNanoOutside(e, Sr, Er)) {\n    throw new RangeError(Io);\n  }\n  return e;\n}\n\nfunction isoTimeFieldsToNano(e) {\n  return givenFieldsToBigNano(e, 5, w)[1];\n}\n\nfunction nanoToIsoTimeAndDay(e) {\n  const [n, t] = divModFloor(e, Uo);\n  return [ nanoToGivenFields(t, 5, w), n ];\n}\n\nfunction epochNanoToSecMod(e) {\n  return divModBigNano(e, Ro);\n}\n\nfunction isoToEpochMilli(e) {\n  return isoArgsToEpochMilli(e.isoYear, e.isoMonth, e.isoDay, e.isoHour, e.isoMinute, e.isoSecond, e.isoMillisecond);\n}\n\nfunction isoToEpochNano(e) {\n  const n = isoToEpochMilli(e);\n  if (void 0 !== n) {\n    const [t, o] = divModTrunc(n, ko);\n    return [ t, o * Qe + (e.isoMicrosecond || 0) * Yo + (e.isoNanosecond || 0) ];\n  }\n}\n\nfunction isoToEpochNanoWithOffset(e, n) {\n  const [t, o] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e) - n);\n  return checkEpochNanoInBounds(isoToEpochNano({\n    ...e,\n    isoDay: e.isoDay + o,\n    ...t\n  }));\n}\n\nfunction isoArgsToEpochSec(...e) {\n  return isoArgsToEpochMilli(...e) / Co;\n}\n\nfunction isoArgsToEpochMilli(...e) {\n  const [n, t] = isoToLegacyDate(...e), o = n.valueOf();\n  if (!isNaN(o)) {\n    return o - t * ko;\n  }\n}\n\nfunction isoToLegacyDate(e, n = 1, t = 1, o = 0, r = 0, i = 0, a = 0) {\n  const s = e === wr ? 1 : e === Fr ? -1 : 0, c = new Date;\n  return c.setUTCHours(o, r, i, a), c.setUTCFullYear(e, n - 1, t + s), [ c, s ];\n}\n\nfunction epochNanoToIso(e, n) {\n  let [t, o] = moveBigNano(e, n);\n  o < 0 && (o += Uo, t -= 1);\n  const [r, i] = divModFloor(o, Qe), [a, s] = divModFloor(i, Yo);\n  return epochMilliToIso(t * ko + r, a, s);\n}\n\nfunction epochMilliToIso(e, n = 0, t = 0) {\n  const o = Math.ceil(Math.max(0, Math.abs(e) - Pr) / ko) * Math.sign(e), r = new Date(e - o * ko);\n  return zipProps(Tr, [ r.getUTCFullYear(), r.getUTCMonth() + 1, r.getUTCDate() + o, r.getUTCHours(), r.getUTCMinutes(), r.getUTCSeconds(), r.getUTCMilliseconds(), n, t ]);\n}\n\nfunction hashIntlFormatParts(e, n) {\n  if (n < -Pr) {\n    throw new RangeError(Io);\n  }\n  const t = e.formatToParts(n), o = {};\n  for (const e of t) {\n    o[e.type] = e.value;\n  }\n  return o;\n}\n\nfunction computeIsoDateParts(e) {\n  return [ e.isoYear, e.isoMonth, e.isoDay ];\n}\n\nfunction computeIsoMonthCodeParts(e, n) {\n  return [ n, 0 ];\n}\n\nfunction computeIsoMonthsInYear() {\n  return kr;\n}\n\nfunction computeIsoDaysInMonth(e, n) {\n  switch (n) {\n   case 2:\n    return computeIsoInLeapYear(e) ? 29 : 28;\n\n   case 4:\n   case 6:\n   case 9:\n   case 11:\n    return 30;\n  }\n  return 31;\n}\n\nfunction computeIsoDaysInYear(e) {\n  return computeIsoInLeapYear(e) ? 366 : 365;\n}\n\nfunction computeIsoInLeapYear(e) {\n  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);\n}\n\nfunction computeIsoDayOfWeek(e) {\n  const [n, t] = isoToLegacyDate(e.isoYear, e.isoMonth, e.isoDay);\n  return modFloor(n.getUTCDay() - t, 7) || 7;\n}\n\nfunction computeIsoEraParts(e) {\n  return this.id === or ? (({isoYear: e}) => e < 1 ? [ \"gregory-inverse\", 1 - e ] : [ \"gregory\", e ])(e) : this.id === rr ? Yr(e) : [];\n}\n\nfunction computeJapaneseEraParts(e) {\n  const n = isoToEpochMilli(e);\n  if (n < Cr) {\n    const {isoYear: n} = e;\n    return n < 1 ? [ \"japanese-inverse\", 1 - n ] : [ \"japanese\", n ];\n  }\n  const t = hashIntlFormatParts(Ci(rr), n), {era: o, eraYear: r} = parseIntlYear(t, rr);\n  return [ o, r ];\n}\n\nfunction checkIsoDateTimeFields(e) {\n  return checkIsoDateFields(e), constrainIsoTimeFields(e, 1), e;\n}\n\nfunction checkIsoDateFields(e) {\n  return constrainIsoDateFields(e, 1), e;\n}\n\nfunction isIsoDateFieldsValid(e) {\n  return allPropsEqual(Dr, e, constrainIsoDateFields(e));\n}\n\nfunction constrainIsoDateFields(e, n) {\n  const {isoYear: t} = e, o = clampProp(e, \"isoMonth\", 1, computeIsoMonthsInYear(), n);\n  return {\n    isoYear: t,\n    isoMonth: o,\n    isoDay: clampProp(e, \"isoDay\", 1, computeIsoDaysInMonth(t, o), n)\n  };\n}\n\nfunction constrainIsoTimeFields(e, n) {\n  return zipProps(w, [ clampProp(e, \"isoHour\", 0, 23, n), clampProp(e, \"isoMinute\", 0, 59, n), clampProp(e, \"isoSecond\", 0, 59, n), clampProp(e, \"isoMillisecond\", 0, 999, n), clampProp(e, \"isoMicrosecond\", 0, 999, n), clampProp(e, \"isoNanosecond\", 0, 999, n) ]);\n}\n\nfunction mt(e) {\n  return void 0 === e ? 0 : Xr(requireObjectLike(e));\n}\n\nfunction je(e, n = 0) {\n  e = normalizeOptions(e);\n  const t = ei(e), o = ni(e, n);\n  return [ Xr(e), o, t ];\n}\n\nfunction refineDiffOptions(e, n, t, o = 9, r = 0, i = 4) {\n  n = normalizeOptions(n);\n  let a = Kr(n, o, r), s = parseRoundingIncInteger(n), c = ii(n, i);\n  const u = Jr(n, o, r, 1);\n  return null == a ? a = Math.max(t, u) : checkLargestSmallestUnit(a, u), s = refineRoundingInc(s, u, 1), \n  e && (c = (e => e < 4 ? (e + 2) % 4 : e)(c)), [ a, u, s, c ];\n}\n\nfunction refineRoundingOptions(e, n = 6, t) {\n  let o = parseRoundingIncInteger(e = normalizeOptionsOrString(e, Rr));\n  const r = ii(e, 7);\n  let i = Jr(e, n);\n  return i = requirePropDefined(Rr, i), o = refineRoundingInc(o, i, void 0, t), [ i, o, r ];\n}\n\nfunction refineDateDisplayOptions(e) {\n  return ti(normalizeOptions(e));\n}\n\nfunction refineTimeDisplayOptions(e, n) {\n  return refineTimeDisplayTuple(normalizeOptions(e), n);\n}\n\nfunction Me(e) {\n  const n = normalizeOptionsOrString(e, qr), t = refineChoiceOption(qr, _r, n, 0);\n  if (!t) {\n    throw new RangeError(invalidEntity(qr, t));\n  }\n  return t;\n}\n\nfunction refineTimeDisplayTuple(e, n = 4) {\n  const t = refineSubsecDigits(e);\n  return [ ii(e, 4), ...refineSmallestUnitAndSubsecDigits(Jr(e, n), t) ];\n}\n\nfunction refineSmallestUnitAndSubsecDigits(e, n) {\n  return null != e ? [ Ao[e], e < 4 ? 9 - 3 * e : -1 ] : [ void 0 === n ? 1 : 10 ** (9 - n), n ];\n}\n\nfunction parseRoundingIncInteger(e) {\n  const n = e[zr];\n  return void 0 === n ? 1 : toInteger(n, zr);\n}\n\nfunction refineRoundingInc(e, n, t, o) {\n  const r = o ? Uo : Ao[n + 1];\n  if (r) {\n    const t = Ao[n];\n    if (r % ((e = clampEntity(zr, e, 1, r / t - (o ? 0 : 1), 1)) * t)) {\n      throw new RangeError(invalidEntity(zr, e));\n    }\n  } else {\n    e = clampEntity(zr, e, 1, t ? 10 ** 9 : 1, 1);\n  }\n  return e;\n}\n\nfunction refineSubsecDigits(e) {\n  let n = e[Ur];\n  if (void 0 !== n) {\n    if (\"number\" != typeof n) {\n      if (\"auto\" === toString(n)) {\n        return;\n      }\n      throw new RangeError(invalidEntity(Ur, n));\n    }\n    n = clampEntity(Ur, Math.floor(n), 0, 9, 1);\n  }\n  return n;\n}\n\nfunction normalizeOptions(e) {\n  return void 0 === e ? {} : requireObjectLike(e);\n}\n\nfunction normalizeOptionsOrString(e, n) {\n  return \"string\" == typeof e ? {\n    [n]: e\n  } : requireObjectLike(e);\n}\n\nfunction fabricateOverflowOptions(e) {\n  return {\n    overflow: jr[e]\n  };\n}\n\nfunction refineUnitOption(e, n, t = 9, o = 0, r) {\n  let i = n[e];\n  if (void 0 === i) {\n    return r ? o : void 0;\n  }\n  if (i = toString(i), \"auto\" === i) {\n    return r ? o : null;\n  }\n  let a = Oo[i];\n  if (void 0 === a && (a = mr[i]), void 0 === a) {\n    throw new RangeError(invalidChoice(e, i, Oo));\n  }\n  return clampEntity(e, a, o, t, 1, Bo), a;\n}\n\nfunction refineChoiceOption(e, n, t, o = 0) {\n  const r = t[e];\n  if (void 0 === r) {\n    return o;\n  }\n  const i = toString(r), a = n[i];\n  if (void 0 === a) {\n    throw new RangeError(invalidChoice(e, i, n));\n  }\n  return a;\n}\n\nfunction checkLargestSmallestUnit(e, n) {\n  if (n > e) {\n    throw new RangeError(Eo);\n  }\n}\n\nfunction xe(e) {\n  return {\n    branding: Re,\n    epochNanoseconds: e\n  };\n}\n\nfunction _e(e, n, t) {\n  return {\n    branding: z,\n    calendar: t,\n    timeZone: n,\n    epochNanoseconds: e\n  };\n}\n\nfunction jt(e, n = e.calendar) {\n  return {\n    branding: x,\n    calendar: n,\n    ...nn(Nr, e)\n  };\n}\n\nfunction W(e, n = e.calendar) {\n  return {\n    branding: G,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction createPlainYearMonthSlots(e, n = e.calendar) {\n  return {\n    branding: Ut,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction createPlainMonthDaySlots(e, n = e.calendar) {\n  return {\n    branding: qt,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction St(e) {\n  return {\n    branding: ft,\n    ...nn(Mr, e)\n  };\n}\n\nfunction Oe(e) {\n  return {\n    branding: N,\n    sign: computeDurationSign(e),\n    ...nn(ur, e)\n  };\n}\n\nfunction I(e) {\n  return divModBigNano(e.epochNanoseconds, Qe)[0];\n}\n\nfunction v(e) {\n  return ((e, n = 1) => {\n    const [t, o] = e, r = Math.floor(o / n), i = Uo / n;\n    return BigInt(t) * BigInt(i) + BigInt(r);\n  })(e.epochNanoseconds);\n}\n\nfunction extractEpochNano(e) {\n  return e.epochNanoseconds;\n}\n\nfunction J(e, n, t, o, r) {\n  const i = getMaxDurationUnit(o), [a, s] = ((e, n) => {\n    const t = n((e = normalizeOptionsOrString(e, Zr))[Ar]);\n    let o = Qr(e);\n    return o = requirePropDefined(Zr, o), [ o, t ];\n  })(r, e), c = Math.max(a, i);\n  if (!s && isUniformUnit(c, s)) {\n    return totalDayTimeDuration(o, a);\n  }\n  if (!s) {\n    throw new RangeError(yo);\n  }\n  if (!o.sign) {\n    return 0;\n  }\n  const [u, f, l] = createMarkerSystem(n, t, s), d = createMarkerToEpochNano(l), m = createMoveMarker(l), h = createDiffMarkers(l), g = m(f, u, o);\n  isZonedEpochSlots(s) || (checkIsoDateTimeInBounds(u), checkIsoDateTimeInBounds(g));\n  const D = h(f, u, g, a);\n  return isUniformUnit(a, s) ? totalDayTimeDuration(D, a) : ((e, n, t, o, r, i, a) => {\n    const s = computeDurationSign(e), [c, u] = clampRelativeDuration(o, gr(t, e), t, s, r, i, a), f = computeEpochNanoFrac(n, c, u);\n    return e[p[t]] + f * s;\n  })(D, d(g), a, f, u, d, m);\n}\n\nfunction totalDayTimeDuration(e, n) {\n  return bigNanoToNumber(durationFieldsToBigNano(e), Ao[n], 1);\n}\n\nfunction clampRelativeDuration(e, n, t, o, r, i, a) {\n  const s = p[t], c = {\n    ...n,\n    [s]: n[s] + o\n  }, u = a(e, r, n), f = a(e, r, c);\n  return [ i(u), i(f) ];\n}\n\nfunction computeEpochNanoFrac(e, n, t) {\n  const o = bigNanoToNumber(diffBigNanos(n, t));\n  if (!o) {\n    throw new RangeError(fo);\n  }\n  return bigNanoToNumber(diffBigNanos(n, e)) / o;\n}\n\nfunction Le(e, n) {\n  const [t, o, r] = refineRoundingOptions(n, 5, 1);\n  return xe(roundBigNano(e.epochNanoseconds, t, o, r, 1));\n}\n\nfunction Ie(e, n, t) {\n  let {epochNanoseconds: o, timeZone: r, calendar: i} = n;\n  const [a, s, c] = refineRoundingOptions(t);\n  if (0 === a && 1 === s) {\n    return n;\n  }\n  const u = e(r);\n  if (6 === a) {\n    o = ((e, n, t, o) => {\n      const r = he(t, n), [i, a] = e(r), s = t.epochNanoseconds, c = getStartOfDayInstantFor(n, i), u = getStartOfDayInstantFor(n, a);\n      if (bigNanoOutside(s, c, u)) {\n        throw new RangeError(fo);\n      }\n      return roundWithMode(computeEpochNanoFrac(s, c, u), o) ? u : c;\n    })(computeDayInterval, u, n, c);\n  } else {\n    const e = u.R(o);\n    o = getMatchingInstantFor(u, roundDateTime(epochNanoToIso(o, e), a, s, c), e, 2, 0, 1);\n  }\n  return _e(o, r, i);\n}\n\nfunction vt(e, n) {\n  return jt(roundDateTime(e, ...refineRoundingOptions(n)), e.calendar);\n}\n\nfunction lt(e, n) {\n  const [t, o, r] = refineRoundingOptions(n, 5);\n  var i;\n  return St((i = r, roundTimeToNano(e, computeNanoInc(t, o), i)[0]));\n}\n\nfunction Te(e, n) {\n  const t = e(n.timeZone), o = he(n, t), [r, i] = computeDayInterval(o), a = bigNanoToNumber(diffBigNanos(getStartOfDayInstantFor(t, r), getStartOfDayInstantFor(t, i)), zo, 1);\n  if (a <= 0) {\n    throw new RangeError(fo);\n  }\n  return a;\n}\n\nfunction ve(e, n) {\n  const {timeZone: t, calendar: o} = n, r = ((e, n, t) => getStartOfDayInstantFor(n, e(he(t, n))))(computeDayFloor, e(t), n);\n  return _e(r, t, o);\n}\n\nfunction roundDateTime(e, n, t, o) {\n  return roundDateTimeToNano(e, computeNanoInc(n, t), o);\n}\n\nfunction roundDateTimeToNano(e, n, t) {\n  const [o, r] = roundTimeToNano(e, n, t);\n  return checkIsoDateTimeInBounds({\n    ...moveByDays(e, r),\n    ...o\n  });\n}\n\nfunction roundTimeToNano(e, n, t) {\n  return nanoToIsoTimeAndDay(roundByInc(isoTimeFieldsToNano(e), n, t));\n}\n\nfunction roundToMinute(e) {\n  return roundByInc(e, Zo, 7);\n}\n\nfunction computeNanoInc(e, n) {\n  return Ao[e] * n;\n}\n\nfunction computeDayInterval(e) {\n  const n = computeDayFloor(e);\n  return [ n, moveByDays(n, 1) ];\n}\n\nfunction computeDayFloor(e) {\n  return yr(6, e);\n}\n\nfunction roundDayTimeDurationByInc(e, n, t) {\n  const o = Math.min(getMaxDurationUnit(e), 6);\n  return nanoToDurationDayTimeFields(roundBigNanoByInc(durationFieldsToBigNano(e, o), n, t), o);\n}\n\nfunction roundRelativeDuration(e, n, t, o, r, i, a, s, c, u) {\n  if (0 === o && 1 === r) {\n    return e;\n  }\n  const f = isUniformUnit(o, s) ? isZonedEpochSlots(s) && o < 6 && t >= 6 ? nudgeZonedTimeDuration : nudgeDayTimeDuration : nudgeRelativeDuration;\n  let [l, d, m] = f(e, n, t, o, r, i, a, s, c, u);\n  return m && 7 !== o && (l = ((e, n, t, o, r, i, a, s) => {\n    const c = computeDurationSign(e);\n    for (let u = o + 1; u <= t; u++) {\n      if (7 === u && 7 !== t) {\n        continue;\n      }\n      const o = gr(u, e);\n      o[p[u]] += c;\n      const f = bigNanoToNumber(diffBigNanos(a(s(r, i, o)), n));\n      if (f && Math.sign(f) !== c) {\n        break;\n      }\n      e = o;\n    }\n    return e;\n  })(l, d, t, Math.max(6, o), a, s, c, u)), l;\n}\n\nfunction roundBigNano(e, n, t, o, r) {\n  if (6 === n) {\n    const n = (e => e[0] + e[1] / Uo)(e);\n    return [ roundByInc(n, t, o), 0 ];\n  }\n  return roundBigNanoByInc(e, computeNanoInc(n, t), o, r);\n}\n\nfunction roundBigNanoByInc(e, n, t, o) {\n  let [r, i] = e;\n  o && i < 0 && (i += Uo, r -= 1);\n  const [a, s] = divModFloor(roundByInc(i, n, t), Uo);\n  return createBigNano(r + a, s);\n}\n\nfunction roundByInc(e, n, t) {\n  return roundWithMode(e / n, t) * n;\n}\n\nfunction roundWithMode(e, n) {\n  return ai[n](e);\n}\n\nfunction nudgeDayTimeDuration(e, n, t, o, r, i) {\n  const a = computeDurationSign(e), s = durationFieldsToBigNano(e), c = roundBigNano(s, o, r, i), u = diffBigNanos(s, c), f = Math.sign(c[0] - s[0]) === a, l = nanoToDurationDayTimeFields(c, Math.min(t, 6));\n  return [ {\n    ...e,\n    ...l\n  }, addBigNanos(n, u), f ];\n}\n\nfunction nudgeZonedTimeDuration(e, n, t, o, r, i, a, s, c, u) {\n  const f = computeDurationSign(e) || 1, l = bigNanoToNumber(durationFieldsToBigNano(e, 5)), d = computeNanoInc(o, r);\n  let m = roundByInc(l, d, i);\n  const [p, h] = clampRelativeDuration(a, {\n    ...e,\n    ...hr\n  }, 6, f, s, c, u), g = m - bigNanoToNumber(diffBigNanos(p, h));\n  let D = 0;\n  g && Math.sign(g) !== f ? n = moveBigNano(p, m) : (D += f, m = roundByInc(g, d, i), \n  n = moveBigNano(h, m));\n  const T = nanoToDurationTimeFields(m);\n  return [ {\n    ...e,\n    ...T,\n    days: e.days + D\n  }, n, Boolean(D) ];\n}\n\nfunction nudgeRelativeDuration(e, n, t, o, r, i, a, s, c, u) {\n  const f = computeDurationSign(e), l = p[o], d = gr(o, e);\n  7 === o && (e = {\n    ...e,\n    weeks: e.weeks + Math.trunc(e.days / 7)\n  });\n  const m = divTrunc(e[l], r) * r;\n  d[l] = m;\n  const [h, g] = clampRelativeDuration(a, d, o, r * f, s, c, u), D = m + computeEpochNanoFrac(n, h, g) * f * r, T = roundByInc(D, r, i), I = Math.sign(T - D) === f;\n  return d[l] = T, [ d, I ? g : h, I ];\n}\n\nfunction ke(e, n, t, o) {\n  const [r, i, a, s] = (e => {\n    const n = refineTimeDisplayTuple(e = normalizeOptions(e));\n    return [ e.timeZone, ...n ];\n  })(o), c = void 0 !== r;\n  return ((e, n, t, o, r, i) => {\n    t = roundBigNanoByInc(t, r, o, 1);\n    const a = n.R(t);\n    return formatIsoDateTimeFields(epochNanoToIso(t, a), i) + (e ? Se(roundToMinute(a)) : \"Z\");\n  })(c, n(c ? e(r) : si), t.epochNanoseconds, i, a, s);\n}\n\nfunction Fe(e, n, t) {\n  const [o, r, i, a, s, c] = (e => {\n    e = normalizeOptions(e);\n    const n = ti(e), t = refineSubsecDigits(e), o = ri(e), r = ii(e, 4), i = Jr(e, 4);\n    return [ n, oi(e), o, r, ...refineSmallestUnitAndSubsecDigits(i, t) ];\n  })(t);\n  return ((e, n, t, o, r, i, a, s, c, u) => {\n    o = roundBigNanoByInc(o, c, s, 1);\n    const f = e(t).R(o);\n    return formatIsoDateTimeFields(epochNanoToIso(o, f), u) + Se(roundToMinute(f), a) + ((e, n) => 1 !== n ? \"[\" + (2 === n ? \"!\" : \"\") + e + \"]\" : \"\")(t, i) + formatCalendar(n, r);\n  })(e, n.calendar, n.timeZone, n.epochNanoseconds, o, r, i, a, s, c);\n}\n\nfunction Ft(e, n) {\n  const [t, o, r, i] = (e => (e = normalizeOptions(e), [ ti(e), ...refineTimeDisplayTuple(e) ]))(n);\n  return a = e.calendar, s = t, c = i, formatIsoDateTimeFields(roundDateTimeToNano(e, r, o), c) + formatCalendar(a, s);\n  var a, s, c;\n}\n\nfunction ce(e, n) {\n  return t = e.calendar, o = e, r = refineDateDisplayOptions(n), formatIsoDateFields(o) + formatCalendar(t, r);\n  var t, o, r;\n}\n\nfunction Kt(e, n) {\n  return formatDateLikeIso(e.calendar, formatIsoYearMonthFields, e, refineDateDisplayOptions(n));\n}\n\nfunction Jt(e, n) {\n  return formatDateLikeIso(e.calendar, formatIsoMonthDayFields, e, refineDateDisplayOptions(n));\n}\n\nfunction ct(e, n) {\n  const [t, o, r] = refineTimeDisplayOptions(n);\n  return i = r, formatIsoTimeFields(roundTimeToNano(e, o, t)[0], i);\n  var i;\n}\n\nfunction k(e, n) {\n  const [t, o, r] = refineTimeDisplayOptions(n, 3);\n  return o > 1 && checkDurationUnits(e = {\n    ...e,\n    ...roundDayTimeDurationByInc(e, o, t)\n  }), ((e, n) => {\n    const {sign: t} = e, o = -1 === t ? negateDurationFields(e) : e, {hours: r, minutes: i} = o, [a, s] = divModBigNano(durationFieldsToBigNano(o, 3), Ro, divModTrunc);\n    checkDurationTimeUnit(a);\n    const c = formatSubsecNano(s, n), u = n >= 0 || !t || c;\n    return (t < 0 ? \"-\" : \"\") + \"P\" + formatDurationFragments({\n      Y: formatDurationNumber(o.years),\n      M: formatDurationNumber(o.months),\n      W: formatDurationNumber(o.weeks),\n      D: formatDurationNumber(o.days)\n    }) + (r || i || a || u ? \"T\" + formatDurationFragments({\n      H: formatDurationNumber(r),\n      M: formatDurationNumber(i),\n      S: formatDurationNumber(a, u) + c\n    }) : \"\");\n  })(e, r);\n}\n\nfunction formatDateLikeIso(e, n, t, o) {\n  const r = o > 1 || 0 === o && e !== l;\n  return 1 === o ? e === l ? n(t) : formatIsoDateFields(t) : r ? formatIsoDateFields(t) + formatCalendarId(e, 2 === o) : n(t);\n}\n\nfunction formatDurationFragments(e) {\n  const n = [];\n  for (const t in e) {\n    const o = e[t];\n    o && n.push(o, t);\n  }\n  return n.join(\"\");\n}\n\nfunction formatIsoDateTimeFields(e, n) {\n  return formatIsoDateFields(e) + \"T\" + formatIsoTimeFields(e, n);\n}\n\nfunction formatIsoDateFields(e) {\n  return formatIsoYearMonthFields(e) + \"-\" + bo(e.isoDay);\n}\n\nfunction formatIsoYearMonthFields(e) {\n  const {isoYear: n} = e;\n  return (n < 0 || n > 9999 ? getSignStr(n) + padNumber(6, Math.abs(n)) : padNumber(4, n)) + \"-\" + bo(e.isoMonth);\n}\n\nfunction formatIsoMonthDayFields(e) {\n  return bo(e.isoMonth) + \"-\" + bo(e.isoDay);\n}\n\nfunction formatIsoTimeFields(e, n) {\n  const t = [ bo(e.isoHour), bo(e.isoMinute) ];\n  return -1 !== n && t.push(bo(e.isoSecond) + ((e, n, t, o) => formatSubsecNano(e * Qe + n * Yo + t, o))(e.isoMillisecond, e.isoMicrosecond, e.isoNanosecond, n)), \n  t.join(\":\");\n}\n\nfunction Se(e, n = 0) {\n  if (1 === n) {\n    return \"\";\n  }\n  const [t, o] = divModFloor(Math.abs(e), zo), [r, i] = divModFloor(o, Zo), [a, s] = divModFloor(i, Ro);\n  return getSignStr(e) + bo(t) + \":\" + bo(r) + (a || s ? \":\" + bo(a) + formatSubsecNano(s) : \"\");\n}\n\nfunction formatCalendar(e, n) {\n  return 1 !== n && (n > 1 || 0 === n && e !== l) ? formatCalendarId(e, 2 === n) : \"\";\n}\n\nfunction formatCalendarId(e, n) {\n  return \"[\" + (n ? \"!\" : \"\") + \"u-ca=\" + e + \"]\";\n}\n\nfunction formatSubsecNano(e, n) {\n  let t = padNumber(9, e);\n  return t = void 0 === n ? t.replace(li, \"\") : t.slice(0, n), t ? \".\" + t : \"\";\n}\n\nfunction getSignStr(e) {\n  return e < 0 ? \"-\" : \"+\";\n}\n\nfunction formatDurationNumber(e, n) {\n  return e || n ? e.toLocaleString(\"fullwide\", {\n    useGrouping: 0\n  }) : \"\";\n}\n\nfunction _zonedEpochSlotsToIso(e, n) {\n  const {epochNanoseconds: t} = e, o = (n.R ? n : n(e.timeZone)).R(t), r = epochNanoToIso(t, o);\n  return {\n    calendar: e.calendar,\n    ...r,\n    offsetNanoseconds: o\n  };\n}\n\nfunction getMatchingInstantFor(e, n, t, o = 0, r = 0, i, a) {\n  if (void 0 !== t && 1 === o && (1 === o || a)) {\n    return isoToEpochNanoWithOffset(n, t);\n  }\n  const s = e.I(n);\n  if (void 0 !== t && 3 !== o) {\n    const e = ((e, n, t, o) => {\n      const r = isoToEpochNano(n);\n      o && (t = roundToMinute(t));\n      for (const n of e) {\n        let e = bigNanoToNumber(diffBigNanos(n, r));\n        if (o && (e = roundToMinute(e)), e === t) {\n          return n;\n        }\n      }\n    })(s, n, t, i);\n    if (void 0 !== e) {\n      return e;\n    }\n    if (0 === o) {\n      throw new RangeError(Do);\n    }\n  }\n  return a ? isoToEpochNano(n) : getSingleInstantFor(e, n, r, s);\n}\n\nfunction getSingleInstantFor(e, n, t = 0, o = e.I(n)) {\n  if (1 === o.length) {\n    return o[0];\n  }\n  if (1 === t) {\n    throw new RangeError(To);\n  }\n  if (o.length) {\n    return o[3 === t ? 1 : 0];\n  }\n  const r = isoToEpochNano(n), i = ((e, n) => {\n    const t = e.R(moveBigNano(n, -Uo));\n    return (e => {\n      if (e > Uo) {\n        throw new RangeError(go);\n      }\n      return e;\n    })(e.R(moveBigNano(n, Uo)) - t);\n  })(e, r), a = i * (2 === t ? -1 : 1);\n  return (o = e.I(epochNanoToIso(r, a)))[2 === t ? 0 : o.length - 1];\n}\n\nfunction getStartOfDayInstantFor(e, n) {\n  const t = e.I(n);\n  if (t.length) {\n    return t[0];\n  }\n  const o = moveBigNano(isoToEpochNano(n), -Uo);\n  return e.O(o, 1);\n}\n\nfunction Ye(e, n, t) {\n  return xe(checkEpochNanoInBounds(addBigNanos(n.epochNanoseconds, (e => {\n    if (durationHasDateParts(e)) {\n      throw new RangeError(vo);\n    }\n    return durationFieldsToBigNano(e, 5);\n  })(e ? negateDurationFields(t) : t))));\n}\n\nfunction pe(e, n, t, o, r, i = Object.create(null)) {\n  const a = n(o.timeZone), s = e(o.calendar);\n  return {\n    ...o,\n    ...moveZonedEpochs(a, s, o, t ? negateDurationFields(r) : r, i)\n  };\n}\n\nfunction wt(e, n, t, o, r = Object.create(null)) {\n  const {calendar: i} = t;\n  return jt(moveDateTime(e(i), t, n ? negateDurationFields(o) : o, r), i);\n}\n\nfunction ne(e, n, t, o, r) {\n  const {calendar: i} = t;\n  return W(moveDate(e(i), t, n ? negateDurationFields(o) : o, r), i);\n}\n\nfunction Gt(e, n, t, o, r) {\n  const i = t.calendar, a = e(i);\n  let s = checkIsoDateInBounds(moveToDayOfMonthUnsafe(a, t));\n  n && (o = B(o)), o.sign < 0 && (s = a.P(s, {\n    ...pr,\n    months: 1\n  }), s = moveByDays(s, -1));\n  const c = a.P(s, o, r);\n  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(a, c), i);\n}\n\nfunction at(e, n, t) {\n  return St(moveTime(n, e ? negateDurationFields(t) : t)[0]);\n}\n\nfunction moveZonedEpochs(e, n, t, o, r) {\n  const i = durationFieldsToBigNano(o, 5);\n  let a = t.epochNanoseconds;\n  if (durationHasDateParts(o)) {\n    const s = he(t, e);\n    a = addBigNanos(getSingleInstantFor(e, {\n      ...moveDate(n, s, {\n        ...o,\n        ...hr\n      }, r),\n      ...nn(w, s)\n    }), i);\n  } else {\n    a = addBigNanos(a, i), mt(r);\n  }\n  return {\n    epochNanoseconds: checkEpochNanoInBounds(a)\n  };\n}\n\nfunction moveDateTime(e, n, t, o) {\n  const [r, i] = moveTime(n, t);\n  return checkIsoDateTimeInBounds({\n    ...moveDate(e, n, {\n      ...t,\n      ...hr,\n      days: t.days + i\n    }, o),\n    ...r\n  });\n}\n\nfunction moveDate(e, n, t, o) {\n  if (t.years || t.months || t.weeks) {\n    return e.P(n, t, o);\n  }\n  mt(o);\n  const r = t.days + durationFieldsToBigNano(t, 5)[0];\n  return r ? checkIsoDateInBounds(moveByDays(n, r)) : n;\n}\n\nfunction moveToDayOfMonthUnsafe(e, n, t = 1) {\n  return moveByDays(n, t - e.day(n));\n}\n\nfunction moveTime(e, n) {\n  const [t, o] = durationFieldsToBigNano(n, 5), [r, i] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e) + o);\n  return [ r, t + i ];\n}\n\nfunction moveByDays(e, n) {\n  return n ? {\n    ...e,\n    ...epochMilliToIso(isoToEpochMilli(e) + n * ko)\n  } : e;\n}\n\nfunction createMarkerSystem(e, n, t) {\n  const o = e(t.calendar);\n  return isZonedEpochSlots(t) ? [ t, o, n(t.timeZone) ] : [ {\n    ...t,\n    ...Nt\n  }, o ];\n}\n\nfunction createMarkerToEpochNano(e) {\n  return e ? extractEpochNano : isoToEpochNano;\n}\n\nfunction createMoveMarker(e) {\n  return e ? Pt(moveZonedEpochs, e) : moveDateTime;\n}\n\nfunction createDiffMarkers(e) {\n  return e ? Pt(diffZonedEpochsExact, e) : diffDateTimesExact;\n}\n\nfunction isZonedEpochSlots(e) {\n  return e && e.epochNanoseconds;\n}\n\nfunction isUniformUnit(e, n) {\n  return e <= 6 - (isZonedEpochSlots(n) ? 1 : 0);\n}\n\nfunction E(e, n, t, o, r, i, a) {\n  const s = e(normalizeOptions(a).relativeTo), c = Math.max(getMaxDurationUnit(r), getMaxDurationUnit(i));\n  if (isUniformUnit(c, s)) {\n    return Oe(checkDurationUnits(((e, n, t, o) => {\n      const r = addBigNanos(durationFieldsToBigNano(e), durationFieldsToBigNano(n), o ? -1 : 1);\n      if (!Number.isFinite(r[0])) {\n        throw new RangeError(Io);\n      }\n      return {\n        ...pr,\n        ...nanoToDurationDayTimeFields(r, t)\n      };\n    })(r, i, c, o)));\n  }\n  if (!s) {\n    throw new RangeError(yo);\n  }\n  o && (i = negateDurationFields(i));\n  const [u, f, l] = createMarkerSystem(n, t, s), d = createMoveMarker(l), m = createDiffMarkers(l), p = d(f, u, r);\n  return Oe(m(f, u, d(f, p, i), c));\n}\n\nfunction V(e, n, t, o, r) {\n  const i = getMaxDurationUnit(o), [a, s, c, u, f] = ((e, n, t) => {\n    e = normalizeOptionsOrString(e, Rr);\n    let o = Kr(e);\n    const r = t(e[Ar]);\n    let i = parseRoundingIncInteger(e);\n    const a = ii(e, 7);\n    let s = Jr(e);\n    if (void 0 === o && void 0 === s) {\n      throw new RangeError(Po);\n    }\n    if (null == s && (s = 0), null == o && (o = Math.max(s, n)), checkLargestSmallestUnit(o, s), \n    i = refineRoundingInc(i, s, 1), i > 1 && s > 5 && o !== s) {\n      throw new RangeError(\"For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit\");\n    }\n    return [ o, s, i, a, r ];\n  })(r, i, e), l = Math.max(i, a);\n  if (!f && l <= 6) {\n    return Oe(checkDurationUnits(((e, n, t, o, r) => {\n      const i = roundBigNano(durationFieldsToBigNano(e), t, o, r);\n      return {\n        ...pr,\n        ...nanoToDurationDayTimeFields(i, n)\n      };\n    })(o, a, s, c, u)));\n  }\n  if (!isZonedEpochSlots(f) && !o.sign) {\n    return o;\n  }\n  if (!f) {\n    throw new RangeError(yo);\n  }\n  const [d, m, p] = createMarkerSystem(n, t, f), h = createMarkerToEpochNano(p), g = createMoveMarker(p), D = createDiffMarkers(p), T = g(m, d, o);\n  isZonedEpochSlots(f) || (checkIsoDateTimeInBounds(d), checkIsoDateTimeInBounds(T));\n  let I = D(m, d, T, a);\n  const M = o.sign, N = computeDurationSign(I);\n  if (M && N && M !== N) {\n    throw new RangeError(fo);\n  }\n  return I = roundRelativeDuration(I, h(T), a, s, c, u, m, d, h, g), Oe(I);\n}\n\nfunction Y(e) {\n  return -1 === e.sign ? B(e) : e;\n}\n\nfunction B(e) {\n  return Oe(negateDurationFields(e));\n}\n\nfunction negateDurationFields(e) {\n  const n = {};\n  for (const t of p) {\n    n[t] = -1 * e[t] || 0;\n  }\n  return n;\n}\n\nfunction y(e) {\n  return !e.sign;\n}\n\nfunction computeDurationSign(e, n = p) {\n  let t = 0;\n  for (const o of n) {\n    const n = Math.sign(e[o]);\n    if (n) {\n      if (t && t !== n) {\n        throw new RangeError(No);\n      }\n      t = n;\n    }\n  }\n  return t;\n}\n\nfunction checkDurationUnits(e) {\n  for (const n of dr) {\n    clampEntity(n, e[n], -di, di, 1);\n  }\n  return checkDurationTimeUnit(bigNanoToNumber(durationFieldsToBigNano(e), Ro)), e;\n}\n\nfunction checkDurationTimeUnit(e) {\n  if (!Number.isSafeInteger(e)) {\n    throw new RangeError(Mo);\n  }\n}\n\nfunction durationFieldsToBigNano(e, n = 6) {\n  return givenFieldsToBigNano(e, n, p);\n}\n\nfunction nanoToDurationDayTimeFields(e, n = 6) {\n  const [t, o] = e, r = nanoToGivenFields(o, n, p);\n  if (r[p[n]] += t * (Uo / Ao[n]), !Number.isFinite(r[p[n]])) {\n    throw new RangeError(Io);\n  }\n  return r;\n}\n\nfunction nanoToDurationTimeFields(e, n = 5) {\n  return nanoToGivenFields(e, n, p);\n}\n\nfunction durationHasDateParts(e) {\n  return Boolean(computeDurationSign(e, lr));\n}\n\nfunction getMaxDurationUnit(e) {\n  let n = 9;\n  for (;n > 0 && !e[p[n]]; n--) {}\n  return n;\n}\n\nfunction createSplitTuple(e, n) {\n  return [ e, n ];\n}\n\nfunction computePeriod(e) {\n  const n = Math.floor(e / ci) * ci;\n  return [ n, n + ci ];\n}\n\nfunction We(e) {\n  const n = parseDateTimeLike(e = toStringViaPrimitive(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  let t;\n  if (n.j) {\n    t = 0;\n  } else {\n    if (!n.offset) {\n      throw new RangeError(failedParse(e));\n    }\n    t = parseOffsetNano(n.offset);\n  }\n  return n.timeZone && parseOffsetNanoMaybe(n.timeZone, 1), xe(isoToEpochNanoWithOffset(checkIsoDateTimeFields(n), t));\n}\n\nfunction H(e) {\n  const n = parseDateTimeLike(m(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  if (n.timeZone) {\n    return finalizeZonedDateTime(n, n.offset ? parseOffsetNano(n.offset) : void 0);\n  }\n  if (n.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return finalizeDate(n);\n}\n\nfunction Ae(e, n) {\n  const t = parseDateTimeLike(m(e));\n  if (!t || !t.timeZone) {\n    throw new RangeError(failedParse(e));\n  }\n  const {offset: o} = t, r = o ? parseOffsetNano(o) : void 0, [, i, a] = je(n);\n  return finalizeZonedDateTime(t, r, i, a);\n}\n\nfunction parseOffsetNano(e) {\n  const n = parseOffsetNanoMaybe(e);\n  if (void 0 === n) {\n    throw new RangeError(failedParse(e));\n  }\n  return n;\n}\n\nfunction Bt(e) {\n  const n = parseDateTimeLike(m(e));\n  if (!n || n.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return jt(finalizeDateTime(n));\n}\n\nfunction de(e, n, t) {\n  let o = parseDateTimeLike(m(e));\n  if (!o || o.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return n ? o.calendar === l && (o = -271821 === o.isoYear && 4 === o.isoMonth ? {\n    ...o,\n    isoDay: 20,\n    ...Nt\n  } : {\n    ...o,\n    isoDay: 1,\n    ...Nt\n  }) : t && o.calendar === l && (o = {\n    ...o,\n    isoYear: Br\n  }), W(o.C ? finalizeDateTime(o) : finalizeDate(o));\n}\n\nfunction _t(e, n) {\n  const t = parseYearMonthOnly(m(n));\n  if (t) {\n    return requireIsoCalendar(t), createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields(t)));\n  }\n  const o = de(n, 1);\n  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(e(o.calendar), o));\n}\n\nfunction requireIsoCalendar(e) {\n  if (e.calendar !== l) {\n    throw new RangeError(invalidSubstring(e.calendar));\n  }\n}\n\nfunction xt(e, n) {\n  const t = parseMonthDayOnly(m(n));\n  if (t) {\n    return requireIsoCalendar(t), createPlainMonthDaySlots(checkIsoDateFields(t));\n  }\n  const o = de(n, 0, 1), {calendar: r} = o, i = e(r), [a, s, c] = i.v(o), [u, f] = i.q(a, s), [l, d] = i.G(u, f, c);\n  return createPlainMonthDaySlots(checkIsoDateInBounds(i.V(l, d, c)), r);\n}\n\nfunction ht(e) {\n  let n, t = (e => {\n    const n = Pi.exec(e);\n    return n ? (organizeAnnotationParts(n[10]), organizeTimeParts(n)) : void 0;\n  })(m(e));\n  if (!t) {\n    if (t = parseDateTimeLike(e), !t) {\n      throw new RangeError(failedParse(e));\n    }\n    if (!t.C) {\n      throw new RangeError(failedParse(e));\n    }\n    if (t.j) {\n      throw new RangeError(invalidSubstring(\"Z\"));\n    }\n    requireIsoCalendar(t);\n  }\n  if ((n = parseYearMonthOnly(e)) && isIsoDateFieldsValid(n)) {\n    throw new RangeError(failedParse(e));\n  }\n  if ((n = parseMonthDayOnly(e)) && isIsoDateFieldsValid(n)) {\n    throw new RangeError(failedParse(e));\n  }\n  return St(constrainIsoTimeFields(t, 1));\n}\n\nfunction R(e) {\n  const n = (e => {\n    const n = Fi.exec(e);\n    return n ? (e => {\n      function parseUnit(e, r, i) {\n        let a = 0, s = 0;\n        if (i && ([a, o] = divModFloor(o, Ao[i])), void 0 !== e) {\n          if (t) {\n            throw new RangeError(invalidSubstring(e));\n          }\n          s = (e => {\n            const n = parseInt(e);\n            if (!Number.isFinite(n)) {\n              throw new RangeError(invalidSubstring(e));\n            }\n            return n;\n          })(e), n = 1, r && (o = parseSubsecNano(r) * (Ao[i] / Ro), t = 1);\n        }\n        return a + s;\n      }\n      let n = 0, t = 0, o = 0, r = {\n        ...zipProps(p, [ parseUnit(e[2]), parseUnit(e[3]), parseUnit(e[4]), parseUnit(e[5]), parseUnit(e[6], e[7], 5), parseUnit(e[8], e[9], 4), parseUnit(e[10], e[11], 3) ]),\n        ...nanoToGivenFields(o, 2, p)\n      };\n      if (!n) {\n        throw new RangeError(noValidFields(p));\n      }\n      return parseSign(e[1]) < 0 && (r = negateDurationFields(r)), r;\n    })(n) : void 0;\n  })(m(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  return Oe(checkDurationUnits(n));\n}\n\nfunction f(e) {\n  const n = parseDateTimeLike(e) || parseYearMonthOnly(e) || parseMonthDayOnly(e);\n  return n ? n.calendar : e;\n}\n\nfunction Z(e) {\n  const n = parseDateTimeLike(e);\n  return n && (n.timeZone || n.j && si || n.offset) || e;\n}\n\nfunction finalizeZonedDateTime(e, n, t = 0, o = 0) {\n  const r = M(e.timeZone), i = L(r);\n  let a;\n  return checkIsoDateTimeFields(e), a = e.C ? getMatchingInstantFor(i, e, n, t, o, !i.$, e.j) : getStartOfDayInstantFor(i, e), \n  _e(a, r, u(e.calendar));\n}\n\nfunction finalizeDateTime(e) {\n  return resolveSlotsCalendar(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e)));\n}\n\nfunction finalizeDate(e) {\n  return resolveSlotsCalendar(checkIsoDateInBounds(checkIsoDateFields(e)));\n}\n\nfunction resolveSlotsCalendar(e) {\n  return {\n    ...e,\n    calendar: u(e.calendar)\n  };\n}\n\nfunction parseDateTimeLike(e) {\n  const n = vi.exec(e);\n  return n ? (e => {\n    const n = e[10], t = \"Z\" === (n || \"\").toUpperCase();\n    return {\n      isoYear: organizeIsoYearParts(e),\n      isoMonth: parseInt(e[4]),\n      isoDay: parseInt(e[5]),\n      ...organizeTimeParts(e.slice(5)),\n      ...organizeAnnotationParts(e[16]),\n      C: Boolean(e[6]),\n      j: t,\n      offset: t ? void 0 : n\n    };\n  })(n) : void 0;\n}\n\nfunction parseYearMonthOnly(e) {\n  const n = Ni.exec(e);\n  return n ? (e => ({\n    isoYear: organizeIsoYearParts(e),\n    isoMonth: parseInt(e[4]),\n    isoDay: 1,\n    ...organizeAnnotationParts(e[5])\n  }))(n) : void 0;\n}\n\nfunction parseMonthDayOnly(e) {\n  const n = yi.exec(e);\n  return n ? (e => ({\n    isoYear: Br,\n    isoMonth: parseInt(e[1]),\n    isoDay: parseInt(e[2]),\n    ...organizeAnnotationParts(e[3])\n  }))(n) : void 0;\n}\n\nfunction parseOffsetNanoMaybe(e, n) {\n  const t = Ei.exec(e);\n  return t ? ((e, n) => {\n    const t = e[4] || e[5];\n    if (n && t) {\n      throw new RangeError(invalidSubstring(t));\n    }\n    return (e => {\n      if (Math.abs(e) >= Uo) {\n        throw new RangeError(ho);\n      }\n      return e;\n    })((parseInt0(e[2]) * zo + parseInt0(e[3]) * Zo + parseInt0(e[4]) * Ro + parseSubsecNano(e[5] || \"\")) * parseSign(e[1]));\n  })(t, n) : void 0;\n}\n\nfunction organizeIsoYearParts(e) {\n  const n = parseSign(e[1]), t = parseInt(e[2] || e[3]);\n  if (n < 0 && !t) {\n    throw new RangeError(invalidSubstring(-0));\n  }\n  return n * t;\n}\n\nfunction organizeTimeParts(e) {\n  const n = parseInt0(e[3]);\n  return {\n    ...nanoToIsoTimeAndDay(parseSubsecNano(e[4] || \"\"))[0],\n    isoHour: parseInt0(e[1]),\n    isoMinute: parseInt0(e[2]),\n    isoSecond: 60 === n ? 59 : n\n  };\n}\n\nfunction organizeAnnotationParts(e) {\n  let n, t;\n  const o = [];\n  if (e.replace(Si, ((e, r, i) => {\n    const a = Boolean(r), [s, c] = i.split(\"=\").reverse();\n    if (c) {\n      if (\"u-ca\" === c) {\n        o.push(s), n || (n = a);\n      } else if (a || /[A-Z]/.test(c)) {\n        throw new RangeError(invalidSubstring(e));\n      }\n    } else {\n      if (t) {\n        throw new RangeError(invalidSubstring(e));\n      }\n      t = s;\n    }\n    return \"\";\n  })), o.length > 1 && n) {\n    throw new RangeError(invalidSubstring(e));\n  }\n  return {\n    timeZone: t,\n    calendar: o[0] || l\n  };\n}\n\nfunction parseSubsecNano(e) {\n  return parseInt(e.padEnd(9, \"0\"));\n}\n\nfunction createRegExp(e) {\n  return new RegExp(`^${e}$`, \"i\");\n}\n\nfunction parseSign(e) {\n  return e && \"+\" !== e ? -1 : 1;\n}\n\nfunction parseInt0(e) {\n  return void 0 === e ? 0 : parseInt(e);\n}\n\nfunction Ze(e) {\n  return M(m(e));\n}\n\nfunction M(e) {\n  const n = getTimeZoneEssence(e);\n  return \"number\" == typeof n ? Se(n) : n ? (e => {\n    if (Oi.test(e)) {\n      throw new RangeError(F(e));\n    }\n    if (bi.test(e)) {\n      throw new RangeError(po);\n    }\n    return e.toLowerCase().split(\"/\").map(((e, n) => (e.length <= 3 || /\\d/.test(e)) && !/etc|yap/.test(e) ? e.toUpperCase() : e.replace(/baja|dumont|[a-z]+/g, ((e, t) => e.length <= 2 && !n || \"in\" === e || \"chat\" === e ? e.toUpperCase() : e.length > 2 || !t ? capitalize(e).replace(/island|noronha|murdo|rivadavia|urville/, capitalize) : e)))).join(\"/\");\n  })(e) : si;\n}\n\nfunction getTimeZoneAtomic(e) {\n  const n = getTimeZoneEssence(e);\n  return \"number\" == typeof n ? n : n ? n.resolvedOptions().timeZone : si;\n}\n\nfunction getTimeZoneEssence(e) {\n  const n = parseOffsetNanoMaybe(e = e.toUpperCase(), 1);\n  return void 0 !== n ? n : e !== si ? wi(e) : void 0;\n}\n\nfunction Ke(e, n) {\n  return compareBigNanos(e.epochNanoseconds, n.epochNanoseconds);\n}\n\nfunction Be(e, n) {\n  return compareBigNanos(e.epochNanoseconds, n.epochNanoseconds);\n}\n\nfunction K(e, n, t, o, r, i) {\n  const a = e(normalizeOptions(i).relativeTo), s = Math.max(getMaxDurationUnit(o), getMaxDurationUnit(r));\n  if (allPropsEqual(p, o, r)) {\n    return 0;\n  }\n  if (isUniformUnit(s, a)) {\n    return compareBigNanos(durationFieldsToBigNano(o), durationFieldsToBigNano(r));\n  }\n  if (!a) {\n    throw new RangeError(yo);\n  }\n  const [c, u, f] = createMarkerSystem(n, t, a), l = createMarkerToEpochNano(f), d = createMoveMarker(f);\n  return compareBigNanos(l(d(u, c, o)), l(d(u, c, r)));\n}\n\nfunction Yt(e, n) {\n  return te(e, n) || Dt(e, n);\n}\n\nfunction te(e, n) {\n  return compareNumbers(isoToEpochMilli(e), isoToEpochMilli(n));\n}\n\nfunction Dt(e, n) {\n  return compareNumbers(isoTimeFieldsToNano(e), isoTimeFieldsToNano(n));\n}\n\nfunction Ve(e, n) {\n  return !Ke(e, n);\n}\n\nfunction Ce(e, n) {\n  return !Be(e, n) && !!isTimeZoneIdsEqual(e.timeZone, n.timeZone) && e.calendar === n.calendar;\n}\n\nfunction Ct(e, n) {\n  return !Yt(e, n) && e.calendar === n.calendar;\n}\n\nfunction re(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction $t(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction Lt(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction st(e, n) {\n  return !Dt(e, n);\n}\n\nfunction isTimeZoneIdsEqual(e, n) {\n  if (e === n) {\n    return 1;\n  }\n  try {\n    return getTimeZoneAtomic(e) === getTimeZoneAtomic(n);\n  } catch (e) {}\n}\n\nfunction Ee(e, n, t, o) {\n  const r = refineDiffOptions(e, o, 3, 5), i = diffEpochNanos(n.epochNanoseconds, t.epochNanoseconds, ...r);\n  return Oe(e ? negateDurationFields(i) : i);\n}\n\nfunction we(e, n, t, o, r, i) {\n  const a = getCommonCalendarId(o.calendar, r.calendar), [s, c, u, f] = refineDiffOptions(t, i, 5), l = o.epochNanoseconds, d = r.epochNanoseconds, m = compareBigNanos(d, l);\n  let p;\n  if (m) {\n    if (s < 6) {\n      p = diffEpochNanos(l, d, s, c, u, f);\n    } else {\n      const t = n(((e, n) => {\n        if (!isTimeZoneIdsEqual(e, n)) {\n          throw new RangeError(mo);\n        }\n        return e;\n      })(o.timeZone, r.timeZone)), l = e(a);\n      p = diffZonedEpochsBig(l, t, o, r, m, s, i), p = roundRelativeDuration(p, d, s, c, u, f, l, o, extractEpochNano, Pt(moveZonedEpochs, t));\n    }\n  } else {\n    p = pr;\n  }\n  return Oe(t ? negateDurationFields(p) : p);\n}\n\nfunction It(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar), [a, s, c, u] = refineDiffOptions(n, r, 6), f = isoToEpochNano(t), l = isoToEpochNano(o), d = compareBigNanos(l, f);\n  let m;\n  if (d) {\n    if (a <= 6) {\n      m = diffEpochNanos(f, l, a, s, c, u);\n    } else {\n      const n = e(i);\n      m = diffDateTimesBig(n, t, o, d, a, r), m = roundRelativeDuration(m, l, a, s, c, u, n, t, isoToEpochNano, moveDateTime);\n    }\n  } else {\n    m = pr;\n  }\n  return Oe(n ? negateDurationFields(m) : m);\n}\n\nfunction oe(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar);\n  return diffDateLike(n, (() => e(i)), t, o, ...refineDiffOptions(n, r, 6, 9, 6));\n}\n\nfunction zt(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar), a = refineDiffOptions(n, r, 9, 9, 8), s = e(i), c = moveToDayOfMonthUnsafe(s, t), u = moveToDayOfMonthUnsafe(s, o);\n  return c.isoYear === u.isoYear && c.isoMonth === u.isoMonth && c.isoDay === u.isoDay ? Oe(pr) : diffDateLike(n, (() => s), checkIsoDateInBounds(c), checkIsoDateInBounds(u), ...a, 8);\n}\n\nfunction diffDateLike(e, n, t, o, r, i, a, s, c = 6) {\n  const u = isoToEpochNano(t), f = isoToEpochNano(o);\n  if (void 0 === u || void 0 === f) {\n    throw new RangeError(Io);\n  }\n  let l;\n  if (compareBigNanos(f, u)) {\n    if (6 === r) {\n      l = diffEpochNanos(u, f, r, i, a, s);\n    } else {\n      const e = n();\n      l = e.N(t, o, r), i === c && 1 === a || (l = roundRelativeDuration(l, f, r, i, a, s, e, t, isoToEpochNano, moveDate));\n    }\n  } else {\n    l = pr;\n  }\n  return Oe(e ? negateDurationFields(l) : l);\n}\n\nfunction it(e, n, t, o) {\n  const [r, i, a, s] = refineDiffOptions(e, o, 5, 5), c = roundByInc(diffTimes(n, t), computeNanoInc(i, a), s), u = {\n    ...pr,\n    ...nanoToDurationTimeFields(c, r)\n  };\n  return Oe(e ? negateDurationFields(u) : u);\n}\n\nfunction diffZonedEpochsExact(e, n, t, o, r, i) {\n  const a = compareBigNanos(o.epochNanoseconds, t.epochNanoseconds);\n  return a ? r < 6 ? diffEpochNanosExact(t.epochNanoseconds, o.epochNanoseconds, r) : diffZonedEpochsBig(n, e, t, o, a, r, i) : pr;\n}\n\nfunction diffDateTimesExact(e, n, t, o, r) {\n  const i = isoToEpochNano(n), a = isoToEpochNano(t), s = compareBigNanos(a, i);\n  return s ? o <= 6 ? diffEpochNanosExact(i, a, o) : diffDateTimesBig(e, n, t, s, o, r) : pr;\n}\n\nfunction diffZonedEpochsBig(e, n, t, o, r, i, a) {\n  const [s, c, u] = ((e, n, t, o) => {\n    function updateMid() {\n      return f = {\n        ...moveByDays(a, c++ * -o),\n        ...i\n      }, l = getSingleInstantFor(e, f), compareBigNanos(s, l) === -o;\n    }\n    const r = he(n, e), i = nn(w, r), a = he(t, e), s = t.epochNanoseconds;\n    let c = 0;\n    const u = diffTimes(r, a);\n    let f, l;\n    if (Math.sign(u) === -o && c++, updateMid() && (-1 === o || updateMid())) {\n      throw new RangeError(fo);\n    }\n    const d = bigNanoToNumber(diffBigNanos(l, s));\n    return [ r, f, d ];\n  })(n, t, o, r);\n  var f, l;\n  return {\n    ...6 === i ? (f = s, l = c, {\n      ...pr,\n      days: diffDays(f, l)\n    }) : e.N(s, c, i, a),\n    ...nanoToDurationTimeFields(u)\n  };\n}\n\nfunction diffDateTimesBig(e, n, t, o, r, i) {\n  const [a, s, c] = ((e, n, t) => {\n    let o = n, r = diffTimes(e, n);\n    return Math.sign(r) === -t && (o = moveByDays(n, -t), r += Uo * t), [ e, o, r ];\n  })(n, t, o);\n  return {\n    ...e.N(a, s, r, i),\n    ...nanoToDurationTimeFields(c)\n  };\n}\n\nfunction diffEpochNanos(e, n, t, o, r, i) {\n  return {\n    ...pr,\n    ...nanoToDurationDayTimeFields(roundBigNano(diffBigNanos(e, n), o, r, i), t)\n  };\n}\n\nfunction diffEpochNanosExact(e, n, t) {\n  return {\n    ...pr,\n    ...nanoToDurationDayTimeFields(diffBigNanos(e, n), t)\n  };\n}\n\nfunction diffDays(e, n) {\n  return diffEpochMilliByDay(isoToEpochMilli(e), isoToEpochMilli(n));\n}\n\nfunction diffEpochMilliByDay(e, n) {\n  return Math.trunc((n - e) / ko);\n}\n\nfunction diffTimes(e, n) {\n  return isoTimeFieldsToNano(n) - isoTimeFieldsToNano(e);\n}\n\nfunction getCommonCalendarId(e, n) {\n  if (e !== n) {\n    throw new RangeError(lo);\n  }\n  return e;\n}\n\nfunction computeNativeWeekOfYear(e) {\n  return this.m(e)[0];\n}\n\nfunction computeNativeYearOfWeek(e) {\n  return this.m(e)[1];\n}\n\nfunction computeNativeDayOfYear(e) {\n  const [n] = this.v(e);\n  return diffEpochMilliByDay(this.p(n), isoToEpochMilli(e)) + 1;\n}\n\nfunction parseMonthCode(e) {\n  const n = Bi.exec(e);\n  if (!n) {\n    throw new RangeError(invalidMonthCode(e));\n  }\n  return [ parseInt(n[1]), Boolean(n[2]) ];\n}\n\nfunction formatMonthCode(e, n) {\n  return \"M\" + bo(e) + (n ? \"L\" : \"\");\n}\n\nfunction monthCodeNumberToMonth(e, n, t) {\n  return e + (n || t && e >= t ? 1 : 0);\n}\n\nfunction monthToMonthCodeNumber(e, n) {\n  return e - (n && e >= n ? 1 : 0);\n}\n\nfunction eraYearToYear(e, n) {\n  return (n + e) * (Math.sign(n) || 1) || 0;\n}\n\nfunction getCalendarEraOrigins(e) {\n  return ir[getCalendarIdBase(e)];\n}\n\nfunction getCalendarLeapMonthMeta(e) {\n  return sr[getCalendarIdBase(e)];\n}\n\nfunction getCalendarIdBase(e) {\n  return computeCalendarIdBase(e.id || l);\n}\n\nfunction createIntlCalendar(e) {\n  function epochMilliToIntlFields(e) {\n    return ((e, n) => ({\n      ...parseIntlYear(e, n),\n      o: e.month,\n      day: parseInt(e.day)\n    }))(hashIntlFormatParts(n, e), t);\n  }\n  const n = Ci(e), t = computeCalendarIdBase(e);\n  return {\n    id: e,\n    h: createIntlFieldCache(epochMilliToIntlFields),\n    l: createIntlYearDataCache(epochMilliToIntlFields)\n  };\n}\n\nfunction createIntlFieldCache(e) {\n  return on((n => {\n    const t = isoToEpochMilli(n);\n    return e(t);\n  }), WeakMap);\n}\n\nfunction createIntlYearDataCache(e) {\n  const n = e(0).year - Or;\n  return on((t => {\n    let o, r = isoArgsToEpochMilli(t - n), i = 0;\n    const a = [], s = [];\n    do {\n      r += 400 * ko;\n    } while ((o = e(r)).year <= t);\n    do {\n      if (r += (1 - o.day) * ko, o.year === t && (a.push(r), s.push(o.o)), r -= ko, ++i > 100 || r < -Pr) {\n        throw new RangeError(fo);\n      }\n    } while ((o = e(r)).year >= t);\n    return {\n      i: a.reverse(),\n      u: Fo(s.reverse())\n    };\n  }));\n}\n\nfunction parseIntlYear(e, n) {\n  let t, o, r = parseIntlPartsYear(e);\n  if (e.era) {\n    const i = ir[n], a = ar[n] || {};\n    void 0 !== i && (t = \"islamic\" === n ? \"ah\" : e.era.normalize(\"NFD\").toLowerCase().replace(/[^a-z0-9]/g, \"\"), \n    \"bc\" === t || \"b\" === t ? t = \"bce\" : \"ad\" === t || \"a\" === t ? t = \"ce\" : \"beforeroc\" === t && (t = \"broc\"), \n    t = a[t] || t, o = r, r = eraYearToYear(o, i[t] || 0));\n  }\n  return {\n    era: t,\n    eraYear: o,\n    year: r\n  };\n}\n\nfunction parseIntlPartsYear(e) {\n  return parseInt(e.relatedYear || e.year);\n}\n\nfunction computeIntlDateParts(e) {\n  const {year: n, o: t, day: o} = this.h(e), {u: r} = this.l(n);\n  return [ n, r[t] + 1, o ];\n}\n\nfunction computeIntlEpochMilli(e, n = 1, t = 1) {\n  return this.l(e).i[n - 1] + (t - 1) * ko;\n}\n\nfunction computeIntlMonthCodeParts(e, n) {\n  const t = computeIntlLeapMonth.call(this, e);\n  return [ monthToMonthCodeNumber(n, t), t === n ];\n}\n\nfunction computeIntlLeapMonth(e) {\n  const n = queryMonthStrings(this, e), t = queryMonthStrings(this, e - 1), o = n.length;\n  if (o > t.length) {\n    const e = getCalendarLeapMonthMeta(this);\n    if (e < 0) {\n      return -e;\n    }\n    for (let e = 0; e < o; e++) {\n      if (n[e] !== t[e]) {\n        return e + 1;\n      }\n    }\n  }\n}\n\nfunction computeIntlDaysInYear(e) {\n  return diffEpochMilliByDay(computeIntlEpochMilli.call(this, e), computeIntlEpochMilli.call(this, e + 1));\n}\n\nfunction computeIntlDaysInMonth(e, n) {\n  const {i: t} = this.l(e);\n  let o = n + 1, r = t;\n  return o > t.length && (o = 1, r = this.l(e + 1).i), diffEpochMilliByDay(t[n - 1], r[o - 1]);\n}\n\nfunction computeIntlMonthsInYear(e) {\n  return this.l(e).i.length;\n}\n\nfunction computeIntlEraParts(e) {\n  const n = this.h(e);\n  return [ n.era, n.eraYear ];\n}\n\nfunction queryMonthStrings(e, n) {\n  return Object.keys(e.l(n).u);\n}\n\nfunction Mt(e) {\n  return u(m(e));\n}\n\nfunction u(e) {\n  if ((e = e.toLowerCase()) !== l && e !== or) {\n    const n = Ci(e).resolvedOptions().calendar;\n    if (computeCalendarIdBase(e) !== computeCalendarIdBase(n)) {\n      throw new RangeError(c(e));\n    }\n    return n;\n  }\n  return e;\n}\n\nfunction computeCalendarIdBase(e) {\n  return \"islamicc\" === e && (e = \"islamic\"), e.split(\"-\")[0];\n}\n\nfunction createNativeOpsCreator(e, n) {\n  return t => t === l ? e : t === or || t === rr ? Object.assign(Object.create(e), {\n    id: t\n  }) : Object.assign(Object.create(n), ki(t));\n}\n\nfunction $(e, n, t, o) {\n  const r = refineCalendarFields(t, o, Xo, [], xo);\n  if (void 0 !== r.timeZone) {\n    const o = t.F(r), i = refineTimeBag(r), a = e(r.timeZone);\n    return {\n      epochNanoseconds: getMatchingInstantFor(n(a), {\n        ...o,\n        ...i\n      }, void 0 !== r.offset ? parseOffsetNano(r.offset) : void 0),\n      timeZone: a\n    };\n  }\n  return {\n    ...t.F(r),\n    ...Nt\n  };\n}\n\nfunction Ne(e, n, t, o, r, i) {\n  const a = refineCalendarFields(t, r, Xo, jo, xo), s = e(a.timeZone), [c, u, f] = je(i), l = t.F(a, fabricateOverflowOptions(c)), d = refineTimeBag(a, c);\n  return _e(getMatchingInstantFor(n(s), {\n    ...l,\n    ...d\n  }, void 0 !== a.offset ? parseOffsetNano(a.offset) : void 0, u, f), s, o);\n}\n\nfunction At(e, n, t) {\n  const o = refineCalendarFields(e, n, Xo, [], O), r = mt(t);\n  return jt(checkIsoDateTimeInBounds({\n    ...e.F(o, fabricateOverflowOptions(r)),\n    ...refineTimeBag(o, r)\n  }));\n}\n\nfunction me(e, n, t, o = []) {\n  const r = refineCalendarFields(e, n, Xo, o);\n  return e.F(r, t);\n}\n\nfunction Xt(e, n, t, o) {\n  const r = refineCalendarFields(e, n, Ko, o);\n  return e.K(r, t);\n}\n\nfunction Rt(e, n, t, o) {\n  const r = refineCalendarFields(e, t, Xo, Jo);\n  return n && void 0 !== r.month && void 0 === r.monthCode && void 0 === r.year && (r.year = Br), \n  e._(r, o);\n}\n\nfunction Tt(e, n) {\n  return St(refineTimeBag(refineFields(e, qo, [], 1), mt(n)));\n}\n\nfunction q(e) {\n  const n = refineFields(e, ur);\n  return Oe(checkDurationUnits({\n    ...pr,\n    ...n\n  }));\n}\n\nfunction refineCalendarFields(e, n, t, o = [], r = []) {\n  return refineFields(n, [ ...e.fields(t), ...r ].sort(), o);\n}\n\nfunction refineFields(e, n, t, o = !t) {\n  const r = {};\n  let i, a = 0;\n  for (const o of n) {\n    if (o === i) {\n      throw new RangeError(duplicateFields(o));\n    }\n    if (\"constructor\" === o || \"__proto__\" === o) {\n      throw new RangeError(forbiddenField(o));\n    }\n    let n = e[o];\n    if (void 0 !== n) {\n      a = 1, Li[o] && (n = Li[o](n, o)), r[o] = n;\n    } else if (t) {\n      if (t.includes(o)) {\n        throw new TypeError(missingField(o));\n      }\n      r[o] = tr[o];\n    }\n    i = o;\n  }\n  if (o && !a) {\n    throw new TypeError(noValidFields(n));\n  }\n  return r;\n}\n\nfunction refineTimeBag(e, n) {\n  return constrainIsoTimeFields(xi({\n    ...tr,\n    ...e\n  }), n);\n}\n\nfunction De(e, n, t, o, r) {\n  const {calendar: i, timeZone: a} = t, s = e(i), c = n(a), u = [ ...s.fields(Xo), ...Lo ].sort(), f = (e => {\n    const n = he(e, L), t = Se(n.offsetNanoseconds), o = ji(e.calendar), [r, i, a] = o.v(n), [s, c] = o.q(r, i), u = formatMonthCode(s, c);\n    return {\n      ...$i(n),\n      year: r,\n      monthCode: u,\n      day: a,\n      offset: t\n    };\n  })(t), l = refineFields(o, u), d = s.k(f, l), m = {\n    ...f,\n    ...l\n  }, [p, h, g] = je(r, 2);\n  return _e(getMatchingInstantFor(c, {\n    ...s.F(d, fabricateOverflowOptions(p)),\n    ...constrainIsoTimeFields(xi(m), p)\n  }, parseOffsetNano(m.offset), h, g), a, i);\n}\n\nfunction gt(e, n, t, o) {\n  const r = e(n.calendar), i = [ ...r.fields(Xo), ...O ].sort(), a = {\n    ...computeDateEssentials(s = n),\n    hour: s.isoHour,\n    minute: s.isoMinute,\n    second: s.isoSecond,\n    millisecond: s.isoMillisecond,\n    microsecond: s.isoMicrosecond,\n    nanosecond: s.isoNanosecond\n  };\n  var s;\n  const c = refineFields(t, i), u = mt(o), f = r.k(a, c), l = {\n    ...a,\n    ...c\n  };\n  return jt(checkIsoDateTimeInBounds({\n    ...r.F(f, fabricateOverflowOptions(u)),\n    ...constrainIsoTimeFields(xi(l), u)\n  }));\n}\n\nfunction ee(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Xo).sort(), a = computeDateEssentials(n), s = refineFields(t, i), c = r.k(a, s);\n  return r.F(c, o);\n}\n\nfunction Wt(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Ko).sort(), a = (e => {\n    const n = ji(e.calendar), [t, o] = n.v(e), [r, i] = n.q(t, o);\n    return {\n      year: t,\n      monthCode: formatMonthCode(r, i)\n    };\n  })(n), s = refineFields(t, i), c = r.k(a, s);\n  return r.K(c, o);\n}\n\nfunction Et(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Xo).sort(), a = (e => {\n    const n = ji(e.calendar), [t, o, r] = n.v(e), [i, a] = n.q(t, o);\n    return {\n      monthCode: formatMonthCode(i, a),\n      day: r\n    };\n  })(n), s = refineFields(t, i), c = r.k(a, s);\n  return r._(c, o);\n}\n\nfunction rt(e, n, t) {\n  return St(((e, n, t) => refineTimeBag({\n    ...nn(qo, e),\n    ...refineFields(n, qo)\n  }, mt(t)))(e, n, t));\n}\n\nfunction A(e, n) {\n  return Oe((t = e, o = n, checkDurationUnits({\n    ...t,\n    ...refineFields(o, ur)\n  })));\n  var t, o;\n}\n\nfunction convertToIso(e, n, t, o, r) {\n  n = nn(t = e.fields(t), n), o = refineFields(o, r = e.fields(r), []);\n  let i = e.k(n, o);\n  return i = refineFields(i, [ ...t, ...r ].sort(), []), e.F(i);\n}\n\nfunction refineYear(e, n) {\n  const t = getCalendarEraOrigins(e), o = ar[e.id || \"\"] || {};\n  let {era: r, eraYear: i, year: a} = n;\n  if (void 0 !== r || void 0 !== i) {\n    if (void 0 === r || void 0 === i) {\n      throw new TypeError(io);\n    }\n    if (!t) {\n      throw new RangeError(ro);\n    }\n    const e = t[o[r] || r];\n    if (void 0 === e) {\n      throw new RangeError(invalidEra(r));\n    }\n    const n = eraYearToYear(i, e);\n    if (void 0 !== a && a !== n) {\n      throw new RangeError(ao);\n    }\n    a = n;\n  } else if (void 0 === a) {\n    throw new TypeError(missingYear(t));\n  }\n  return a;\n}\n\nfunction refineMonth(e, n, t, o) {\n  let {month: r, monthCode: i} = n;\n  if (void 0 !== i) {\n    const n = ((e, n, t, o) => {\n      const r = e.L(t), [i, a] = parseMonthCode(n);\n      let s = monthCodeNumberToMonth(i, a, r);\n      if (a) {\n        const n = getCalendarLeapMonthMeta(e);\n        if (void 0 === n) {\n          throw new RangeError(uo);\n        }\n        if (n > 0) {\n          if (s > n) {\n            throw new RangeError(uo);\n          }\n          if (void 0 === r) {\n            if (1 === o) {\n              throw new RangeError(uo);\n            }\n            s--;\n          }\n        } else {\n          if (s !== -n) {\n            throw new RangeError(uo);\n          }\n          if (void 0 === r && 1 === o) {\n            throw new RangeError(uo);\n          }\n        }\n      }\n      return s;\n    })(e, i, t, o);\n    if (void 0 !== r && r !== n) {\n      throw new RangeError(so);\n    }\n    r = n, o = 1;\n  } else if (void 0 === r) {\n    throw new TypeError(co);\n  }\n  return clampEntity(\"month\", r, 1, e.B(t), o);\n}\n\nfunction refineDay(e, n, t, o, r) {\n  return clampProp(n, \"day\", 1, e.U(o, t), r);\n}\n\nfunction spliceFields(e, n, t, o) {\n  let r = 0;\n  const i = [];\n  for (const e of t) {\n    void 0 !== n[e] ? r = 1 : i.push(e);\n  }\n  if (Object.assign(e, n), r) {\n    for (const n of o || i) {\n      delete e[n];\n    }\n  }\n}\n\nfunction computeDateEssentials(e) {\n  const n = ji(e.calendar), [t, o, r] = n.v(e), [i, a] = n.q(t, o);\n  return {\n    year: t,\n    monthCode: formatMonthCode(i, a),\n    day: r\n  };\n}\n\nfunction qe(e) {\n  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e))));\n}\n\nfunction ye(e, n, t, o, r = l) {\n  return _e(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(t))), n(o), e(r));\n}\n\nfunction Zt(n, t, o, r, i = 0, a = 0, s = 0, c = 0, u = 0, f = 0, d = l) {\n  return jt(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e(toInteger, zipProps(Tr, [ t, o, r, i, a, s, c, u, f ])))), n(d));\n}\n\nfunction ue(n, t, o, r, i = l) {\n  return W(checkIsoDateInBounds(checkIsoDateFields(e(toInteger, {\n    isoYear: t,\n    isoMonth: o,\n    isoDay: r\n  }))), n(i));\n}\n\nfunction Qt(e, n, t, o = l, r = 1) {\n  const i = toInteger(n), a = toInteger(t), s = e(o);\n  return createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields({\n    isoYear: i,\n    isoMonth: a,\n    isoDay: toInteger(r)\n  })), s);\n}\n\nfunction kt(e, n, t, o = l, r = Br) {\n  const i = toInteger(n), a = toInteger(t), s = e(o);\n  return createPlainMonthDaySlots(checkIsoDateInBounds(checkIsoDateFields({\n    isoYear: toInteger(r),\n    isoMonth: i,\n    isoDay: a\n  })), s);\n}\n\nfunction ut(n = 0, t = 0, o = 0, r = 0, i = 0, a = 0) {\n  return St(constrainIsoTimeFields(e(toInteger, zipProps(w, [ n, t, o, r, i, a ])), 1));\n}\n\nfunction j(n = 0, t = 0, o = 0, r = 0, i = 0, a = 0, s = 0, c = 0, u = 0, f = 0) {\n  return Oe(checkDurationUnits(e(toStrictInteger, zipProps(p, [ n, t, o, r, i, a, s, c, u, f ]))));\n}\n\nfunction Je(e, n, t = l) {\n  return _e(e.epochNanoseconds, n, t);\n}\n\nfunction be(e) {\n  return xe(e.epochNanoseconds);\n}\n\nfunction yt(e, n) {\n  return jt(he(n, e));\n}\n\nfunction fe(e, n) {\n  return W(he(n, e));\n}\n\nfunction dt(e, n) {\n  return St(he(n, e));\n}\n\nfunction bt(e, n, t, o) {\n  const r = ((e, n, t, o) => {\n    const r = (e => ei(normalizeOptions(e)))(o);\n    return getSingleInstantFor(e(n), t, r);\n  })(e, t, n, o);\n  return _e(checkEpochNanoInBounds(r), t, n.calendar);\n}\n\nfunction ae(e, n, t, o, r) {\n  const i = e(r.timeZone), a = r.plainTime, s = void 0 !== a ? n(a) : void 0, c = t(i);\n  let u;\n  return u = s ? getSingleInstantFor(c, {\n    ...o,\n    ...s\n  }) : getStartOfDayInstantFor(c, {\n    ...o,\n    ...Nt\n  }), _e(u, i, o.calendar);\n}\n\nfunction ie(e, n = Nt) {\n  return jt(checkIsoDateTimeInBounds({\n    ...e,\n    ...n\n  }));\n}\n\nfunction le(e, n, t) {\n  return ((e, n) => {\n    const t = refineCalendarFields(e, n, Qo);\n    return e.K(t, void 0);\n  })(e(n.calendar), t);\n}\n\nfunction se(e, n, t) {\n  return ((e, n) => {\n    const t = refineCalendarFields(e, n, nr);\n    return e._(t);\n  })(e(n.calendar), t);\n}\n\nfunction Ht(e, n, t, o) {\n  return ((e, n, t) => convertToIso(e, n, Qo, requireObjectLike(t), Jo))(e(n.calendar), t, o);\n}\n\nfunction Vt(e, n, t, o) {\n  return ((e, n, t) => convertToIso(e, n, nr, requireObjectLike(t), Go))(e(n.calendar), t, o);\n}\n\nfunction $e(e) {\n  return xe(checkEpochNanoInBounds(Ge(toStrictInteger(e), Qe)));\n}\n\nfunction He(e) {\n  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e))));\n}\n\nfunction createOptionsTransformer(e, n, t) {\n  const o = new Set(t);\n  return (r, i) => {\n    const a = t && hasAnyPropsByName(r, t);\n    if (!hasAnyPropsByName(r = ((e, n) => {\n      const t = {};\n      for (const o in n) {\n        e.has(o) || (t[o] = n[o]);\n      }\n      return t;\n    })(o, r), e)) {\n      if (i && a) {\n        throw new TypeError(\"Invalid formatting options\");\n      }\n      r = {\n        ...n,\n        ...r\n      };\n    }\n    return t && (r.timeZone = si, [ \"full\", \"long\" ].includes(r.J) && (r.J = \"medium\")), \n    r;\n  };\n}\n\nfunction Q(e, n = an, t = 0) {\n  const [o, , , r] = e;\n  return (i, a = Na, ...s) => {\n    const c = n(r && r(...s), i, a, o, t), u = c.resolvedOptions();\n    return [ c, ...toEpochMillis(e, u, s) ];\n  };\n}\n\nfunction an(e, n, t, o, r) {\n  if (t = o(t, r), e) {\n    if (void 0 !== t.timeZone) {\n      throw new TypeError(So);\n    }\n    t.timeZone = e;\n  }\n  return new en(n, t);\n}\n\nfunction toEpochMillis(e, n, t) {\n  const [, o, r] = e;\n  return t.map((e => (e.calendar && ((e, n, t) => {\n    if ((t || e !== l) && e !== n) {\n      throw new RangeError(lo);\n    }\n  })(e.calendar, n.calendar, r), o(e, n))));\n}\n\nfunction ge(e, n, t) {\n  const o = n.timeZone, r = e(o), i = {\n    ...he(n, r),\n    ...t || Nt\n  };\n  let a;\n  return a = t ? getMatchingInstantFor(r, i, i.offsetNanoseconds, 2) : getStartOfDayInstantFor(r, i), \n  _e(a, o, n.calendar);\n}\n\nfunction Ot(e, n = Nt) {\n  return jt(checkIsoDateTimeInBounds({\n    ...e,\n    ...n\n  }));\n}\n\nfunction pt(e, n) {\n  return {\n    ...e,\n    calendar: n\n  };\n}\n\nfunction Pe(e, n) {\n  return {\n    ...e,\n    timeZone: n\n  };\n}\n\nfunction tn(e) {\n  const n = Xe();\n  return epochNanoToIso(n, e.R(n));\n}\n\nfunction Xe() {\n  return Ge(Date.now(), Qe);\n}\n\nfunction Ue() {\n  return va || (va = (new en).resolvedOptions().timeZone);\n}\n\nconst expectedInteger = (e, n) => `Non-integer ${e}: ${n}`, expectedPositive = (e, n) => `Non-positive ${e}: ${n}`, expectedFinite = (e, n) => `Non-finite ${e}: ${n}`, forbiddenBigIntToNumber = e => `Cannot convert bigint to ${e}`, invalidBigInt = e => `Invalid bigint: ${e}`, no = \"Cannot convert Symbol to string\", oo = \"Invalid object\", numberOutOfRange = (e, n, t, o, r) => r ? numberOutOfRange(e, r[n], r[t], r[o]) : invalidEntity(e, n) + `; must be between ${t}-${o}`, invalidEntity = (e, n) => `Invalid ${e}: ${n}`, missingField = e => `Missing ${e}`, forbiddenField = e => `Invalid field ${e}`, duplicateFields = e => `Duplicate field ${e}`, noValidFields = e => \"No valid fields: \" + e.join(), i = \"Invalid bag\", invalidChoice = (e, n, t) => invalidEntity(e, n) + \"; must be \" + Object.keys(t).join(), b = \"Cannot use valueOf\", a = \"Invalid calling context\", ro = \"Forbidden era/eraYear\", io = \"Mismatching era/eraYear\", ao = \"Mismatching year/eraYear\", invalidEra = e => `Invalid era: ${e}`, missingYear = e => \"Missing year\" + (e ? \"/era/eraYear\" : \"\"), invalidMonthCode = e => `Invalid monthCode: ${e}`, so = \"Mismatching month/monthCode\", co = \"Missing month/monthCode\", uo = \"Invalid leap month\", fo = \"Invalid protocol results\", c = e => invalidEntity(\"Calendar\", e), lo = \"Mismatching Calendars\", F = e => invalidEntity(\"TimeZone\", e), mo = \"Mismatching TimeZones\", po = \"Forbidden ICU TimeZone\", ho = \"Out-of-bounds offset\", go = \"Out-of-bounds TimeZone gap\", Do = \"Invalid TimeZone offset\", To = \"Ambiguous offset\", Io = \"Out-of-bounds date\", Mo = \"Out-of-bounds duration\", No = \"Cannot mix duration signs\", yo = \"Missing relativeTo\", vo = \"Cannot use large units\", Po = \"Required smallestUnit or largestUnit\", Eo = \"smallestUnit > largestUnit\", failedParse = e => `Cannot parse: ${e}`, invalidSubstring = e => `Invalid substring: ${e}`, rn = e => `Cannot format ${e}`, ln = \"Mismatching types for formatting\", So = \"Cannot specify TimeZone\", Fo = /*@__PURE__*/ Pt(g, ((e, n) => n)), wo = /*@__PURE__*/ Pt(g, ((e, n, t) => t)), bo = /*@__PURE__*/ Pt(padNumber, 2), Oo = {\n  nanosecond: 0,\n  microsecond: 1,\n  millisecond: 2,\n  second: 3,\n  minute: 4,\n  hour: 5,\n  day: 6,\n  week: 7,\n  month: 8,\n  year: 9\n}, Bo = /*@__PURE__*/ Object.keys(Oo), ko = 864e5, Co = 1e3, Yo = 1e3, Qe = 1e6, Ro = 1e9, Zo = 6e10, zo = 36e11, Uo = 864e11, Ao = [ 1, Yo, Qe, Ro, Zo, zo, Uo ], O = /*@__PURE__*/ Bo.slice(0, 6), qo = /*@__PURE__*/ sortStrings(O), Wo = [ \"offset\" ], jo = [ \"timeZone\" ], Lo = /*@__PURE__*/ O.concat(Wo), xo = /*@__PURE__*/ Lo.concat(jo), $o = [ \"era\", \"eraYear\" ], Ho = /*@__PURE__*/ $o.concat([ \"year\" ]), Go = [ \"year\" ], Vo = [ \"monthCode\" ], _o = /*@__PURE__*/ [ \"month\" ].concat(Vo), Jo = [ \"day\" ], Ko = /*@__PURE__*/ _o.concat(Go), Qo = /*@__PURE__*/ Vo.concat(Go), Xo = /*@__PURE__*/ Jo.concat(Ko), er = /*@__PURE__*/ Jo.concat(_o), nr = /*@__PURE__*/ Jo.concat(Vo), tr = /*@__PURE__*/ wo(O, 0), l = \"iso8601\", or = \"gregory\", rr = \"japanese\", ir = {\n  [or]: {\n    \"gregory-inverse\": -1,\n    gregory: 0\n  },\n  [rr]: {\n    \"japanese-inverse\": -1,\n    japanese: 0,\n    meiji: 1867,\n    taisho: 1911,\n    showa: 1925,\n    heisei: 1988,\n    reiwa: 2018\n  },\n  ethiopic: {\n    ethioaa: 0,\n    ethiopic: 5500\n  },\n  coptic: {\n    \"coptic-inverse\": -1,\n    coptic: 0\n  },\n  roc: {\n    \"roc-inverse\": -1,\n    roc: 0\n  },\n  buddhist: {\n    be: 0\n  },\n  islamic: {\n    ah: 0\n  },\n  indian: {\n    saka: 0\n  },\n  persian: {\n    ap: 0\n  }\n}, ar = {\n  [or]: {\n    bce: \"gregory-inverse\",\n    ce: \"gregory\"\n  },\n  [rr]: {\n    bce: \"japanese-inverse\",\n    ce: \"japanese\"\n  },\n  ethiopic: {\n    era0: \"ethioaa\",\n    era1: \"ethiopic\"\n  },\n  coptic: {\n    era0: \"coptic-inverse\",\n    era1: \"coptic\"\n  },\n  roc: {\n    broc: \"roc-inverse\",\n    minguo: \"roc\"\n  }\n}, sr = {\n  chinese: 13,\n  dangi: 13,\n  hebrew: -6\n}, m = /*@__PURE__*/ Pt(requireType, \"string\"), D = /*@__PURE__*/ Pt(requireType, \"boolean\"), cr = /*@__PURE__*/ Pt(requireType, \"number\"), p = /*@__PURE__*/ Bo.map((e => e + \"s\")), ur = /*@__PURE__*/ sortStrings(p), fr = /*@__PURE__*/ p.slice(0, 6), lr = /*@__PURE__*/ p.slice(6), dr = /*@__PURE__*/ lr.slice(1), mr = /*@__PURE__*/ Fo(p), pr = /*@__PURE__*/ wo(p, 0), hr = /*@__PURE__*/ wo(fr, 0), gr = /*@__PURE__*/ Pt(zeroOutProps, p), w = [ \"isoNanosecond\", \"isoMicrosecond\", \"isoMillisecond\", \"isoSecond\", \"isoMinute\", \"isoHour\" ], Dr = [ \"isoDay\", \"isoMonth\", \"isoYear\" ], Tr = /*@__PURE__*/ w.concat(Dr), Ir = /*@__PURE__*/ sortStrings(Dr), Mr = /*@__PURE__*/ sortStrings(w), Nr = /*@__PURE__*/ sortStrings(Tr), Nt = /*@__PURE__*/ wo(Mr, 0), yr = /*@__PURE__*/ Pt(zeroOutProps, Tr), vr = 1e8, Pr = vr * ko, Er = [ vr, 0 ], Sr = [ -vr, 0 ], Fr = 275760, wr = -271821, en = Intl.DateTimeFormat, br = \"en-GB\", Or = 1970, Br = 1972, kr = 12, Cr = /*@__PURE__*/ isoArgsToEpochMilli(1868, 9, 8), Yr = /*@__PURE__*/ on(computeJapaneseEraParts, WeakMap), Rr = \"smallestUnit\", Zr = \"unit\", zr = \"roundingIncrement\", Ur = \"fractionalSecondDigits\", Ar = \"relativeTo\", qr = \"direction\", Wr = {\n  constrain: 0,\n  reject: 1\n}, jr = /*@__PURE__*/ Object.keys(Wr), Lr = {\n  compatible: 0,\n  reject: 1,\n  earlier: 2,\n  later: 3\n}, xr = {\n  reject: 0,\n  use: 1,\n  prefer: 2,\n  ignore: 3\n}, $r = {\n  auto: 0,\n  never: 1,\n  critical: 2,\n  always: 3\n}, Hr = {\n  auto: 0,\n  never: 1,\n  critical: 2\n}, Gr = {\n  auto: 0,\n  never: 1\n}, Vr = {\n  floor: 0,\n  halfFloor: 1,\n  ceil: 2,\n  halfCeil: 3,\n  trunc: 4,\n  halfTrunc: 5,\n  expand: 6,\n  halfExpand: 7,\n  halfEven: 8\n}, _r = {\n  previous: -1,\n  next: 1\n}, Jr = /*@__PURE__*/ Pt(refineUnitOption, Rr), Kr = /*@__PURE__*/ Pt(refineUnitOption, \"largestUnit\"), Qr = /*@__PURE__*/ Pt(refineUnitOption, Zr), Xr = /*@__PURE__*/ Pt(refineChoiceOption, \"overflow\", Wr), ei = /*@__PURE__*/ Pt(refineChoiceOption, \"disambiguation\", Lr), ni = /*@__PURE__*/ Pt(refineChoiceOption, \"offset\", xr), ti = /*@__PURE__*/ Pt(refineChoiceOption, \"calendarName\", $r), oi = /*@__PURE__*/ Pt(refineChoiceOption, \"timeZoneName\", Hr), ri = /*@__PURE__*/ Pt(refineChoiceOption, \"offset\", Gr), ii = /*@__PURE__*/ Pt(refineChoiceOption, \"roundingMode\", Vr), Ut = \"PlainYearMonth\", qt = \"PlainMonthDay\", G = \"PlainDate\", x = \"PlainDateTime\", ft = \"PlainTime\", z = \"ZonedDateTime\", Re = \"Instant\", N = \"Duration\", ai = [ Math.floor, e => hasHalf(e) ? Math.floor(e) : Math.round(e), Math.ceil, e => hasHalf(e) ? Math.ceil(e) : Math.round(e), Math.trunc, e => hasHalf(e) ? Math.trunc(e) || 0 : Math.round(e), e => e < 0 ? Math.floor(e) : Math.ceil(e), e => Math.sign(e) * Math.round(Math.abs(e)) || 0, e => hasHalf(e) ? (e = Math.trunc(e) || 0) + e % 2 : Math.round(e) ], si = \"UTC\", ci = 5184e3, ui = /*@__PURE__*/ isoArgsToEpochSec(1847), fi = /*@__PURE__*/ isoArgsToEpochSec(/*@__PURE__*/ (/*@__PURE__*/ new Date).getUTCFullYear() + 10), li = /0+$/, he = /*@__PURE__*/ on(_zonedEpochSlotsToIso, WeakMap), di = 2 ** 32 - 1, L = /*@__PURE__*/ on((e => {\n  const n = getTimeZoneEssence(e);\n  return \"object\" == typeof n ? new IntlTimeZone(n) : new FixedTimeZone(n || 0);\n}));\n\nclass FixedTimeZone {\n  constructor(e) {\n    this.$ = e;\n  }\n  R() {\n    return this.$;\n  }\n  I(e) {\n    return (e => {\n      const n = isoToEpochNano({\n        ...e,\n        ...Nt\n      });\n      if (!n || Math.abs(n[0]) > 1e8) {\n        throw new RangeError(Io);\n      }\n    })(e), [ isoToEpochNanoWithOffset(e, this.$) ];\n  }\n  O() {}\n}\n\nclass IntlTimeZone {\n  constructor(e) {\n    this.nn = (e => {\n      function getOffsetSec(e) {\n        const i = clampNumber(e, o, r), [a, s] = computePeriod(i), c = n(a), u = n(s);\n        return c === u ? c : pinch(t(a, s), c, u, e);\n      }\n      function pinch(n, t, o, r) {\n        let i, a;\n        for (;(void 0 === r || void 0 === (i = r < n[0] ? t : r >= n[1] ? o : void 0)) && (a = n[1] - n[0]); ) {\n          const t = n[0] + Math.floor(a / 2);\n          e(t) === o ? n[1] = t : n[0] = t + 1;\n        }\n        return i;\n      }\n      const n = on(e), t = on(createSplitTuple);\n      let o = ui, r = fi;\n      return {\n        tn(e) {\n          const n = getOffsetSec(e - 86400), t = getOffsetSec(e + 86400), o = e - n, r = e - t;\n          if (n === t) {\n            return [ o ];\n          }\n          const i = getOffsetSec(o);\n          return i === getOffsetSec(r) ? [ e - i ] : n > t ? [ o, r ] : [];\n        },\n        rn: getOffsetSec,\n        O(e, i) {\n          const a = clampNumber(e, o, r);\n          let [s, c] = computePeriod(a);\n          const u = ci * i, f = i < 0 ? () => c > o || (o = a, 0) : () => s < r || (r = a, \n          0);\n          for (;f(); ) {\n            const o = n(s), r = n(c);\n            if (o !== r) {\n              const n = t(s, c);\n              pinch(n, o, r);\n              const a = n[0];\n              if ((compareNumbers(a, e) || 1) === i) {\n                return a;\n              }\n            }\n            s += u, c += u;\n          }\n        }\n      };\n    })((e => n => {\n      const t = hashIntlFormatParts(e, n * Co);\n      return isoArgsToEpochSec(parseIntlPartsYear(t), parseInt(t.month), parseInt(t.day), parseInt(t.hour), parseInt(t.minute), parseInt(t.second)) - n;\n    })(e));\n  }\n  R(e) {\n    return this.nn.rn((e => epochNanoToSecMod(e)[0])(e)) * Ro;\n  }\n  I(e) {\n    const [n, t] = [ isoArgsToEpochSec((o = e).isoYear, o.isoMonth, o.isoDay, o.isoHour, o.isoMinute, o.isoSecond), o.isoMillisecond * Qe + o.isoMicrosecond * Yo + o.isoNanosecond ];\n    var o;\n    return this.nn.tn(n).map((e => checkEpochNanoInBounds(moveBigNano(Ge(e, Ro), t))));\n  }\n  O(e, n) {\n    const [t, o] = epochNanoToSecMod(e), r = this.nn.O(t + (n > 0 || o ? 1 : 0), n);\n    if (void 0 !== r) {\n      return Ge(r, Ro);\n    }\n  }\n}\n\nconst mi = \"([+-])\", pi = \"(?:[.,](\\\\d{1,9}))?\", hi = `(?:(?:${mi}(\\\\d{6}))|(\\\\d{4}))-?(\\\\d{2})`, gi = \"(\\\\d{2})(?::?(\\\\d{2})(?::?(\\\\d{2})\" + pi + \")?)?\", Di = mi + gi, Ti = hi + \"-?(\\\\d{2})(?:[T ]\" + gi + \"(Z|\" + Di + \")?)?\", Ii = \"\\\\[(!?)([^\\\\]]*)\\\\]\", Mi = `((?:${Ii}){0,9})`, Ni = /*@__PURE__*/ createRegExp(hi + Mi), yi = /*@__PURE__*/ createRegExp(\"(?:--)?(\\\\d{2})-?(\\\\d{2})\" + Mi), vi = /*@__PURE__*/ createRegExp(Ti + Mi), Pi = /*@__PURE__*/ createRegExp(\"T?\" + gi + \"(?:\" + Di + \")?\" + Mi), Ei = /*@__PURE__*/ createRegExp(Di), Si = /*@__PURE__*/ new RegExp(Ii, \"g\"), Fi = /*@__PURE__*/ createRegExp(`${mi}?P(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(?:T(?:(\\\\d+)${pi}H)?(?:(\\\\d+)${pi}M)?(?:(\\\\d+)${pi}S)?)?`), wi = /*@__PURE__*/ on((e => new en(br, {\n  timeZone: e,\n  era: \"short\",\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\",\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\"\n}))), bi = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, Oi = /[^\\w\\/:+-]+/, Bi = /^M(\\d{2})(L?)$/, ki = /*@__PURE__*/ on(createIntlCalendar), Ci = /*@__PURE__*/ on((e => new en(br, {\n  calendar: e,\n  timeZone: si,\n  era: \"short\",\n  year: \"numeric\",\n  month: \"short\",\n  day: \"numeric\"\n}))), Yi = {\n  P(e, n, t) {\n    const o = mt(t);\n    let r, {years: i, months: a, weeks: s, days: c} = n;\n    if (c += durationFieldsToBigNano(n, 5)[0], i || a) {\n      r = ((e, n, t, o, r) => {\n        let [i, a, s] = e.v(n);\n        if (t) {\n          const [n, o] = e.q(i, a);\n          i += t, a = monthCodeNumberToMonth(n, o, e.L(i)), a = clampEntity(\"month\", a, 1, e.B(i), r);\n        }\n        return o && ([i, a] = e.un(i, a, o)), s = clampEntity(\"day\", s, 1, e.U(i, a), r), \n        e.p(i, a, s);\n      })(this, e, i, a, o);\n    } else {\n      if (!s && !c) {\n        return e;\n      }\n      r = isoToEpochMilli(e);\n    }\n    if (void 0 === r) {\n      throw new RangeError(Io);\n    }\n    return r += (7 * s + c) * ko, checkIsoDateInBounds(epochMilliToIso(r));\n  },\n  N(e, n, t) {\n    if (t <= 7) {\n      let o = 0, r = diffDays({\n        ...e,\n        ...Nt\n      }, {\n        ...n,\n        ...Nt\n      });\n      return 7 === t && ([o, r] = divModTrunc(r, 7)), {\n        ...pr,\n        weeks: o,\n        days: r\n      };\n    }\n    const o = this.v(e), r = this.v(n);\n    let [i, a, s] = ((e, n, t, o, r, i, a) => {\n      let s = r - n, c = i - t, u = a - o;\n      if (s || c) {\n        const f = Math.sign(s || c);\n        let l = e.U(r, i), d = 0;\n        if (Math.sign(u) === -f) {\n          const o = l;\n          [r, i] = e.un(r, i, -f), s = r - n, c = i - t, l = e.U(r, i), d = f < 0 ? -o : l;\n        }\n        if (u = a - Math.min(o, l) + d, s) {\n          const [o, a] = e.q(n, t), [u, l] = e.q(r, i);\n          if (c = u - o || Number(l) - Number(a), Math.sign(c) === -f) {\n            const t = f < 0 && -e.B(r);\n            s = (r -= f) - n, c = i - monthCodeNumberToMonth(o, a, e.L(r)) + (t || e.B(r));\n          }\n        }\n      }\n      return [ s, c, u ];\n    })(this, ...o, ...r);\n    return 8 === t && (a += this.cn(i, o[0]), i = 0), {\n      ...pr,\n      years: i,\n      months: a,\n      days: s\n    };\n  },\n  F(e, n) {\n    const t = mt(n), o = refineYear(this, e), r = refineMonth(this, e, o, t), i = refineDay(this, e, r, o, t);\n    return W(checkIsoDateInBounds(this.V(o, r, i)), this.id || l);\n  },\n  K(e, n) {\n    const t = mt(n), o = refineYear(this, e), r = refineMonth(this, e, o, t);\n    return createPlainYearMonthSlots(checkIsoYearMonthInBounds(this.V(o, r, 1)), this.id || l);\n  },\n  _(e, n) {\n    const t = mt(n);\n    let o, r, i, a = void 0 !== e.eraYear || void 0 !== e.year ? refineYear(this, e) : void 0;\n    const s = !this.id;\n    if (void 0 === a && s && (a = Br), void 0 !== a) {\n      const n = refineMonth(this, e, a, t);\n      o = refineDay(this, e, n, a, t);\n      const s = this.L(a);\n      r = monthToMonthCodeNumber(n, s), i = n === s;\n    } else {\n      if (void 0 === e.monthCode) {\n        throw new TypeError(co);\n      }\n      if ([r, i] = parseMonthCode(e.monthCode), this.id && this.id !== or && this.id !== rr) {\n        if (this.id && \"coptic\" === computeCalendarIdBase(this.id) && 0 === t) {\n          const n = i || 13 !== r ? 30 : 6;\n          o = e.day, o = clampNumber(o, 1, n);\n        } else if (this.id && \"chinese\" === computeCalendarIdBase(this.id) && 0 === t) {\n          const n = !i || 1 !== r && 9 !== r && 10 !== r && 11 !== r && 12 !== r ? 30 : 29;\n          o = e.day, o = clampNumber(o, 1, n);\n        } else {\n          o = e.day;\n        }\n      } else {\n        o = refineDay(this, e, refineMonth(this, e, Br, t), Br, t);\n      }\n    }\n    const c = this.G(r, i, o);\n    if (!c) {\n      throw new RangeError(\"Cannot guess year\");\n    }\n    const [u, f] = c;\n    return createPlainMonthDaySlots(checkIsoDateInBounds(this.V(u, f, o)), this.id || l);\n  },\n  fields(e) {\n    return getCalendarEraOrigins(this) && e.includes(\"year\") ? [ ...e, ...$o ] : e;\n  },\n  k(e, n) {\n    const t = Object.assign(Object.create(null), e);\n    return spliceFields(t, n, _o), getCalendarEraOrigins(this) && (spliceFields(t, n, Ho), \n    this.id === rr && spliceFields(t, n, er, $o)), t;\n  },\n  inLeapYear(e) {\n    const [n] = this.v(e);\n    return this.sn(n);\n  },\n  monthsInYear(e) {\n    const [n] = this.v(e);\n    return this.B(n);\n  },\n  daysInMonth(e) {\n    const [n, t] = this.v(e);\n    return this.U(n, t);\n  },\n  daysInYear(e) {\n    const [n] = this.v(e);\n    return this.fn(n);\n  },\n  dayOfYear: computeNativeDayOfYear,\n  era(e) {\n    return this.hn(e)[0];\n  },\n  eraYear(e) {\n    return this.hn(e)[1];\n  },\n  monthCode(e) {\n    const [n, t] = this.v(e), [o, r] = this.q(n, t);\n    return formatMonthCode(o, r);\n  },\n  dayOfWeek: computeIsoDayOfWeek,\n  daysInWeek() {\n    return 7;\n  }\n}, Ri = {\n  v: computeIsoDateParts,\n  hn: computeIsoEraParts,\n  q: computeIsoMonthCodeParts\n}, Zi = {\n  dayOfYear: computeNativeDayOfYear,\n  v: computeIsoDateParts,\n  p: isoArgsToEpochMilli\n}, zi = /*@__PURE__*/ Object.assign({}, Zi, {\n  weekOfYear: computeNativeWeekOfYear,\n  yearOfWeek: computeNativeYearOfWeek,\n  m(e) {\n    function computeWeekShift(e) {\n      return (7 - e < n ? 7 : 0) - e;\n    }\n    function computeWeeksInYear(e) {\n      const n = computeIsoDaysInYear(f + e), t = e || 1, o = computeWeekShift(modFloor(a + n * t, 7));\n      return c = (n + (o - s) * t) / 7;\n    }\n    const n = this.id ? 1 : 4, t = computeIsoDayOfWeek(e), o = this.dayOfYear(e), r = modFloor(t - 1, 7), i = o - 1, a = modFloor(r - i, 7), s = computeWeekShift(a);\n    let c, u = Math.floor((i - s) / 7) + 1, f = e.isoYear;\n    return u ? u > computeWeeksInYear(0) && (u = 1, f++) : (u = computeWeeksInYear(-1), \n    f--), [ u, f, c ];\n  }\n}), Ui = /*@__PURE__*/ Object.assign({}, Yi, zi, {\n  v: computeIsoDateParts,\n  hn: computeIsoEraParts,\n  q: computeIsoMonthCodeParts,\n  G(e, n) {\n    if (!n) {\n      return [ Br, e ];\n    }\n  },\n  sn: computeIsoInLeapYear,\n  L() {},\n  B: computeIsoMonthsInYear,\n  cn: e => e * kr,\n  U: computeIsoDaysInMonth,\n  fn: computeIsoDaysInYear,\n  V: (e, n, t) => ({\n    isoYear: e,\n    isoMonth: n,\n    isoDay: t\n  }),\n  p: isoArgsToEpochMilli,\n  un: (e, n, t) => (e += divTrunc(t, kr), (n += modTrunc(t, kr)) < 1 ? (e--, n += kr) : n > kr && (e++, \n  n -= kr), [ e, n ]),\n  year(e) {\n    return e.isoYear;\n  },\n  month(e) {\n    return e.isoMonth;\n  },\n  day: e => e.isoDay\n}), Ai = {\n  v: computeIntlDateParts,\n  hn: computeIntlEraParts,\n  q: computeIntlMonthCodeParts\n}, qi = {\n  dayOfYear: computeNativeDayOfYear,\n  v: computeIntlDateParts,\n  p: computeIntlEpochMilli,\n  weekOfYear: computeNativeWeekOfYear,\n  yearOfWeek: computeNativeYearOfWeek,\n  m() {\n    return [];\n  }\n}, Wi = /*@__PURE__*/ Object.assign({}, Yi, qi, {\n  v: computeIntlDateParts,\n  hn: computeIntlEraParts,\n  q: computeIntlMonthCodeParts,\n  G(e, n, t) {\n    const o = this.id && \"chinese\" === computeCalendarIdBase(this.id) ? ((e, n, t) => {\n      if (n) {\n        switch (e) {\n         case 1:\n          return 1651;\n\n         case 2:\n          return t < 30 ? 1947 : 1765;\n\n         case 3:\n          return t < 30 ? 1966 : 1955;\n\n         case 4:\n          return t < 30 ? 1963 : 1944;\n\n         case 5:\n          return t < 30 ? 1971 : 1952;\n\n         case 6:\n          return t < 30 ? 1960 : 1941;\n\n         case 7:\n          return t < 30 ? 1968 : 1938;\n\n         case 8:\n          return t < 30 ? 1957 : 1718;\n\n         case 9:\n          return 1832;\n\n         case 10:\n          return 1870;\n\n         case 11:\n          return 1814;\n\n         case 12:\n          return 1890;\n        }\n      }\n      return 1972;\n    })(e, n, t) : Br;\n    let [r, i, a] = computeIntlDateParts.call(this, {\n      isoYear: o,\n      isoMonth: kr,\n      isoDay: 31\n    });\n    const s = computeIntlLeapMonth.call(this, r), c = i === s;\n    1 === (compareNumbers(e, monthToMonthCodeNumber(i, s)) || compareNumbers(Number(n), Number(c)) || compareNumbers(t, a)) && r--;\n    for (let o = 0; o < 100; o++) {\n      const i = r - o, a = computeIntlLeapMonth.call(this, i), s = monthCodeNumberToMonth(e, n, a);\n      if (n === (s === a) && t <= computeIntlDaysInMonth.call(this, i, s)) {\n        return [ i, s ];\n      }\n    }\n  },\n  sn(e) {\n    const n = computeIntlDaysInYear.call(this, e);\n    return n > computeIntlDaysInYear.call(this, e - 1) && n > computeIntlDaysInYear.call(this, e + 1);\n  },\n  L: computeIntlLeapMonth,\n  B: computeIntlMonthsInYear,\n  cn(e, n) {\n    const t = n + e, o = Math.sign(e), r = o < 0 ? -1 : 0;\n    let i = 0;\n    for (let e = n; e !== t; e += o) {\n      i += computeIntlMonthsInYear.call(this, e + r);\n    }\n    return i;\n  },\n  U: computeIntlDaysInMonth,\n  fn: computeIntlDaysInYear,\n  V(e, n, t) {\n    return epochMilliToIso(computeIntlEpochMilli.call(this, e, n, t));\n  },\n  p: computeIntlEpochMilli,\n  un(e, n, t) {\n    if (t) {\n      if (n += t, !Number.isSafeInteger(n)) {\n        throw new RangeError(Io);\n      }\n      if (t < 0) {\n        for (;n < 1; ) {\n          n += computeIntlMonthsInYear.call(this, --e);\n        }\n      } else {\n        let t;\n        for (;n > (t = computeIntlMonthsInYear.call(this, e)); ) {\n          n -= t, e++;\n        }\n      }\n    }\n    return [ e, n ];\n  },\n  year(e) {\n    return this.h(e).year;\n  },\n  month(e) {\n    const {year: n, o: t} = this.h(e), {u: o} = this.l(n);\n    return o[t] + 1;\n  },\n  day(e) {\n    return this.h(e).day;\n  }\n}), ji = /*@__PURE__*/ createNativeOpsCreator(Ri, Ai), C = /*@__PURE__*/ createNativeOpsCreator(Ui, Wi), Li = {\n  ...{\n    era: toStringViaPrimitive,\n    eraYear: toInteger,\n    year: toInteger,\n    month: toPositiveInteger,\n    monthCode(e) {\n      const n = toStringViaPrimitive(e);\n      return parseMonthCode(n), n;\n    },\n    day: toPositiveInteger\n  },\n  .../*@__PURE__*/ wo(O, toInteger),\n  .../*@__PURE__*/ wo(p, toStrictInteger),\n  offset(e) {\n    const n = toStringViaPrimitive(e);\n    return parseOffsetNano(n), n;\n  }\n}, xi = /*@__PURE__*/ Pt(remapProps, O, w), $i = /*@__PURE__*/ Pt(remapProps, w, O), Hi = \"numeric\", Gi = [ \"timeZoneName\" ], Vi = {\n  month: Hi,\n  day: Hi\n}, _i = {\n  year: Hi,\n  month: Hi\n}, Ji = /*@__PURE__*/ Object.assign({}, _i, {\n  day: Hi\n}), Ki = {\n  hour: Hi,\n  minute: Hi,\n  second: Hi\n}, Qi = /*@__PURE__*/ Object.assign({}, Ji, Ki), Xi = /*@__PURE__*/ Object.assign({}, Qi, {\n  timeZoneName: \"short\"\n}), ea = /*@__PURE__*/ Object.keys(_i), na = /*@__PURE__*/ Object.keys(Vi), ta = /*@__PURE__*/ Object.keys(Ji), oa = /*@__PURE__*/ Object.keys(Ki), ra = [ \"dateStyle\" ], ia = /*@__PURE__*/ ea.concat(ra), aa = /*@__PURE__*/ na.concat(ra), sa = /*@__PURE__*/ ta.concat(ra, [ \"weekday\" ]), ca = /*@__PURE__*/ oa.concat([ \"dayPeriod\", \"timeStyle\", \"fractionalSecondDigits\" ]), ua = /*@__PURE__*/ sa.concat(ca), fa = /*@__PURE__*/ Gi.concat(ca), la = /*@__PURE__*/ Gi.concat(sa), da = /*@__PURE__*/ Gi.concat([ \"day\", \"weekday\" ], ca), ma = /*@__PURE__*/ Gi.concat([ \"year\", \"weekday\" ], ca), pa = /*@__PURE__*/ createOptionsTransformer(ua, Qi), ha = /*@__PURE__*/ createOptionsTransformer(ua, Xi), ga = /*@__PURE__*/ createOptionsTransformer(ua, Qi, Gi), Da = /*@__PURE__*/ createOptionsTransformer(sa, Ji, fa), Ta = /*@__PURE__*/ createOptionsTransformer(ca, Ki, la), Ia = /*@__PURE__*/ createOptionsTransformer(ia, _i, da), Ma = /*@__PURE__*/ createOptionsTransformer(aa, Vi, ma), Na = {}, ya = /*@__PURE__*/ new en(void 0, {\n  calendar: l\n}).resolvedOptions().calendar === l, U = [ pa, I ], ot = [ ha, I, 0, (e, n) => {\n  const t = e.timeZone;\n  if (n && n.timeZone !== t) {\n    throw new RangeError(mo);\n  }\n  return t;\n} ], X = [ ga, isoToEpochMilli ], _ = [ Da, isoToEpochMilli ], tt = [ Ta, e => isoTimeFieldsToNano(e) / Qe ], et = [ Ia, isoToEpochMilli, ya ], nt = [ Ma, isoToEpochMilli, ya ];\n\nlet va;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvY2h1bmtzL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLFNBQVMsa0RBQWtELHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsdUJBQXVCLGNBQWMsTUFBTTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyx3QkFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELEVBQUUsSUFBSSxFQUFFLGdEQUFnRCxFQUFFLElBQUksRUFBRSw0Q0FBNEMsRUFBRSxJQUFJLEVBQUUsOERBQThELEVBQUUsMkNBQTJDLEVBQUUsNktBQTZLLGtCQUFrQixFQUFFLEdBQUcsRUFBRSx3Q0FBd0MsRUFBRSxJQUFJLEVBQUUsa0NBQWtDLEVBQUUsMENBQTBDLEVBQUUsNkNBQTZDLEVBQUUsaUlBQWlJLDZOQUE2TixFQUFFLGdIQUFnSCxFQUFFLCtxQkFBK3FCLEVBQUUsaURBQWlELEVBQUUsOEJBQThCLEVBQUU7QUFDNzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrRkFBK0Y7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLElBQUksb0JBQW9CLEdBQUcsS0FBSyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsa0RBQWtELEVBQUUsOEVBQThFLEdBQUcsRUFBRSxJQUFJLDJGQUEyRixFQUFFLFFBQVEsRUFBRSx5T0FBeU8sR0FBRyxpREFBaUQsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHO0FBQzdyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2SEFBNkgsRUFBRTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMscUNBQXFDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxlQUFlLGNBQWMsTUFBTTtBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUMsOENBQThDO0FBQ3BGO0FBQ0EsQ0FBQyx5OUJBQXk5QjtBQUMxOUI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRTIxSSIsInNvdXJjZXMiOlsiL1VzZXJzL25pa2l0YS9EZXNrdG9wL2ZvY3VzcGhlcmUvbm9kZV9tb2R1bGVzL3RlbXBvcmFsLXBvbHlmaWxsL2NodW5rcy9pbnRlcm5hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFtcFByb3AoZSwgbiwgdCwgbywgcikge1xuICByZXR1cm4gY2xhbXBFbnRpdHkobiwgKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IGVbbl07XG4gICAgaWYgKHZvaWQgMCA9PT0gdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXNzaW5nRmllbGQobikpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSkoZSwgbiksIHQsIG8sIHIpO1xufVxuXG5mdW5jdGlvbiBjbGFtcEVudGl0eShlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBjbGFtcE51bWJlcihuLCB0LCBvKTtcbiAgaWYgKHIgJiYgbiAhPT0gYSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG51bWJlck91dE9mUmFuZ2UoZSwgbiwgdCwgbywgaSkpO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBzKGUpIHtcbiAgcmV0dXJuIG51bGwgIT09IGUgJiYgL29iamVjdHxmdW5jdGlvbi8udGVzdCh0eXBlb2YgZSk7XG59XG5cbmZ1bmN0aW9uIG9uKGUsIG4gPSBNYXApIHtcbiAgY29uc3QgdCA9IG5ldyBuO1xuICByZXR1cm4gKG4sIC4uLm8pID0+IHtcbiAgICBpZiAodC5oYXMobikpIHtcbiAgICAgIHJldHVybiB0LmdldChuKTtcbiAgICB9XG4gICAgY29uc3QgciA9IGUobiwgLi4ubyk7XG4gICAgcmV0dXJuIHQuc2V0KG4sIHIpLCByO1xuICB9O1xufVxuXG5mdW5jdGlvbiByKGUpIHtcbiAgcmV0dXJuIG4oe1xuICAgIG5hbWU6IGVcbiAgfSwgMSk7XG59XG5cbmZ1bmN0aW9uIG4obiwgdCkge1xuICByZXR1cm4gZSgoZSA9PiAoe1xuICAgIHZhbHVlOiBlLFxuICAgIGNvbmZpZ3VyYWJsZTogMSxcbiAgICB3cml0YWJsZTogIXRcbiAgfSkpLCBuKTtcbn1cblxuZnVuY3Rpb24gdChuKSB7XG4gIHJldHVybiBlKChlID0+ICh7XG4gICAgZ2V0OiBlLFxuICAgIGNvbmZpZ3VyYWJsZTogMVxuICB9KSksIG4pO1xufVxuXG5mdW5jdGlvbiBvKGUpIHtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgdmFsdWU6IGUsXG4gICAgICBjb25maWd1cmFibGU6IDFcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHppcFByb3BzKGUsIG4pIHtcbiAgY29uc3QgdCA9IHt9O1xuICBsZXQgbyA9IGUubGVuZ3RoO1xuICBmb3IgKGNvbnN0IHIgb2Ygbikge1xuICAgIHRbZVstLW9dXSA9IHI7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGUoZSwgbiwgdCkge1xuICBjb25zdCBvID0ge307XG4gIGZvciAoY29uc3QgciBpbiBuKSB7XG4gICAgb1tyXSA9IGUobltyXSwgciwgdCk7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIGcoZSwgbiwgdCkge1xuICBjb25zdCBvID0ge307XG4gIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGkgPSBuW3JdO1xuICAgIG9baV0gPSBlKGksIHIsIHQpO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiByZW1hcFByb3BzKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHt9O1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBvW25bcl1dID0gdFtlW3JdXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbm4oZSwgbikge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBvIG9mIGUpIHtcbiAgICB0W29dID0gbltvXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaGFzQW55UHJvcHNCeU5hbWUoZSwgbikge1xuICBmb3IgKGNvbnN0IHQgb2Ygbikge1xuICAgIGlmICh0IGluIGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWxsUHJvcHNFcXVhbChlLCBuLCB0KSB7XG4gIGZvciAoY29uc3QgbyBvZiBlKSB7XG4gICAgaWYgKG5bb10gIT09IHRbb10pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gemVyb091dFByb3BzKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHtcbiAgICAuLi50XG4gIH07XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgbjsgdCsrKSB7XG4gICAgb1tlW3RdXSA9IDA7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIFB0KGUsIC4uLm4pIHtcbiAgcmV0dXJuICguLi50KSA9PiBlKC4uLm4sIC4uLnQpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKGUpIHtcbiAgcmV0dXJuIGVbMF0udG9VcHBlckNhc2UoKSArIGUuc3Vic3RyaW5nKDEpO1xufVxuXG5mdW5jdGlvbiBzb3J0U3RyaW5ncyhlKSB7XG4gIHJldHVybiBlLnNsaWNlKCkuc29ydCgpO1xufVxuXG5mdW5jdGlvbiBwYWROdW1iZXIoZSwgbikge1xuICByZXR1cm4gU3RyaW5nKG4pLnBhZFN0YXJ0KGUsIFwiMFwiKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoZSwgbikge1xuICByZXR1cm4gTWF0aC5zaWduKGUgLSBuKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBOdW1iZXIoZSwgbiwgdCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZSwgbiksIHQpO1xufVxuXG5mdW5jdGlvbiBkaXZNb2RGbG9vcihlLCBuKSB7XG4gIHJldHVybiBbIE1hdGguZmxvb3IoZSAvIG4pLCBtb2RGbG9vcihlLCBuKSBdO1xufVxuXG5mdW5jdGlvbiBtb2RGbG9vcihlLCBuKSB7XG4gIHJldHVybiAoZSAlIG4gKyBuKSAlIG47XG59XG5cbmZ1bmN0aW9uIGRpdk1vZFRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIFsgZGl2VHJ1bmMoZSwgbiksIG1vZFRydW5jKGUsIG4pIF07XG59XG5cbmZ1bmN0aW9uIGRpdlRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoZSAvIG4pIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG1vZFRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIGUgJSBuIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGhhc0hhbGYoZSkge1xuICByZXR1cm4gLjUgPT09IE1hdGguYWJzKGUgJSAxKTtcbn1cblxuZnVuY3Rpb24gZ2l2ZW5GaWVsZHNUb0JpZ05hbm8oZSwgbiwgdCkge1xuICBsZXQgbyA9IDAsIHIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICBjb25zdCBuID0gZVt0W2ldXSwgYSA9IEFvW2ldLCBzID0gVW8gLyBhLCBbYywgdV0gPSBkaXZNb2RUcnVuYyhuLCBzKTtcbiAgICBvICs9IHUgKiBhLCByICs9IGM7XG4gIH1cbiAgY29uc3QgW2ksIGFdID0gZGl2TW9kVHJ1bmMobywgVW8pO1xuICByZXR1cm4gWyByICsgaSwgYSBdO1xufVxuXG5mdW5jdGlvbiBuYW5vVG9HaXZlbkZpZWxkcyhlLCBuLCB0KSB7XG4gIGNvbnN0IG8gPSB7fTtcbiAgZm9yIChsZXQgciA9IG47IHIgPj0gMDsgci0tKSB7XG4gICAgY29uc3QgbiA9IEFvW3JdO1xuICAgIG9bdFtyXV0gPSBkaXZUcnVuYyhlLCBuKSwgZSA9IG1vZFRydW5jKGUsIG4pO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBkKGUpIHtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHJldHVybiBtKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFAoZSkge1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgcmV0dXJuIGgoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUyhlKSB7XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICByZXR1cm4gVChlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoKGUpIHtcbiAgcmV0dXJuIHJlcXVpcmVOdW1iZXJJc1Bvc2l0aXZlKFQoZSkpO1xufVxuXG5mdW5jdGlvbiBUKGUpIHtcbiAgcmV0dXJuIHplKGNyKGUpKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZVByb3BEZWZpbmVkKGUsIG4pIHtcbiAgaWYgKG51bGwgPT0gbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1pc3NpbmdGaWVsZChlKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVPYmplY3RMaWtlKGUpIHtcbiAgaWYgKCFzKGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvbyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVUeXBlKGUsIG4sIHQgPSBlKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoaW52YWxpZEVudGl0eSh0LCBuKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIHplKGUsIG4gPSBcIm51bWJlclwiKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkSW50ZWdlcihuLCBlKSk7XG4gIH1cbiAgcmV0dXJuIGUgfHwgMDtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZU51bWJlcklzUG9zaXRpdmUoZSwgbiA9IFwibnVtYmVyXCIpIHtcbiAgaWYgKGUgPD0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkUG9zaXRpdmUobiwgZSkpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gIGlmIChcInN5bWJvbFwiID09IHR5cGVvZiBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihubyk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhlKTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmdWaWFQcmltaXRpdmUoZSwgbikge1xuICByZXR1cm4gcyhlKSA/IFN0cmluZyhlKSA6IG0oZSwgbik7XG59XG5cbmZ1bmN0aW9uIHRvQmlnSW50KGUpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICByZXR1cm4gQmlnSW50KGUpO1xuICB9XG4gIGlmIChcImJpZ2ludFwiICE9IHR5cGVvZiBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihpbnZhbGlkQmlnSW50KGUpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoZSwgbiA9IFwibnVtYmVyXCIpIHtcbiAgaWYgKFwiYmlnaW50XCIgPT0gdHlwZW9mIGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZvcmJpZGRlbkJpZ0ludFRvTnVtYmVyKG4pKTtcbiAgfVxuICBpZiAoZSA9IE51bWJlcihlKSwgIU51bWJlci5pc0Zpbml0ZShlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkRmluaXRlKG4sIGUpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gdG9JbnRlZ2VyKGUsIG4pIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmModG9OdW1iZXIoZSwgbikpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaWN0SW50ZWdlcihlLCBuKSB7XG4gIHJldHVybiB6ZSh0b051bWJlcihlLCBuKSwgbik7XG59XG5cbmZ1bmN0aW9uIHRvUG9zaXRpdmVJbnRlZ2VyKGUsIG4pIHtcbiAgcmV0dXJuIHJlcXVpcmVOdW1iZXJJc1Bvc2l0aXZlKHRvSW50ZWdlcihlLCBuKSwgbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJpZ05hbm8oZSwgbikge1xuICBsZXQgW3QsIG9dID0gZGl2TW9kVHJ1bmMobiwgVW8pLCByID0gZSArIHQ7XG4gIGNvbnN0IGkgPSBNYXRoLnNpZ24ocik7XG4gIHJldHVybiBpICYmIGkgPT09IC1NYXRoLnNpZ24obykgJiYgKHIgLT0gaSwgbyArPSBpICogVW8pLCBbIHIsIG8gXTtcbn1cblxuZnVuY3Rpb24gYWRkQmlnTmFub3MoZSwgbiwgdCA9IDEpIHtcbiAgcmV0dXJuIGNyZWF0ZUJpZ05hbm8oZVswXSArIG5bMF0gKiB0LCBlWzFdICsgblsxXSAqIHQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQmlnTmFubyhlLCBuKSB7XG4gIHJldHVybiBjcmVhdGVCaWdOYW5vKGVbMF0sIGVbMV0gKyBuKTtcbn1cblxuZnVuY3Rpb24gZGlmZkJpZ05hbm9zKGUsIG4pIHtcbiAgcmV0dXJuIGFkZEJpZ05hbm9zKG4sIGUsIC0xKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUJpZ05hbm9zKGUsIG4pIHtcbiAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGVbMF0sIG5bMF0pIHx8IGNvbXBhcmVOdW1iZXJzKGVbMV0sIG5bMV0pO1xufVxuXG5mdW5jdGlvbiBiaWdOYW5vT3V0c2lkZShlLCBuLCB0KSB7XG4gIHJldHVybiAtMSA9PT0gY29tcGFyZUJpZ05hbm9zKGUsIG4pIHx8IDEgPT09IGNvbXBhcmVCaWdOYW5vcyhlLCB0KTtcbn1cblxuZnVuY3Rpb24gYmlnSW50VG9CaWdOYW5vKGUsIG4gPSAxKSB7XG4gIGNvbnN0IHQgPSBCaWdJbnQoVW8gLyBuKTtcbiAgcmV0dXJuIFsgTnVtYmVyKGUgLyB0KSwgTnVtYmVyKGUgJSB0KSAqIG4gXTtcbn1cblxuZnVuY3Rpb24gR2UoZSwgbiA9IDEpIHtcbiAgY29uc3QgdCA9IFVvIC8gbiwgW28sIHJdID0gZGl2TW9kVHJ1bmMoZSwgdCk7XG4gIHJldHVybiBbIG8sIHIgKiBuIF07XG59XG5cbmZ1bmN0aW9uIGJpZ05hbm9Ub051bWJlcihlLCBuID0gMSwgdCkge1xuICBjb25zdCBbbywgcl0gPSBlLCBbaSwgYV0gPSBkaXZNb2RUcnVuYyhyLCBuKTtcbiAgcmV0dXJuIG8gKiAoVW8gLyBuKSArIChpICsgKHQgPyBhIC8gbiA6IDApKTtcbn1cblxuZnVuY3Rpb24gZGl2TW9kQmlnTmFubyhlLCBuLCB0ID0gZGl2TW9kRmxvb3IpIHtcbiAgY29uc3QgW28sIHJdID0gZSwgW2ksIGFdID0gdChyLCBuKTtcbiAgcmV0dXJuIFsgbyAqIChVbyAvIG4pICsgaSwgYSBdO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb1llYXJNb250aEluQm91bmRzKGUpIHtcbiAgcmV0dXJuIGNsYW1wUHJvcChlLCBcImlzb1llYXJcIiwgd3IsIEZyLCAxKSwgZS5pc29ZZWFyID09PSB3ciA/IGNsYW1wUHJvcChlLCBcImlzb01vbnRoXCIsIDQsIDEyLCAxKSA6IGUuaXNvWWVhciA9PT0gRnIgJiYgY2xhbXBQcm9wKGUsIFwiaXNvTW9udGhcIiwgMSwgOSwgMSksIFxuICBlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb0RhdGVJbkJvdW5kcyhlKSB7XG4gIHJldHVybiBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLmUsXG4gICAgLi4uTnQsXG4gICAgaXNvSG91cjogMTJcbiAgfSksIGU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyhlKSB7XG4gIGNvbnN0IG4gPSBjbGFtcFByb3AoZSwgXCJpc29ZZWFyXCIsIHdyLCBGciwgMSksIHQgPSBuID09PSB3ciA/IDEgOiBuID09PSBGciA/IC0xIDogMDtcbiAgcmV0dXJuIHQgJiYgY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhpc29Ub0Vwb2NoTmFubyh7XG4gICAgLi4uZSxcbiAgICBpc29EYXk6IGUuaXNvRGF5ICsgdCxcbiAgICBpc29OYW5vc2Vjb25kOiBlLmlzb05hbm9zZWNvbmQgLSB0XG4gIH0pKSwgZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhlKSB7XG4gIGlmICghZSB8fCBiaWdOYW5vT3V0c2lkZShlLCBTciwgRXIpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBpc29UaW1lRmllbGRzVG9OYW5vKGUpIHtcbiAgcmV0dXJuIGdpdmVuRmllbGRzVG9CaWdOYW5vKGUsIDUsIHcpWzFdO1xufVxuXG5mdW5jdGlvbiBuYW5vVG9Jc29UaW1lQW5kRGF5KGUpIHtcbiAgY29uc3QgW24sIHRdID0gZGl2TW9kRmxvb3IoZSwgVW8pO1xuICByZXR1cm4gWyBuYW5vVG9HaXZlbkZpZWxkcyh0LCA1LCB3KSwgbiBdO1xufVxuXG5mdW5jdGlvbiBlcG9jaE5hbm9Ub1NlY01vZChlKSB7XG4gIHJldHVybiBkaXZNb2RCaWdOYW5vKGUsIFJvKTtcbn1cblxuZnVuY3Rpb24gaXNvVG9FcG9jaE1pbGxpKGUpIHtcbiAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSwgZS5pc29Ib3VyLCBlLmlzb01pbnV0ZSwgZS5pc29TZWNvbmQsIGUuaXNvTWlsbGlzZWNvbmQpO1xufVxuXG5mdW5jdGlvbiBpc29Ub0Vwb2NoTmFubyhlKSB7XG4gIGNvbnN0IG4gPSBpc29Ub0Vwb2NoTWlsbGkoZSk7XG4gIGlmICh2b2lkIDAgIT09IG4pIHtcbiAgICBjb25zdCBbdCwgb10gPSBkaXZNb2RUcnVuYyhuLCBrbyk7XG4gICAgcmV0dXJuIFsgdCwgbyAqIFFlICsgKGUuaXNvTWljcm9zZWNvbmQgfHwgMCkgKiBZbyArIChlLmlzb05hbm9zZWNvbmQgfHwgMCkgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc29Ub0Vwb2NoTmFub1dpdGhPZmZzZXQoZSwgbikge1xuICBjb25zdCBbdCwgb10gPSBuYW5vVG9Jc29UaW1lQW5kRGF5KGlzb1RpbWVGaWVsZHNUb05hbm8oZSkgLSBuKTtcbiAgcmV0dXJuIGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoaXNvVG9FcG9jaE5hbm8oe1xuICAgIC4uLmUsXG4gICAgaXNvRGF5OiBlLmlzb0RheSArIG8sXG4gICAgLi4udFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGlzb0FyZ3NUb0Vwb2NoU2VjKC4uLmUpIHtcbiAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoLi4uZSkgLyBDbztcbn1cblxuZnVuY3Rpb24gaXNvQXJnc1RvRXBvY2hNaWxsaSguLi5lKSB7XG4gIGNvbnN0IFtuLCB0XSA9IGlzb1RvTGVnYWN5RGF0ZSguLi5lKSwgbyA9IG4udmFsdWVPZigpO1xuICBpZiAoIWlzTmFOKG8pKSB7XG4gICAgcmV0dXJuIG8gLSB0ICoga287XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNvVG9MZWdhY3lEYXRlKGUsIG4gPSAxLCB0ID0gMSwgbyA9IDAsIHIgPSAwLCBpID0gMCwgYSA9IDApIHtcbiAgY29uc3QgcyA9IGUgPT09IHdyID8gMSA6IGUgPT09IEZyID8gLTEgOiAwLCBjID0gbmV3IERhdGU7XG4gIHJldHVybiBjLnNldFVUQ0hvdXJzKG8sIHIsIGksIGEpLCBjLnNldFVUQ0Z1bGxZZWFyKGUsIG4gLSAxLCB0ICsgcyksIFsgYywgcyBdO1xufVxuXG5mdW5jdGlvbiBlcG9jaE5hbm9Ub0lzbyhlLCBuKSB7XG4gIGxldCBbdCwgb10gPSBtb3ZlQmlnTmFubyhlLCBuKTtcbiAgbyA8IDAgJiYgKG8gKz0gVW8sIHQgLT0gMSk7XG4gIGNvbnN0IFtyLCBpXSA9IGRpdk1vZEZsb29yKG8sIFFlKSwgW2EsIHNdID0gZGl2TW9kRmxvb3IoaSwgWW8pO1xuICByZXR1cm4gZXBvY2hNaWxsaVRvSXNvKHQgKiBrbyArIHIsIGEsIHMpO1xufVxuXG5mdW5jdGlvbiBlcG9jaE1pbGxpVG9Jc28oZSwgbiA9IDAsIHQgPSAwKSB7XG4gIGNvbnN0IG8gPSBNYXRoLmNlaWwoTWF0aC5tYXgoMCwgTWF0aC5hYnMoZSkgLSBQcikgLyBrbykgKiBNYXRoLnNpZ24oZSksIHIgPSBuZXcgRGF0ZShlIC0gbyAqIGtvKTtcbiAgcmV0dXJuIHppcFByb3BzKFRyLCBbIHIuZ2V0VVRDRnVsbFllYXIoKSwgci5nZXRVVENNb250aCgpICsgMSwgci5nZXRVVENEYXRlKCkgKyBvLCByLmdldFVUQ0hvdXJzKCksIHIuZ2V0VVRDTWludXRlcygpLCByLmdldFVUQ1NlY29uZHMoKSwgci5nZXRVVENNaWxsaXNlY29uZHMoKSwgbiwgdCBdKTtcbn1cblxuZnVuY3Rpb24gaGFzaEludGxGb3JtYXRQYXJ0cyhlLCBuKSB7XG4gIGlmIChuIDwgLVByKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIGNvbnN0IHQgPSBlLmZvcm1hdFRvUGFydHMobiksIG8gPSB7fTtcbiAgZm9yIChjb25zdCBlIG9mIHQpIHtcbiAgICBvW2UudHlwZV0gPSBlLnZhbHVlO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvRGF0ZVBhcnRzKGUpIHtcbiAgcmV0dXJuIFsgZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvTW9udGhDb2RlUGFydHMoZSwgbikge1xuICByZXR1cm4gWyBuLCAwIF07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc29Nb250aHNJblllYXIoKSB7XG4gIHJldHVybiBrcjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0RheXNJbk1vbnRoKGUsIG4pIHtcbiAgc3dpdGNoIChuKSB7XG4gICBjYXNlIDI6XG4gICAgcmV0dXJuIGNvbXB1dGVJc29JbkxlYXBZZWFyKGUpID8gMjkgOiAyODtcblxuICAgY2FzZSA0OlxuICAgY2FzZSA2OlxuICAgY2FzZSA5OlxuICAgY2FzZSAxMTpcbiAgICByZXR1cm4gMzA7XG4gIH1cbiAgcmV0dXJuIDMxO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvRGF5c0luWWVhcihlKSB7XG4gIHJldHVybiBjb21wdXRlSXNvSW5MZWFwWWVhcihlKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0luTGVhcFllYXIoZSkge1xuICByZXR1cm4gZSAlIDQgPT0gMCAmJiAoZSAlIDEwMCAhPSAwIHx8IGUgJSA0MDAgPT0gMCk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc29EYXlPZldlZWsoZSkge1xuICBjb25zdCBbbiwgdF0gPSBpc29Ub0xlZ2FjeURhdGUoZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSk7XG4gIHJldHVybiBtb2RGbG9vcihuLmdldFVUQ0RheSgpIC0gdCwgNykgfHwgNztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0VyYVBhcnRzKGUpIHtcbiAgcmV0dXJuIHRoaXMuaWQgPT09IG9yID8gKCh7aXNvWWVhcjogZX0pID0+IGUgPCAxID8gWyBcImdyZWdvcnktaW52ZXJzZVwiLCAxIC0gZSBdIDogWyBcImdyZWdvcnlcIiwgZSBdKShlKSA6IHRoaXMuaWQgPT09IHJyID8gWXIoZSkgOiBbXTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUphcGFuZXNlRXJhUGFydHMoZSkge1xuICBjb25zdCBuID0gaXNvVG9FcG9jaE1pbGxpKGUpO1xuICBpZiAobiA8IENyKSB7XG4gICAgY29uc3Qge2lzb1llYXI6IG59ID0gZTtcbiAgICByZXR1cm4gbiA8IDEgPyBbIFwiamFwYW5lc2UtaW52ZXJzZVwiLCAxIC0gbiBdIDogWyBcImphcGFuZXNlXCIsIG4gXTtcbiAgfVxuICBjb25zdCB0ID0gaGFzaEludGxGb3JtYXRQYXJ0cyhDaShyciksIG4pLCB7ZXJhOiBvLCBlcmFZZWFyOiByfSA9IHBhcnNlSW50bFllYXIodCwgcnIpO1xuICByZXR1cm4gWyBvLCByIF07XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMoZSkge1xuICByZXR1cm4gY2hlY2tJc29EYXRlRmllbGRzKGUpLCBjb25zdHJhaW5Jc29UaW1lRmllbGRzKGUsIDEpLCBlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb0RhdGVGaWVsZHMoZSkge1xuICByZXR1cm4gY29uc3RyYWluSXNvRGF0ZUZpZWxkcyhlLCAxKSwgZTtcbn1cblxuZnVuY3Rpb24gaXNJc29EYXRlRmllbGRzVmFsaWQoZSkge1xuICByZXR1cm4gYWxsUHJvcHNFcXVhbChEciwgZSwgY29uc3RyYWluSXNvRGF0ZUZpZWxkcyhlKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbklzb0RhdGVGaWVsZHMoZSwgbikge1xuICBjb25zdCB7aXNvWWVhcjogdH0gPSBlLCBvID0gY2xhbXBQcm9wKGUsIFwiaXNvTW9udGhcIiwgMSwgY29tcHV0ZUlzb01vbnRoc0luWWVhcigpLCBuKTtcbiAgcmV0dXJuIHtcbiAgICBpc29ZZWFyOiB0LFxuICAgIGlzb01vbnRoOiBvLFxuICAgIGlzb0RheTogY2xhbXBQcm9wKGUsIFwiaXNvRGF5XCIsIDEsIGNvbXB1dGVJc29EYXlzSW5Nb250aCh0LCBvKSwgbilcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uc3RyYWluSXNvVGltZUZpZWxkcyhlLCBuKSB7XG4gIHJldHVybiB6aXBQcm9wcyh3LCBbIGNsYW1wUHJvcChlLCBcImlzb0hvdXJcIiwgMCwgMjMsIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaW51dGVcIiwgMCwgNTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29TZWNvbmRcIiwgMCwgNTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaWxsaXNlY29uZFwiLCAwLCA5OTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaWNyb3NlY29uZFwiLCAwLCA5OTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29OYW5vc2Vjb25kXCIsIDAsIDk5OSwgbikgXSk7XG59XG5cbmZ1bmN0aW9uIG10KGUpIHtcbiAgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IDAgOiBYcihyZXF1aXJlT2JqZWN0TGlrZShlKSk7XG59XG5cbmZ1bmN0aW9uIGplKGUsIG4gPSAwKSB7XG4gIGUgPSBub3JtYWxpemVPcHRpb25zKGUpO1xuICBjb25zdCB0ID0gZWkoZSksIG8gPSBuaShlLCBuKTtcbiAgcmV0dXJuIFsgWHIoZSksIG8sIHQgXTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lRGlmZk9wdGlvbnMoZSwgbiwgdCwgbyA9IDksIHIgPSAwLCBpID0gNCkge1xuICBuID0gbm9ybWFsaXplT3B0aW9ucyhuKTtcbiAgbGV0IGEgPSBLcihuLCBvLCByKSwgcyA9IHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKG4pLCBjID0gaWkobiwgaSk7XG4gIGNvbnN0IHUgPSBKcihuLCBvLCByLCAxKTtcbiAgcmV0dXJuIG51bGwgPT0gYSA/IGEgPSBNYXRoLm1heCh0LCB1KSA6IGNoZWNrTGFyZ2VzdFNtYWxsZXN0VW5pdChhLCB1KSwgcyA9IHJlZmluZVJvdW5kaW5nSW5jKHMsIHUsIDEpLCBcbiAgZSAmJiAoYyA9IChlID0+IGUgPCA0ID8gKGUgKyAyKSAlIDQgOiBlKShjKSksIFsgYSwgdSwgcywgYyBdO1xufVxuXG5mdW5jdGlvbiByZWZpbmVSb3VuZGluZ09wdGlvbnMoZSwgbiA9IDYsIHQpIHtcbiAgbGV0IG8gPSBwYXJzZVJvdW5kaW5nSW5jSW50ZWdlcihlID0gbm9ybWFsaXplT3B0aW9uc09yU3RyaW5nKGUsIFJyKSk7XG4gIGNvbnN0IHIgPSBpaShlLCA3KTtcbiAgbGV0IGkgPSBKcihlLCBuKTtcbiAgcmV0dXJuIGkgPSByZXF1aXJlUHJvcERlZmluZWQoUnIsIGkpLCBvID0gcmVmaW5lUm91bmRpbmdJbmMobywgaSwgdm9pZCAwLCB0KSwgWyBpLCBvLCByIF07XG59XG5cbmZ1bmN0aW9uIHJlZmluZURhdGVEaXNwbGF5T3B0aW9ucyhlKSB7XG4gIHJldHVybiB0aShub3JtYWxpemVPcHRpb25zKGUpKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lVGltZURpc3BsYXlPcHRpb25zKGUsIG4pIHtcbiAgcmV0dXJuIHJlZmluZVRpbWVEaXNwbGF5VHVwbGUobm9ybWFsaXplT3B0aW9ucyhlKSwgbik7XG59XG5cbmZ1bmN0aW9uIE1lKGUpIHtcbiAgY29uc3QgbiA9IG5vcm1hbGl6ZU9wdGlvbnNPclN0cmluZyhlLCBxciksIHQgPSByZWZpbmVDaG9pY2VPcHRpb24ocXIsIF9yLCBuLCAwKTtcbiAgaWYgKCF0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVudGl0eShxciwgdCkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiByZWZpbmVUaW1lRGlzcGxheVR1cGxlKGUsIG4gPSA0KSB7XG4gIGNvbnN0IHQgPSByZWZpbmVTdWJzZWNEaWdpdHMoZSk7XG4gIHJldHVybiBbIGlpKGUsIDQpLCAuLi5yZWZpbmVTbWFsbGVzdFVuaXRBbmRTdWJzZWNEaWdpdHMoSnIoZSwgbiksIHQpIF07XG59XG5cbmZ1bmN0aW9uIHJlZmluZVNtYWxsZXN0VW5pdEFuZFN1YnNlY0RpZ2l0cyhlLCBuKSB7XG4gIHJldHVybiBudWxsICE9IGUgPyBbIEFvW2VdLCBlIDwgNCA/IDkgLSAzICogZSA6IC0xIF0gOiBbIHZvaWQgMCA9PT0gbiA/IDEgOiAxMCAqKiAoOSAtIG4pLCBuIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKGUpIHtcbiAgY29uc3QgbiA9IGVbenJdO1xuICByZXR1cm4gdm9pZCAwID09PSBuID8gMSA6IHRvSW50ZWdlcihuLCB6cik7XG59XG5cbmZ1bmN0aW9uIHJlZmluZVJvdW5kaW5nSW5jKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IG8gPyBVbyA6IEFvW24gKyAxXTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCB0ID0gQW9bbl07XG4gICAgaWYgKHIgJSAoKGUgPSBjbGFtcEVudGl0eSh6ciwgZSwgMSwgciAvIHQgLSAobyA/IDAgOiAxKSwgMSkpICogdCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRFbnRpdHkoenIsIGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZSA9IGNsYW1wRW50aXR5KHpyLCBlLCAxLCB0ID8gMTAgKiogOSA6IDEsIDEpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiByZWZpbmVTdWJzZWNEaWdpdHMoZSkge1xuICBsZXQgbiA9IGVbVXJdO1xuICBpZiAodm9pZCAwICE9PSBuKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG4pIHtcbiAgICAgIGlmIChcImF1dG9cIiA9PT0gdG9TdHJpbmcobikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVudGl0eShVciwgbikpO1xuICAgIH1cbiAgICBuID0gY2xhbXBFbnRpdHkoVXIsIE1hdGguZmxvb3IobiksIDAsIDksIDEpO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGUpIHtcbiAgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IHt9IDogcmVxdWlyZU9iamVjdExpa2UoZSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnNPclN0cmluZyhlLCBuKSB7XG4gIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlID8ge1xuICAgIFtuXTogZVxuICB9IDogcmVxdWlyZU9iamVjdExpa2UoZSk7XG59XG5cbmZ1bmN0aW9uIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyhlKSB7XG4gIHJldHVybiB7XG4gICAgb3ZlcmZsb3c6IGpyW2VdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZmluZVVuaXRPcHRpb24oZSwgbiwgdCA9IDksIG8gPSAwLCByKSB7XG4gIGxldCBpID0gbltlXTtcbiAgaWYgKHZvaWQgMCA9PT0gaSkge1xuICAgIHJldHVybiByID8gbyA6IHZvaWQgMDtcbiAgfVxuICBpZiAoaSA9IHRvU3RyaW5nKGkpLCBcImF1dG9cIiA9PT0gaSkge1xuICAgIHJldHVybiByID8gbyA6IG51bGw7XG4gIH1cbiAgbGV0IGEgPSBPb1tpXTtcbiAgaWYgKHZvaWQgMCA9PT0gYSAmJiAoYSA9IG1yW2ldKSwgdm9pZCAwID09PSBhKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZENob2ljZShlLCBpLCBPbykpO1xuICB9XG4gIHJldHVybiBjbGFtcEVudGl0eShlLCBhLCBvLCB0LCAxLCBCbyksIGE7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNob2ljZU9wdGlvbihlLCBuLCB0LCBvID0gMCkge1xuICBjb25zdCByID0gdFtlXTtcbiAgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgIHJldHVybiBvO1xuICB9XG4gIGNvbnN0IGkgPSB0b1N0cmluZyhyKSwgYSA9IG5baV07XG4gIGlmICh2b2lkIDAgPT09IGEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkQ2hvaWNlKGUsIGksIG4pKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY2hlY2tMYXJnZXN0U21hbGxlc3RVbml0KGUsIG4pIHtcbiAgaWYgKG4gPiBlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRW8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhlKGUpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuZGluZzogUmUsXG4gICAgZXBvY2hOYW5vc2Vjb25kczogZVxuICB9O1xufVxuXG5mdW5jdGlvbiBfZShlLCBuLCB0KSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmRpbmc6IHosXG4gICAgY2FsZW5kYXI6IHQsXG4gICAgdGltZVpvbmU6IG4sXG4gICAgZXBvY2hOYW5vc2Vjb25kczogZVxuICB9O1xufVxuXG5mdW5jdGlvbiBqdChlLCBuID0gZS5jYWxlbmRhcikge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiB4LFxuICAgIGNhbGVuZGFyOiBuLFxuICAgIC4uLm5uKE5yLCBlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBXKGUsIG4gPSBlLmNhbGVuZGFyKSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmRpbmc6IEcsXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgLi4ubm4oSXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWluWWVhck1vbnRoU2xvdHMoZSwgbiA9IGUuY2FsZW5kYXIpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuZGluZzogVXQsXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgLi4ubm4oSXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWluTW9udGhEYXlTbG90cyhlLCBuID0gZS5jYWxlbmRhcikge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBxdCxcbiAgICBjYWxlbmRhcjogbixcbiAgICAuLi5ubihJciwgZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gU3QoZSkge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBmdCxcbiAgICAuLi5ubihNciwgZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gT2UoZSkge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBOLFxuICAgIHNpZ246IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksXG4gICAgLi4ubm4odXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIEkoZSkge1xuICByZXR1cm4gZGl2TW9kQmlnTmFubyhlLmVwb2NoTmFub3NlY29uZHMsIFFlKVswXTtcbn1cblxuZnVuY3Rpb24gdihlKSB7XG4gIHJldHVybiAoKGUsIG4gPSAxKSA9PiB7XG4gICAgY29uc3QgW3QsIG9dID0gZSwgciA9IE1hdGguZmxvb3IobyAvIG4pLCBpID0gVW8gLyBuO1xuICAgIHJldHVybiBCaWdJbnQodCkgKiBCaWdJbnQoaSkgKyBCaWdJbnQocik7XG4gIH0pKGUuZXBvY2hOYW5vc2Vjb25kcyk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcG9jaE5hbm8oZSkge1xuICByZXR1cm4gZS5lcG9jaE5hbm9zZWNvbmRzO1xufVxuXG5mdW5jdGlvbiBKKGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IGdldE1heER1cmF0aW9uVW5pdChvKSwgW2EsIHNdID0gKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IG4oKGUgPSBub3JtYWxpemVPcHRpb25zT3JTdHJpbmcoZSwgWnIpKVtBcl0pO1xuICAgIGxldCBvID0gUXIoZSk7XG4gICAgcmV0dXJuIG8gPSByZXF1aXJlUHJvcERlZmluZWQoWnIsIG8pLCBbIG8sIHQgXTtcbiAgfSkociwgZSksIGMgPSBNYXRoLm1heChhLCBpKTtcbiAgaWYgKCFzICYmIGlzVW5pZm9ybVVuaXQoYywgcykpIHtcbiAgICByZXR1cm4gdG90YWxEYXlUaW1lRHVyYXRpb24obywgYSk7XG4gIH1cbiAgaWYgKCFzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoeW8pO1xuICB9XG4gIGlmICghby5zaWduKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgW3UsIGYsIGxdID0gY3JlYXRlTWFya2VyU3lzdGVtKG4sIHQsIHMpLCBkID0gY3JlYXRlTWFya2VyVG9FcG9jaE5hbm8obCksIG0gPSBjcmVhdGVNb3ZlTWFya2VyKGwpLCBoID0gY3JlYXRlRGlmZk1hcmtlcnMobCksIGcgPSBtKGYsIHUsIG8pO1xuICBpc1pvbmVkRXBvY2hTbG90cyhzKSB8fCAoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHUpLCBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoZykpO1xuICBjb25zdCBEID0gaChmLCB1LCBnLCBhKTtcbiAgcmV0dXJuIGlzVW5pZm9ybVVuaXQoYSwgcykgPyB0b3RhbERheVRpbWVEdXJhdGlvbihELCBhKSA6ICgoZSwgbiwgdCwgbywgciwgaSwgYSkgPT4ge1xuICAgIGNvbnN0IHMgPSBjb21wdXRlRHVyYXRpb25TaWduKGUpLCBbYywgdV0gPSBjbGFtcFJlbGF0aXZlRHVyYXRpb24obywgZ3IodCwgZSksIHQsIHMsIHIsIGksIGEpLCBmID0gY29tcHV0ZUVwb2NoTmFub0ZyYWMobiwgYywgdSk7XG4gICAgcmV0dXJuIGVbcFt0XV0gKyBmICogcztcbiAgfSkoRCwgZChnKSwgYSwgZiwgdSwgZCwgbSk7XG59XG5cbmZ1bmN0aW9uIHRvdGFsRGF5VGltZUR1cmF0aW9uKGUsIG4pIHtcbiAgcmV0dXJuIGJpZ05hbm9Ub051bWJlcihkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgQW9bbl0sIDEpO1xufVxuXG5mdW5jdGlvbiBjbGFtcFJlbGF0aXZlRHVyYXRpb24oZSwgbiwgdCwgbywgciwgaSwgYSkge1xuICBjb25zdCBzID0gcFt0XSwgYyA9IHtcbiAgICAuLi5uLFxuICAgIFtzXTogbltzXSArIG9cbiAgfSwgdSA9IGEoZSwgciwgbiksIGYgPSBhKGUsIHIsIGMpO1xuICByZXR1cm4gWyBpKHUpLCBpKGYpIF07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFcG9jaE5hbm9GcmFjKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IGJpZ05hbm9Ub051bWJlcihkaWZmQmlnTmFub3MobiwgdCkpO1xuICBpZiAoIW8pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gIH1cbiAgcmV0dXJuIGJpZ05hbm9Ub051bWJlcihkaWZmQmlnTmFub3MobiwgZSkpIC8gbztcbn1cblxuZnVuY3Rpb24gTGUoZSwgbikge1xuICBjb25zdCBbdCwgbywgcl0gPSByZWZpbmVSb3VuZGluZ09wdGlvbnMobiwgNSwgMSk7XG4gIHJldHVybiB4ZShyb3VuZEJpZ05hbm8oZS5lcG9jaE5hbm9zZWNvbmRzLCB0LCBvLCByLCAxKSk7XG59XG5cbmZ1bmN0aW9uIEllKGUsIG4sIHQpIHtcbiAgbGV0IHtlcG9jaE5hbm9zZWNvbmRzOiBvLCB0aW1lWm9uZTogciwgY2FsZW5kYXI6IGl9ID0gbjtcbiAgY29uc3QgW2EsIHMsIGNdID0gcmVmaW5lUm91bmRpbmdPcHRpb25zKHQpO1xuICBpZiAoMCA9PT0gYSAmJiAxID09PSBzKSB7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgY29uc3QgdSA9IGUocik7XG4gIGlmICg2ID09PSBhKSB7XG4gICAgbyA9ICgoZSwgbiwgdCwgbykgPT4ge1xuICAgICAgY29uc3QgciA9IGhlKHQsIG4pLCBbaSwgYV0gPSBlKHIpLCBzID0gdC5lcG9jaE5hbm9zZWNvbmRzLCBjID0gZ2V0U3RhcnRPZkRheUluc3RhbnRGb3IobiwgaSksIHUgPSBnZXRTdGFydE9mRGF5SW5zdGFudEZvcihuLCBhKTtcbiAgICAgIGlmIChiaWdOYW5vT3V0c2lkZShzLCBjLCB1KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91bmRXaXRoTW9kZShjb21wdXRlRXBvY2hOYW5vRnJhYyhzLCBjLCB1KSwgbykgPyB1IDogYztcbiAgICB9KShjb21wdXRlRGF5SW50ZXJ2YWwsIHUsIG4sIGMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGUgPSB1LlIobyk7XG4gICAgbyA9IGdldE1hdGNoaW5nSW5zdGFudEZvcih1LCByb3VuZERhdGVUaW1lKGVwb2NoTmFub1RvSXNvKG8sIGUpLCBhLCBzLCBjKSwgZSwgMiwgMCwgMSk7XG4gIH1cbiAgcmV0dXJuIF9lKG8sIHIsIGkpO1xufVxuXG5mdW5jdGlvbiB2dChlLCBuKSB7XG4gIHJldHVybiBqdChyb3VuZERhdGVUaW1lKGUsIC4uLnJlZmluZVJvdW5kaW5nT3B0aW9ucyhuKSksIGUuY2FsZW5kYXIpO1xufVxuXG5mdW5jdGlvbiBsdChlLCBuKSB7XG4gIGNvbnN0IFt0LCBvLCByXSA9IHJlZmluZVJvdW5kaW5nT3B0aW9ucyhuLCA1KTtcbiAgdmFyIGk7XG4gIHJldHVybiBTdCgoaSA9IHIsIHJvdW5kVGltZVRvTmFubyhlLCBjb21wdXRlTmFub0luYyh0LCBvKSwgaSlbMF0pKTtcbn1cblxuZnVuY3Rpb24gVGUoZSwgbikge1xuICBjb25zdCB0ID0gZShuLnRpbWVab25lKSwgbyA9IGhlKG4sIHQpLCBbciwgaV0gPSBjb21wdXRlRGF5SW50ZXJ2YWwobyksIGEgPSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKHQsIHIpLCBnZXRTdGFydE9mRGF5SW5zdGFudEZvcih0LCBpKSksIHpvLCAxKTtcbiAgaWYgKGEgPD0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZvKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gdmUoZSwgbikge1xuICBjb25zdCB7dGltZVpvbmU6IHQsIGNhbGVuZGFyOiBvfSA9IG4sIHIgPSAoKGUsIG4sIHQpID0+IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKG4sIGUoaGUodCwgbikpKSkoY29tcHV0ZURheUZsb29yLCBlKHQpLCBuKTtcbiAgcmV0dXJuIF9lKHIsIHQsIG8pO1xufVxuXG5mdW5jdGlvbiByb3VuZERhdGVUaW1lKGUsIG4sIHQsIG8pIHtcbiAgcmV0dXJuIHJvdW5kRGF0ZVRpbWVUb05hbm8oZSwgY29tcHV0ZU5hbm9JbmMobiwgdCksIG8pO1xufVxuXG5mdW5jdGlvbiByb3VuZERhdGVUaW1lVG9OYW5vKGUsIG4sIHQpIHtcbiAgY29uc3QgW28sIHJdID0gcm91bmRUaW1lVG9OYW5vKGUsIG4sIHQpO1xuICByZXR1cm4gY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHtcbiAgICAuLi5tb3ZlQnlEYXlzKGUsIHIpLFxuICAgIC4uLm9cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVGltZVRvTmFubyhlLCBuLCB0KSB7XG4gIHJldHVybiBuYW5vVG9Jc29UaW1lQW5kRGF5KHJvdW5kQnlJbmMoaXNvVGltZUZpZWxkc1RvTmFubyhlKSwgbiwgdCkpO1xufVxuXG5mdW5jdGlvbiByb3VuZFRvTWludXRlKGUpIHtcbiAgcmV0dXJuIHJvdW5kQnlJbmMoZSwgWm8sIDcpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTmFub0luYyhlLCBuKSB7XG4gIHJldHVybiBBb1tlXSAqIG47XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEYXlJbnRlcnZhbChlKSB7XG4gIGNvbnN0IG4gPSBjb21wdXRlRGF5Rmxvb3IoZSk7XG4gIHJldHVybiBbIG4sIG1vdmVCeURheXMobiwgMSkgXTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURheUZsb29yKGUpIHtcbiAgcmV0dXJuIHlyKDYsIGUpO1xufVxuXG5mdW5jdGlvbiByb3VuZERheVRpbWVEdXJhdGlvbkJ5SW5jKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IE1hdGgubWluKGdldE1heER1cmF0aW9uVW5pdChlKSwgNik7XG4gIHJldHVybiBuYW5vVG9EdXJhdGlvbkRheVRpbWVGaWVsZHMocm91bmRCaWdOYW5vQnlJbmMoZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSwgbyksIG4sIHQpLCBvKTtcbn1cblxuZnVuY3Rpb24gcm91bmRSZWxhdGl2ZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUpIHtcbiAgaWYgKDAgPT09IG8gJiYgMSA9PT0gcikge1xuICAgIHJldHVybiBlO1xuICB9XG4gIGNvbnN0IGYgPSBpc1VuaWZvcm1Vbml0KG8sIHMpID8gaXNab25lZEVwb2NoU2xvdHMocykgJiYgbyA8IDYgJiYgdCA+PSA2ID8gbnVkZ2Vab25lZFRpbWVEdXJhdGlvbiA6IG51ZGdlRGF5VGltZUR1cmF0aW9uIDogbnVkZ2VSZWxhdGl2ZUR1cmF0aW9uO1xuICBsZXQgW2wsIGQsIG1dID0gZihlLCBuLCB0LCBvLCByLCBpLCBhLCBzLCBjLCB1KTtcbiAgcmV0dXJuIG0gJiYgNyAhPT0gbyAmJiAobCA9ICgoZSwgbiwgdCwgbywgciwgaSwgYSwgcykgPT4ge1xuICAgIGNvbnN0IGMgPSBjb21wdXRlRHVyYXRpb25TaWduKGUpO1xuICAgIGZvciAobGV0IHUgPSBvICsgMTsgdSA8PSB0OyB1KyspIHtcbiAgICAgIGlmICg3ID09PSB1ICYmIDcgIT09IHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gZ3IodSwgZSk7XG4gICAgICBvW3BbdV1dICs9IGM7XG4gICAgICBjb25zdCBmID0gYmlnTmFub1RvTnVtYmVyKGRpZmZCaWdOYW5vcyhhKHMociwgaSwgbykpLCBuKSk7XG4gICAgICBpZiAoZiAmJiBNYXRoLnNpZ24oZikgIT09IGMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pKGwsIGQsIHQsIE1hdGgubWF4KDYsIG8pLCBhLCBzLCBjLCB1KSksIGw7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQmlnTmFubyhlLCBuLCB0LCBvLCByKSB7XG4gIGlmICg2ID09PSBuKSB7XG4gICAgY29uc3QgbiA9IChlID0+IGVbMF0gKyBlWzFdIC8gVW8pKGUpO1xuICAgIHJldHVybiBbIHJvdW5kQnlJbmMobiwgdCwgbyksIDAgXTtcbiAgfVxuICByZXR1cm4gcm91bmRCaWdOYW5vQnlJbmMoZSwgY29tcHV0ZU5hbm9JbmMobiwgdCksIG8sIHIpO1xufVxuXG5mdW5jdGlvbiByb3VuZEJpZ05hbm9CeUluYyhlLCBuLCB0LCBvKSB7XG4gIGxldCBbciwgaV0gPSBlO1xuICBvICYmIGkgPCAwICYmIChpICs9IFVvLCByIC09IDEpO1xuICBjb25zdCBbYSwgc10gPSBkaXZNb2RGbG9vcihyb3VuZEJ5SW5jKGksIG4sIHQpLCBVbyk7XG4gIHJldHVybiBjcmVhdGVCaWdOYW5vKHIgKyBhLCBzKTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeUluYyhlLCBuLCB0KSB7XG4gIHJldHVybiByb3VuZFdpdGhNb2RlKGUgLyBuLCB0KSAqIG47XG59XG5cbmZ1bmN0aW9uIHJvdW5kV2l0aE1vZGUoZSwgbikge1xuICByZXR1cm4gYWlbbl0oZSk7XG59XG5cbmZ1bmN0aW9uIG51ZGdlRGF5VGltZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGkpIHtcbiAgY29uc3QgYSA9IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksIHMgPSBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgYyA9IHJvdW5kQmlnTmFubyhzLCBvLCByLCBpKSwgdSA9IGRpZmZCaWdOYW5vcyhzLCBjKSwgZiA9IE1hdGguc2lnbihjWzBdIC0gc1swXSkgPT09IGEsIGwgPSBuYW5vVG9EdXJhdGlvbkRheVRpbWVGaWVsZHMoYywgTWF0aC5taW4odCwgNikpO1xuICByZXR1cm4gWyB7XG4gICAgLi4uZSxcbiAgICAuLi5sXG4gIH0sIGFkZEJpZ05hbm9zKG4sIHUpLCBmIF07XG59XG5cbmZ1bmN0aW9uIG51ZGdlWm9uZWRUaW1lRHVyYXRpb24oZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYywgdSkge1xuICBjb25zdCBmID0gY29tcHV0ZUR1cmF0aW9uU2lnbihlKSB8fCAxLCBsID0gYmlnTmFub1RvTnVtYmVyKGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKGUsIDUpKSwgZCA9IGNvbXB1dGVOYW5vSW5jKG8sIHIpO1xuICBsZXQgbSA9IHJvdW5kQnlJbmMobCwgZCwgaSk7XG4gIGNvbnN0IFtwLCBoXSA9IGNsYW1wUmVsYXRpdmVEdXJhdGlvbihhLCB7XG4gICAgLi4uZSxcbiAgICAuLi5oclxuICB9LCA2LCBmLCBzLCBjLCB1KSwgZyA9IG0gLSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKHAsIGgpKTtcbiAgbGV0IEQgPSAwO1xuICBnICYmIE1hdGguc2lnbihnKSAhPT0gZiA/IG4gPSBtb3ZlQmlnTmFubyhwLCBtKSA6IChEICs9IGYsIG0gPSByb3VuZEJ5SW5jKGcsIGQsIGkpLCBcbiAgbiA9IG1vdmVCaWdOYW5vKGgsIG0pKTtcbiAgY29uc3QgVCA9IG5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyhtKTtcbiAgcmV0dXJuIFsge1xuICAgIC4uLmUsXG4gICAgLi4uVCxcbiAgICBkYXlzOiBlLmRheXMgKyBEXG4gIH0sIG4sIEJvb2xlYW4oRCkgXTtcbn1cblxuZnVuY3Rpb24gbnVkZ2VSZWxhdGl2ZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUpIHtcbiAgY29uc3QgZiA9IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksIGwgPSBwW29dLCBkID0gZ3IobywgZSk7XG4gIDcgPT09IG8gJiYgKGUgPSB7XG4gICAgLi4uZSxcbiAgICB3ZWVrczogZS53ZWVrcyArIE1hdGgudHJ1bmMoZS5kYXlzIC8gNylcbiAgfSk7XG4gIGNvbnN0IG0gPSBkaXZUcnVuYyhlW2xdLCByKSAqIHI7XG4gIGRbbF0gPSBtO1xuICBjb25zdCBbaCwgZ10gPSBjbGFtcFJlbGF0aXZlRHVyYXRpb24oYSwgZCwgbywgciAqIGYsIHMsIGMsIHUpLCBEID0gbSArIGNvbXB1dGVFcG9jaE5hbm9GcmFjKG4sIGgsIGcpICogZiAqIHIsIFQgPSByb3VuZEJ5SW5jKEQsIHIsIGkpLCBJID0gTWF0aC5zaWduKFQgLSBEKSA9PT0gZjtcbiAgcmV0dXJuIGRbbF0gPSBULCBbIGQsIEkgPyBnIDogaCwgSSBdO1xufVxuXG5mdW5jdGlvbiBrZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IFtyLCBpLCBhLCBzXSA9IChlID0+IHtcbiAgICBjb25zdCBuID0gcmVmaW5lVGltZURpc3BsYXlUdXBsZShlID0gbm9ybWFsaXplT3B0aW9ucyhlKSk7XG4gICAgcmV0dXJuIFsgZS50aW1lWm9uZSwgLi4ubiBdO1xuICB9KShvKSwgYyA9IHZvaWQgMCAhPT0gcjtcbiAgcmV0dXJuICgoZSwgbiwgdCwgbywgciwgaSkgPT4ge1xuICAgIHQgPSByb3VuZEJpZ05hbm9CeUluYyh0LCByLCBvLCAxKTtcbiAgICBjb25zdCBhID0gbi5SKHQpO1xuICAgIHJldHVybiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlcG9jaE5hbm9Ub0lzbyh0LCBhKSwgaSkgKyAoZSA/IFNlKHJvdW5kVG9NaW51dGUoYSkpIDogXCJaXCIpO1xuICB9KShjLCBuKGMgPyBlKHIpIDogc2kpLCB0LmVwb2NoTmFub3NlY29uZHMsIGksIGEsIHMpO1xufVxuXG5mdW5jdGlvbiBGZShlLCBuLCB0KSB7XG4gIGNvbnN0IFtvLCByLCBpLCBhLCBzLCBjXSA9IChlID0+IHtcbiAgICBlID0gbm9ybWFsaXplT3B0aW9ucyhlKTtcbiAgICBjb25zdCBuID0gdGkoZSksIHQgPSByZWZpbmVTdWJzZWNEaWdpdHMoZSksIG8gPSByaShlKSwgciA9IGlpKGUsIDQpLCBpID0gSnIoZSwgNCk7XG4gICAgcmV0dXJuIFsgbiwgb2koZSksIG8sIHIsIC4uLnJlZmluZVNtYWxsZXN0VW5pdEFuZFN1YnNlY0RpZ2l0cyhpLCB0KSBdO1xuICB9KSh0KTtcbiAgcmV0dXJuICgoZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYywgdSkgPT4ge1xuICAgIG8gPSByb3VuZEJpZ05hbm9CeUluYyhvLCBjLCBzLCAxKTtcbiAgICBjb25zdCBmID0gZSh0KS5SKG8pO1xuICAgIHJldHVybiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlcG9jaE5hbm9Ub0lzbyhvLCBmKSwgdSkgKyBTZShyb3VuZFRvTWludXRlKGYpLCBhKSArICgoZSwgbikgPT4gMSAhPT0gbiA/IFwiW1wiICsgKDIgPT09IG4gPyBcIiFcIiA6IFwiXCIpICsgZSArIFwiXVwiIDogXCJcIikodCwgaSkgKyBmb3JtYXRDYWxlbmRhcihuLCByKTtcbiAgfSkoZSwgbi5jYWxlbmRhciwgbi50aW1lWm9uZSwgbi5lcG9jaE5hbm9zZWNvbmRzLCBvLCByLCBpLCBhLCBzLCBjKTtcbn1cblxuZnVuY3Rpb24gRnQoZSwgbikge1xuICBjb25zdCBbdCwgbywgciwgaV0gPSAoZSA9PiAoZSA9IG5vcm1hbGl6ZU9wdGlvbnMoZSksIFsgdGkoZSksIC4uLnJlZmluZVRpbWVEaXNwbGF5VHVwbGUoZSkgXSkpKG4pO1xuICByZXR1cm4gYSA9IGUuY2FsZW5kYXIsIHMgPSB0LCBjID0gaSwgZm9ybWF0SXNvRGF0ZVRpbWVGaWVsZHMocm91bmREYXRlVGltZVRvTmFubyhlLCByLCBvKSwgYykgKyBmb3JtYXRDYWxlbmRhcihhLCBzKTtcbiAgdmFyIGEsIHMsIGM7XG59XG5cbmZ1bmN0aW9uIGNlKGUsIG4pIHtcbiAgcmV0dXJuIHQgPSBlLmNhbGVuZGFyLCBvID0gZSwgciA9IHJlZmluZURhdGVEaXNwbGF5T3B0aW9ucyhuKSwgZm9ybWF0SXNvRGF0ZUZpZWxkcyhvKSArIGZvcm1hdENhbGVuZGFyKHQsIHIpO1xuICB2YXIgdCwgbywgcjtcbn1cblxuZnVuY3Rpb24gS3QoZSwgbikge1xuICByZXR1cm4gZm9ybWF0RGF0ZUxpa2VJc28oZS5jYWxlbmRhciwgZm9ybWF0SXNvWWVhck1vbnRoRmllbGRzLCBlLCByZWZpbmVEYXRlRGlzcGxheU9wdGlvbnMobikpO1xufVxuXG5mdW5jdGlvbiBKdChlLCBuKSB7XG4gIHJldHVybiBmb3JtYXREYXRlTGlrZUlzbyhlLmNhbGVuZGFyLCBmb3JtYXRJc29Nb250aERheUZpZWxkcywgZSwgcmVmaW5lRGF0ZURpc3BsYXlPcHRpb25zKG4pKTtcbn1cblxuZnVuY3Rpb24gY3QoZSwgbikge1xuICBjb25zdCBbdCwgbywgcl0gPSByZWZpbmVUaW1lRGlzcGxheU9wdGlvbnMobik7XG4gIHJldHVybiBpID0gciwgZm9ybWF0SXNvVGltZUZpZWxkcyhyb3VuZFRpbWVUb05hbm8oZSwgbywgdClbMF0sIGkpO1xuICB2YXIgaTtcbn1cblxuZnVuY3Rpb24gayhlLCBuKSB7XG4gIGNvbnN0IFt0LCBvLCByXSA9IHJlZmluZVRpbWVEaXNwbGF5T3B0aW9ucyhuLCAzKTtcbiAgcmV0dXJuIG8gPiAxICYmIGNoZWNrRHVyYXRpb25Vbml0cyhlID0ge1xuICAgIC4uLmUsXG4gICAgLi4ucm91bmREYXlUaW1lRHVyYXRpb25CeUluYyhlLCBvLCB0KVxuICB9KSwgKChlLCBuKSA9PiB7XG4gICAgY29uc3Qge3NpZ246IHR9ID0gZSwgbyA9IC0xID09PSB0ID8gbmVnYXRlRHVyYXRpb25GaWVsZHMoZSkgOiBlLCB7aG91cnM6IHIsIG1pbnV0ZXM6IGl9ID0gbywgW2EsIHNdID0gZGl2TW9kQmlnTmFubyhkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhvLCAzKSwgUm8sIGRpdk1vZFRydW5jKTtcbiAgICBjaGVja0R1cmF0aW9uVGltZVVuaXQoYSk7XG4gICAgY29uc3QgYyA9IGZvcm1hdFN1YnNlY05hbm8ocywgbiksIHUgPSBuID49IDAgfHwgIXQgfHwgYztcbiAgICByZXR1cm4gKHQgPCAwID8gXCItXCIgOiBcIlwiKSArIFwiUFwiICsgZm9ybWF0RHVyYXRpb25GcmFnbWVudHMoe1xuICAgICAgWTogZm9ybWF0RHVyYXRpb25OdW1iZXIoby55ZWFycyksXG4gICAgICBNOiBmb3JtYXREdXJhdGlvbk51bWJlcihvLm1vbnRocyksXG4gICAgICBXOiBmb3JtYXREdXJhdGlvbk51bWJlcihvLndlZWtzKSxcbiAgICAgIEQ6IGZvcm1hdER1cmF0aW9uTnVtYmVyKG8uZGF5cylcbiAgICB9KSArIChyIHx8IGkgfHwgYSB8fCB1ID8gXCJUXCIgKyBmb3JtYXREdXJhdGlvbkZyYWdtZW50cyh7XG4gICAgICBIOiBmb3JtYXREdXJhdGlvbk51bWJlcihyKSxcbiAgICAgIE06IGZvcm1hdER1cmF0aW9uTnVtYmVyKGkpLFxuICAgICAgUzogZm9ybWF0RHVyYXRpb25OdW1iZXIoYSwgdSkgKyBjXG4gICAgfSkgOiBcIlwiKTtcbiAgfSkoZSwgcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGVMaWtlSXNvKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IG8gPiAxIHx8IDAgPT09IG8gJiYgZSAhPT0gbDtcbiAgcmV0dXJuIDEgPT09IG8gPyBlID09PSBsID8gbih0KSA6IGZvcm1hdElzb0RhdGVGaWVsZHModCkgOiByID8gZm9ybWF0SXNvRGF0ZUZpZWxkcyh0KSArIGZvcm1hdENhbGVuZGFySWQoZSwgMiA9PT0gbykgOiBuKHQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREdXJhdGlvbkZyYWdtZW50cyhlKSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgZm9yIChjb25zdCB0IGluIGUpIHtcbiAgICBjb25zdCBvID0gZVt0XTtcbiAgICBvICYmIG4ucHVzaChvLCB0KTtcbiAgfVxuICByZXR1cm4gbi5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlLCBuKSB7XG4gIHJldHVybiBmb3JtYXRJc29EYXRlRmllbGRzKGUpICsgXCJUXCIgKyBmb3JtYXRJc29UaW1lRmllbGRzKGUsIG4pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29EYXRlRmllbGRzKGUpIHtcbiAgcmV0dXJuIGZvcm1hdElzb1llYXJNb250aEZpZWxkcyhlKSArIFwiLVwiICsgYm8oZS5pc29EYXkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29ZZWFyTW9udGhGaWVsZHMoZSkge1xuICBjb25zdCB7aXNvWWVhcjogbn0gPSBlO1xuICByZXR1cm4gKG4gPCAwIHx8IG4gPiA5OTk5ID8gZ2V0U2lnblN0cihuKSArIHBhZE51bWJlcig2LCBNYXRoLmFicyhuKSkgOiBwYWROdW1iZXIoNCwgbikpICsgXCItXCIgKyBibyhlLmlzb01vbnRoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SXNvTW9udGhEYXlGaWVsZHMoZSkge1xuICByZXR1cm4gYm8oZS5pc29Nb250aCkgKyBcIi1cIiArIGJvKGUuaXNvRGF5KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SXNvVGltZUZpZWxkcyhlLCBuKSB7XG4gIGNvbnN0IHQgPSBbIGJvKGUuaXNvSG91ciksIGJvKGUuaXNvTWludXRlKSBdO1xuICByZXR1cm4gLTEgIT09IG4gJiYgdC5wdXNoKGJvKGUuaXNvU2Vjb25kKSArICgoZSwgbiwgdCwgbykgPT4gZm9ybWF0U3Vic2VjTmFubyhlICogUWUgKyBuICogWW8gKyB0LCBvKSkoZS5pc29NaWxsaXNlY29uZCwgZS5pc29NaWNyb3NlY29uZCwgZS5pc29OYW5vc2Vjb25kLCBuKSksIFxuICB0LmpvaW4oXCI6XCIpO1xufVxuXG5mdW5jdGlvbiBTZShlLCBuID0gMCkge1xuICBpZiAoMSA9PT0gbikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IFt0LCBvXSA9IGRpdk1vZEZsb29yKE1hdGguYWJzKGUpLCB6byksIFtyLCBpXSA9IGRpdk1vZEZsb29yKG8sIFpvKSwgW2EsIHNdID0gZGl2TW9kRmxvb3IoaSwgUm8pO1xuICByZXR1cm4gZ2V0U2lnblN0cihlKSArIGJvKHQpICsgXCI6XCIgKyBibyhyKSArIChhIHx8IHMgPyBcIjpcIiArIGJvKGEpICsgZm9ybWF0U3Vic2VjTmFubyhzKSA6IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRDYWxlbmRhcihlLCBuKSB7XG4gIHJldHVybiAxICE9PSBuICYmIChuID4gMSB8fCAwID09PSBuICYmIGUgIT09IGwpID8gZm9ybWF0Q2FsZW5kYXJJZChlLCAyID09PSBuKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhbGVuZGFySWQoZSwgbikge1xuICByZXR1cm4gXCJbXCIgKyAobiA/IFwiIVwiIDogXCJcIikgKyBcInUtY2E9XCIgKyBlICsgXCJdXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFN1YnNlY05hbm8oZSwgbikge1xuICBsZXQgdCA9IHBhZE51bWJlcig5LCBlKTtcbiAgcmV0dXJuIHQgPSB2b2lkIDAgPT09IG4gPyB0LnJlcGxhY2UobGksIFwiXCIpIDogdC5zbGljZSgwLCBuKSwgdCA/IFwiLlwiICsgdCA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGdldFNpZ25TdHIoZSkge1xuICByZXR1cm4gZSA8IDAgPyBcIi1cIiA6IFwiK1wiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREdXJhdGlvbk51bWJlcihlLCBuKSB7XG4gIHJldHVybiBlIHx8IG4gPyBlLnRvTG9jYWxlU3RyaW5nKFwiZnVsbHdpZGVcIiwge1xuICAgIHVzZUdyb3VwaW5nOiAwXG4gIH0pIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gX3pvbmVkRXBvY2hTbG90c1RvSXNvKGUsIG4pIHtcbiAgY29uc3Qge2Vwb2NoTmFub3NlY29uZHM6IHR9ID0gZSwgbyA9IChuLlIgPyBuIDogbihlLnRpbWVab25lKSkuUih0KSwgciA9IGVwb2NoTmFub1RvSXNvKHQsIG8pO1xuICByZXR1cm4ge1xuICAgIGNhbGVuZGFyOiBlLmNhbGVuZGFyLFxuICAgIC4uLnIsXG4gICAgb2Zmc2V0TmFub3NlY29uZHM6IG9cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hpbmdJbnN0YW50Rm9yKGUsIG4sIHQsIG8gPSAwLCByID0gMCwgaSwgYSkge1xuICBpZiAodm9pZCAwICE9PSB0ICYmIDEgPT09IG8gJiYgKDEgPT09IG8gfHwgYSkpIHtcbiAgICByZXR1cm4gaXNvVG9FcG9jaE5hbm9XaXRoT2Zmc2V0KG4sIHQpO1xuICB9XG4gIGNvbnN0IHMgPSBlLkkobik7XG4gIGlmICh2b2lkIDAgIT09IHQgJiYgMyAhPT0gbykge1xuICAgIGNvbnN0IGUgPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBpc29Ub0Vwb2NoTmFubyhuKTtcbiAgICAgIG8gJiYgKHQgPSByb3VuZFRvTWludXRlKHQpKTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICAgIGxldCBlID0gYmlnTmFub1RvTnVtYmVyKGRpZmZCaWdOYW5vcyhuLCByKSk7XG4gICAgICAgIGlmIChvICYmIChlID0gcm91bmRUb01pbnV0ZShlKSksIGUgPT09IHQpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHMsIG4sIHQsIGkpO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBpZiAoMCA9PT0gbykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYSA/IGlzb1RvRXBvY2hOYW5vKG4pIDogZ2V0U2luZ2xlSW5zdGFudEZvcihlLCBuLCByLCBzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2luZ2xlSW5zdGFudEZvcihlLCBuLCB0ID0gMCwgbyA9IGUuSShuKSkge1xuICBpZiAoMSA9PT0gby5sZW5ndGgpIHtcbiAgICByZXR1cm4gb1swXTtcbiAgfVxuICBpZiAoMSA9PT0gdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFRvKTtcbiAgfVxuICBpZiAoby5sZW5ndGgpIHtcbiAgICByZXR1cm4gb1szID09PSB0ID8gMSA6IDBdO1xuICB9XG4gIGNvbnN0IHIgPSBpc29Ub0Vwb2NoTmFubyhuKSwgaSA9ICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSBlLlIobW92ZUJpZ05hbm8obiwgLVVvKSk7XG4gICAgcmV0dXJuIChlID0+IHtcbiAgICAgIGlmIChlID4gVW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZ28pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSkoZS5SKG1vdmVCaWdOYW5vKG4sIFVvKSkgLSB0KTtcbiAgfSkoZSwgciksIGEgPSBpICogKDIgPT09IHQgPyAtMSA6IDEpO1xuICByZXR1cm4gKG8gPSBlLkkoZXBvY2hOYW5vVG9Jc28ociwgYSkpKVsyID09PSB0ID8gMCA6IG8ubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKGUsIG4pIHtcbiAgY29uc3QgdCA9IGUuSShuKTtcbiAgaWYgKHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRbMF07XG4gIH1cbiAgY29uc3QgbyA9IG1vdmVCaWdOYW5vKGlzb1RvRXBvY2hOYW5vKG4pLCAtVW8pO1xuICByZXR1cm4gZS5PKG8sIDEpO1xufVxuXG5mdW5jdGlvbiBZZShlLCBuLCB0KSB7XG4gIHJldHVybiB4ZShjaGVja0Vwb2NoTmFub0luQm91bmRzKGFkZEJpZ05hbm9zKG4uZXBvY2hOYW5vc2Vjb25kcywgKGUgPT4ge1xuICAgIGlmIChkdXJhdGlvbkhhc0RhdGVQYXJ0cyhlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3Iodm8pO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSwgNSk7XG4gIH0pKGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyh0KSA6IHQpKSkpO1xufVxuXG5mdW5jdGlvbiBwZShlLCBuLCB0LCBvLCByLCBpID0gT2JqZWN0LmNyZWF0ZShudWxsKSkge1xuICBjb25zdCBhID0gbihvLnRpbWVab25lKSwgcyA9IGUoby5jYWxlbmRhcik7XG4gIHJldHVybiB7XG4gICAgLi4ubyxcbiAgICAuLi5tb3ZlWm9uZWRFcG9jaHMoYSwgcywgbywgdCA/IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKHIpIDogciwgaSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3QoZSwgbiwgdCwgbywgciA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgY29uc3Qge2NhbGVuZGFyOiBpfSA9IHQ7XG4gIHJldHVybiBqdChtb3ZlRGF0ZVRpbWUoZShpKSwgdCwgbiA/IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKG8pIDogbywgciksIGkpO1xufVxuXG5mdW5jdGlvbiBuZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogaX0gPSB0O1xuICByZXR1cm4gVyhtb3ZlRGF0ZShlKGkpLCB0LCBuID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobykgOiBvLCByKSwgaSk7XG59XG5cbmZ1bmN0aW9uIEd0KGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IHQuY2FsZW5kYXIsIGEgPSBlKGkpO1xuICBsZXQgcyA9IGNoZWNrSXNvRGF0ZUluQm91bmRzKG1vdmVUb0RheU9mTW9udGhVbnNhZmUoYSwgdCkpO1xuICBuICYmIChvID0gQihvKSksIG8uc2lnbiA8IDAgJiYgKHMgPSBhLlAocywge1xuICAgIC4uLnByLFxuICAgIG1vbnRoczogMVxuICB9KSwgcyA9IG1vdmVCeURheXMocywgLTEpKTtcbiAgY29uc3QgYyA9IGEuUChzLCBvLCByKTtcbiAgcmV0dXJuIGNyZWF0ZVBsYWluWWVhck1vbnRoU2xvdHMobW92ZVRvRGF5T2ZNb250aFVuc2FmZShhLCBjKSwgaSk7XG59XG5cbmZ1bmN0aW9uIGF0KGUsIG4sIHQpIHtcbiAgcmV0dXJuIFN0KG1vdmVUaW1lKG4sIGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyh0KSA6IHQpWzBdKTtcbn1cblxuZnVuY3Rpb24gbW92ZVpvbmVkRXBvY2hzKGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKG8sIDUpO1xuICBsZXQgYSA9IHQuZXBvY2hOYW5vc2Vjb25kcztcbiAgaWYgKGR1cmF0aW9uSGFzRGF0ZVBhcnRzKG8pKSB7XG4gICAgY29uc3QgcyA9IGhlKHQsIGUpO1xuICAgIGEgPSBhZGRCaWdOYW5vcyhnZXRTaW5nbGVJbnN0YW50Rm9yKGUsIHtcbiAgICAgIC4uLm1vdmVEYXRlKG4sIHMsIHtcbiAgICAgICAgLi4ubyxcbiAgICAgICAgLi4uaHJcbiAgICAgIH0sIHIpLFxuICAgICAgLi4ubm4odywgcylcbiAgICB9KSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgYSA9IGFkZEJpZ05hbm9zKGEsIGkpLCBtdChyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVwb2NoTmFub3NlY29uZHM6IGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW92ZURhdGVUaW1lKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgW3IsIGldID0gbW92ZVRpbWUobiwgdCk7XG4gIHJldHVybiBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLm1vdmVEYXRlKGUsIG4sIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi5ocixcbiAgICAgIGRheXM6IHQuZGF5cyArIGlcbiAgICB9LCBvKSxcbiAgICAuLi5yXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGF0ZShlLCBuLCB0LCBvKSB7XG4gIGlmICh0LnllYXJzIHx8IHQubW9udGhzIHx8IHQud2Vla3MpIHtcbiAgICByZXR1cm4gZS5QKG4sIHQsIG8pO1xuICB9XG4gIG10KG8pO1xuICBjb25zdCByID0gdC5kYXlzICsgZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8odCwgNSlbMF07XG4gIHJldHVybiByID8gY2hlY2tJc29EYXRlSW5Cb3VuZHMobW92ZUJ5RGF5cyhuLCByKSkgOiBuO1xufVxuXG5mdW5jdGlvbiBtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKGUsIG4sIHQgPSAxKSB7XG4gIHJldHVybiBtb3ZlQnlEYXlzKG4sIHQgLSBlLmRheShuKSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVUaW1lKGUsIG4pIHtcbiAgY29uc3QgW3QsIG9dID0gZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8obiwgNSksIFtyLCBpXSA9IG5hbm9Ub0lzb1RpbWVBbmREYXkoaXNvVGltZUZpZWxkc1RvTmFubyhlKSArIG8pO1xuICByZXR1cm4gWyByLCB0ICsgaSBdO1xufVxuXG5mdW5jdGlvbiBtb3ZlQnlEYXlzKGUsIG4pIHtcbiAgcmV0dXJuIG4gPyB7XG4gICAgLi4uZSxcbiAgICAuLi5lcG9jaE1pbGxpVG9Jc28oaXNvVG9FcG9jaE1pbGxpKGUpICsgbiAqIGtvKVxuICB9IDogZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFya2VyU3lzdGVtKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IGUodC5jYWxlbmRhcik7XG4gIHJldHVybiBpc1pvbmVkRXBvY2hTbG90cyh0KSA/IFsgdCwgbywgbih0LnRpbWVab25lKSBdIDogWyB7XG4gICAgLi4udCxcbiAgICAuLi5OdFxuICB9LCBvIF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtlclRvRXBvY2hOYW5vKGUpIHtcbiAgcmV0dXJuIGUgPyBleHRyYWN0RXBvY2hOYW5vIDogaXNvVG9FcG9jaE5hbm87XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vdmVNYXJrZXIoZSkge1xuICByZXR1cm4gZSA/IFB0KG1vdmVab25lZEVwb2NocywgZSkgOiBtb3ZlRGF0ZVRpbWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZNYXJrZXJzKGUpIHtcbiAgcmV0dXJuIGUgPyBQdChkaWZmWm9uZWRFcG9jaHNFeGFjdCwgZSkgOiBkaWZmRGF0ZVRpbWVzRXhhY3Q7XG59XG5cbmZ1bmN0aW9uIGlzWm9uZWRFcG9jaFNsb3RzKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5lcG9jaE5hbm9zZWNvbmRzO1xufVxuXG5mdW5jdGlvbiBpc1VuaWZvcm1Vbml0KGUsIG4pIHtcbiAgcmV0dXJuIGUgPD0gNiAtIChpc1pvbmVkRXBvY2hTbG90cyhuKSA/IDEgOiAwKTtcbn1cblxuZnVuY3Rpb24gRShlLCBuLCB0LCBvLCByLCBpLCBhKSB7XG4gIGNvbnN0IHMgPSBlKG5vcm1hbGl6ZU9wdGlvbnMoYSkucmVsYXRpdmVUbyksIGMgPSBNYXRoLm1heChnZXRNYXhEdXJhdGlvblVuaXQociksIGdldE1heER1cmF0aW9uVW5pdChpKSk7XG4gIGlmIChpc1VuaWZvcm1Vbml0KGMsIHMpKSB7XG4gICAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cygoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBhZGRCaWdOYW5vcyhkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8obiksIG8gPyAtMSA6IDEpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoclswXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHIsXG4gICAgICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhyLCB0KVxuICAgICAgfTtcbiAgICB9KShyLCBpLCBjLCBvKSkpO1xuICB9XG4gIGlmICghcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHlvKTtcbiAgfVxuICBvICYmIChpID0gbmVnYXRlRHVyYXRpb25GaWVsZHMoaSkpO1xuICBjb25zdCBbdSwgZiwgbF0gPSBjcmVhdGVNYXJrZXJTeXN0ZW0obiwgdCwgcyksIGQgPSBjcmVhdGVNb3ZlTWFya2VyKGwpLCBtID0gY3JlYXRlRGlmZk1hcmtlcnMobCksIHAgPSBkKGYsIHUsIHIpO1xuICByZXR1cm4gT2UobShmLCB1LCBkKGYsIHAsIGkpLCBjKSk7XG59XG5cbmZ1bmN0aW9uIFYoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0TWF4RHVyYXRpb25Vbml0KG8pLCBbYSwgcywgYywgdSwgZl0gPSAoKGUsIG4sIHQpID0+IHtcbiAgICBlID0gbm9ybWFsaXplT3B0aW9uc09yU3RyaW5nKGUsIFJyKTtcbiAgICBsZXQgbyA9IEtyKGUpO1xuICAgIGNvbnN0IHIgPSB0KGVbQXJdKTtcbiAgICBsZXQgaSA9IHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKGUpO1xuICAgIGNvbnN0IGEgPSBpaShlLCA3KTtcbiAgICBsZXQgcyA9IEpyKGUpO1xuICAgIGlmICh2b2lkIDAgPT09IG8gJiYgdm9pZCAwID09PSBzKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihQbyk7XG4gICAgfVxuICAgIGlmIChudWxsID09IHMgJiYgKHMgPSAwKSwgbnVsbCA9PSBvICYmIChvID0gTWF0aC5tYXgocywgbikpLCBjaGVja0xhcmdlc3RTbWFsbGVzdFVuaXQobywgcyksIFxuICAgIGkgPSByZWZpbmVSb3VuZGluZ0luYyhpLCBzLCAxKSwgaSA+IDEgJiYgcyA+IDUgJiYgbyAhPT0gcykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGb3IgY2FsZW5kYXIgdW5pdHMgd2l0aCByb3VuZGluZ0luY3JlbWVudCA+IDEsIHVzZSBsYXJnZXN0VW5pdCA9IHNtYWxsZXN0VW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFsgbywgcywgaSwgYSwgciBdO1xuICB9KShyLCBpLCBlKSwgbCA9IE1hdGgubWF4KGksIGEpO1xuICBpZiAoIWYgJiYgbCA8PSA2KSB7XG4gICAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cygoKGUsIG4sIHQsIG8sIHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSByb3VuZEJpZ05hbm8oZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSksIHQsIG8sIHIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHIsXG4gICAgICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhpLCBuKVxuICAgICAgfTtcbiAgICB9KShvLCBhLCBzLCBjLCB1KSkpO1xuICB9XG4gIGlmICghaXNab25lZEVwb2NoU2xvdHMoZikgJiYgIW8uc2lnbikge1xuICAgIHJldHVybiBvO1xuICB9XG4gIGlmICghZikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHlvKTtcbiAgfVxuICBjb25zdCBbZCwgbSwgcF0gPSBjcmVhdGVNYXJrZXJTeXN0ZW0obiwgdCwgZiksIGggPSBjcmVhdGVNYXJrZXJUb0Vwb2NoTmFubyhwKSwgZyA9IGNyZWF0ZU1vdmVNYXJrZXIocCksIEQgPSBjcmVhdGVEaWZmTWFya2VycyhwKSwgVCA9IGcobSwgZCwgbyk7XG4gIGlzWm9uZWRFcG9jaFNsb3RzKGYpIHx8IChjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoZCksIGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyhUKSk7XG4gIGxldCBJID0gRChtLCBkLCBULCBhKTtcbiAgY29uc3QgTSA9IG8uc2lnbiwgTiA9IGNvbXB1dGVEdXJhdGlvblNpZ24oSSk7XG4gIGlmIChNICYmIE4gJiYgTSAhPT0gTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZvKTtcbiAgfVxuICByZXR1cm4gSSA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihJLCBoKFQpLCBhLCBzLCBjLCB1LCBtLCBkLCBoLCBnKSwgT2UoSSk7XG59XG5cbmZ1bmN0aW9uIFkoZSkge1xuICByZXR1cm4gLTEgPT09IGUuc2lnbiA/IEIoZSkgOiBlO1xufVxuXG5mdW5jdGlvbiBCKGUpIHtcbiAgcmV0dXJuIE9lKG5lZ2F0ZUR1cmF0aW9uRmllbGRzKGUpKTtcbn1cblxuZnVuY3Rpb24gbmVnYXRlRHVyYXRpb25GaWVsZHMoZSkge1xuICBjb25zdCBuID0ge307XG4gIGZvciAoY29uc3QgdCBvZiBwKSB7XG4gICAgblt0XSA9IC0xICogZVt0XSB8fCAwO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiB5KGUpIHtcbiAgcmV0dXJuICFlLnNpZ247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEdXJhdGlvblNpZ24oZSwgbiA9IHApIHtcbiAgbGV0IHQgPSAwO1xuICBmb3IgKGNvbnN0IG8gb2Ygbikge1xuICAgIGNvbnN0IG4gPSBNYXRoLnNpZ24oZVtvXSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICh0ICYmIHQgIT09IG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoTm8pO1xuICAgICAgfVxuICAgICAgdCA9IG47XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uVW5pdHMoZSkge1xuICBmb3IgKGNvbnN0IG4gb2YgZHIpIHtcbiAgICBjbGFtcEVudGl0eShuLCBlW25dLCAtZGksIGRpLCAxKTtcbiAgfVxuICByZXR1cm4gY2hlY2tEdXJhdGlvblRpbWVVbml0KGJpZ05hbm9Ub051bWJlcihkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgUm8pKSwgZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvblRpbWVVbml0KGUpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKE1vKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlLCBuID0gNikge1xuICByZXR1cm4gZ2l2ZW5GaWVsZHNUb0JpZ05hbm8oZSwgbiwgcCk7XG59XG5cbmZ1bmN0aW9uIG5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhlLCBuID0gNikge1xuICBjb25zdCBbdCwgb10gPSBlLCByID0gbmFub1RvR2l2ZW5GaWVsZHMobywgbiwgcCk7XG4gIGlmIChyW3Bbbl1dICs9IHQgKiAoVW8gLyBBb1tuXSksICFOdW1iZXIuaXNGaW5pdGUocltwW25dXSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihJbyk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyhlLCBuID0gNSkge1xuICByZXR1cm4gbmFub1RvR2l2ZW5GaWVsZHMoZSwgbiwgcCk7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uSGFzRGF0ZVBhcnRzKGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY29tcHV0ZUR1cmF0aW9uU2lnbihlLCBscikpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhEdXJhdGlvblVuaXQoZSkge1xuICBsZXQgbiA9IDk7XG4gIGZvciAoO24gPiAwICYmICFlW3Bbbl1dOyBuLS0pIHt9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTcGxpdFR1cGxlKGUsIG4pIHtcbiAgcmV0dXJuIFsgZSwgbiBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUGVyaW9kKGUpIHtcbiAgY29uc3QgbiA9IE1hdGguZmxvb3IoZSAvIGNpKSAqIGNpO1xuICByZXR1cm4gWyBuLCBuICsgY2kgXTtcbn1cblxuZnVuY3Rpb24gV2UoZSkge1xuICBjb25zdCBuID0gcGFyc2VEYXRlVGltZUxpa2UoZSA9IHRvU3RyaW5nVmlhUHJpbWl0aXZlKGUpKTtcbiAgaWYgKCFuKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIGxldCB0O1xuICBpZiAobi5qKSB7XG4gICAgdCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFuLm9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICAgIH1cbiAgICB0ID0gcGFyc2VPZmZzZXROYW5vKG4ub2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gbi50aW1lWm9uZSAmJiBwYXJzZU9mZnNldE5hbm9NYXliZShuLnRpbWVab25lLCAxKSwgeGUoaXNvVG9FcG9jaE5hbm9XaXRoT2Zmc2V0KGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMobiksIHQpKTtcbn1cblxuZnVuY3Rpb24gSChlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZURhdGVUaW1lTGlrZShtKGUpKTtcbiAgaWYgKCFuKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIGlmIChuLnRpbWVab25lKSB7XG4gICAgcmV0dXJuIGZpbmFsaXplWm9uZWREYXRlVGltZShuLCBuLm9mZnNldCA/IHBhcnNlT2Zmc2V0TmFubyhuLm9mZnNldCkgOiB2b2lkIDApO1xuICB9XG4gIGlmIChuLmopIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRGF0ZShuKTtcbn1cblxuZnVuY3Rpb24gQWUoZSwgbikge1xuICBjb25zdCB0ID0gcGFyc2VEYXRlVGltZUxpa2UobShlKSk7XG4gIGlmICghdCB8fCAhdC50aW1lWm9uZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZhaWxlZFBhcnNlKGUpKTtcbiAgfVxuICBjb25zdCB7b2Zmc2V0OiBvfSA9IHQsIHIgPSBvID8gcGFyc2VPZmZzZXROYW5vKG8pIDogdm9pZCAwLCBbLCBpLCBhXSA9IGplKG4pO1xuICByZXR1cm4gZmluYWxpemVab25lZERhdGVUaW1lKHQsIHIsIGksIGEpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9mZnNldE5hbm8oZSkge1xuICBjb25zdCBuID0gcGFyc2VPZmZzZXROYW5vTWF5YmUoZSk7XG4gIGlmICh2b2lkIDAgPT09IG4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIEJ0KGUpIHtcbiAgY29uc3QgbiA9IHBhcnNlRGF0ZVRpbWVMaWtlKG0oZSkpO1xuICBpZiAoIW4gfHwgbi5qKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBqdChmaW5hbGl6ZURhdGVUaW1lKG4pKTtcbn1cblxuZnVuY3Rpb24gZGUoZSwgbiwgdCkge1xuICBsZXQgbyA9IHBhcnNlRGF0ZVRpbWVMaWtlKG0oZSkpO1xuICBpZiAoIW8gfHwgby5qKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBuID8gby5jYWxlbmRhciA9PT0gbCAmJiAobyA9IC0yNzE4MjEgPT09IG8uaXNvWWVhciAmJiA0ID09PSBvLmlzb01vbnRoID8ge1xuICAgIC4uLm8sXG4gICAgaXNvRGF5OiAyMCxcbiAgICAuLi5OdFxuICB9IDoge1xuICAgIC4uLm8sXG4gICAgaXNvRGF5OiAxLFxuICAgIC4uLk50XG4gIH0pIDogdCAmJiBvLmNhbGVuZGFyID09PSBsICYmIChvID0ge1xuICAgIC4uLm8sXG4gICAgaXNvWWVhcjogQnJcbiAgfSksIFcoby5DID8gZmluYWxpemVEYXRlVGltZShvKSA6IGZpbmFsaXplRGF0ZShvKSk7XG59XG5cbmZ1bmN0aW9uIF90KGUsIG4pIHtcbiAgY29uc3QgdCA9IHBhcnNlWWVhck1vbnRoT25seShtKG4pKTtcbiAgaWYgKHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlzb0NhbGVuZGFyKHQpLCBjcmVhdGVQbGFpblllYXJNb250aFNsb3RzKGNoZWNrSXNvWWVhck1vbnRoSW5Cb3VuZHMoY2hlY2tJc29EYXRlRmllbGRzKHQpKSk7XG4gIH1cbiAgY29uc3QgbyA9IGRlKG4sIDEpO1xuICByZXR1cm4gY3JlYXRlUGxhaW5ZZWFyTW9udGhTbG90cyhtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKGUoby5jYWxlbmRhciksIG8pKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZUlzb0NhbGVuZGFyKGUpIHtcbiAgaWYgKGUuY2FsZW5kYXIgIT09IGwpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKGUuY2FsZW5kYXIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB4dChlLCBuKSB7XG4gIGNvbnN0IHQgPSBwYXJzZU1vbnRoRGF5T25seShtKG4pKTtcbiAgaWYgKHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlzb0NhbGVuZGFyKHQpLCBjcmVhdGVQbGFpbk1vbnRoRGF5U2xvdHMoY2hlY2tJc29EYXRlRmllbGRzKHQpKTtcbiAgfVxuICBjb25zdCBvID0gZGUobiwgMCwgMSksIHtjYWxlbmRhcjogcn0gPSBvLCBpID0gZShyKSwgW2EsIHMsIGNdID0gaS52KG8pLCBbdSwgZl0gPSBpLnEoYSwgcyksIFtsLCBkXSA9IGkuRyh1LCBmLCBjKTtcbiAgcmV0dXJuIGNyZWF0ZVBsYWluTW9udGhEYXlTbG90cyhjaGVja0lzb0RhdGVJbkJvdW5kcyhpLlYobCwgZCwgYykpLCByKTtcbn1cblxuZnVuY3Rpb24gaHQoZSkge1xuICBsZXQgbiwgdCA9IChlID0+IHtcbiAgICBjb25zdCBuID0gUGkuZXhlYyhlKTtcbiAgICByZXR1cm4gbiA/IChvcmdhbml6ZUFubm90YXRpb25QYXJ0cyhuWzEwXSksIG9yZ2FuaXplVGltZVBhcnRzKG4pKSA6IHZvaWQgMDtcbiAgfSkobShlKSk7XG4gIGlmICghdCkge1xuICAgIGlmICh0ID0gcGFyc2VEYXRlVGltZUxpa2UoZSksICF0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gICAgfVxuICAgIGlmICghdC5DKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gICAgfVxuICAgIGlmICh0LmopIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoXCJaXCIpKTtcbiAgICB9XG4gICAgcmVxdWlyZUlzb0NhbGVuZGFyKHQpO1xuICB9XG4gIGlmICgobiA9IHBhcnNlWWVhck1vbnRoT25seShlKSkgJiYgaXNJc29EYXRlRmllbGRzVmFsaWQobikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgaWYgKChuID0gcGFyc2VNb250aERheU9ubHkoZSkpICYmIGlzSXNvRGF0ZUZpZWxkc1ZhbGlkKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBTdChjb25zdHJhaW5Jc29UaW1lRmllbGRzKHQsIDEpKTtcbn1cblxuZnVuY3Rpb24gUihlKSB7XG4gIGNvbnN0IG4gPSAoZSA9PiB7XG4gICAgY29uc3QgbiA9IEZpLmV4ZWMoZSk7XG4gICAgcmV0dXJuIG4gPyAoZSA9PiB7XG4gICAgICBmdW5jdGlvbiBwYXJzZVVuaXQoZSwgciwgaSkge1xuICAgICAgICBsZXQgYSA9IDAsIHMgPSAwO1xuICAgICAgICBpZiAoaSAmJiAoW2EsIG9dID0gZGl2TW9kRmxvb3IobywgQW9baV0pKSwgdm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGUpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZFN1YnN0cmluZyhlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICB9KShlKSwgbiA9IDEsIHIgJiYgKG8gPSBwYXJzZVN1YnNlY05hbm8ocikgKiAoQW9baV0gLyBSbyksIHQgPSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSArIHM7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IDAsIHQgPSAwLCBvID0gMCwgciA9IHtcbiAgICAgICAgLi4uemlwUHJvcHMocCwgWyBwYXJzZVVuaXQoZVsyXSksIHBhcnNlVW5pdChlWzNdKSwgcGFyc2VVbml0KGVbNF0pLCBwYXJzZVVuaXQoZVs1XSksIHBhcnNlVW5pdChlWzZdLCBlWzddLCA1KSwgcGFyc2VVbml0KGVbOF0sIGVbOV0sIDQpLCBwYXJzZVVuaXQoZVsxMF0sIGVbMTFdLCAzKSBdKSxcbiAgICAgICAgLi4ubmFub1RvR2l2ZW5GaWVsZHMobywgMiwgcClcbiAgICAgIH07XG4gICAgICBpZiAoIW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3Iobm9WYWxpZEZpZWxkcyhwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VTaWduKGVbMV0pIDwgMCAmJiAociA9IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKHIpKSwgcjtcbiAgICB9KShuKSA6IHZvaWQgMDtcbiAgfSkobShlKSk7XG4gIGlmICghbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZhaWxlZFBhcnNlKGUpKTtcbiAgfVxuICByZXR1cm4gT2UoY2hlY2tEdXJhdGlvblVuaXRzKG4pKTtcbn1cblxuZnVuY3Rpb24gZihlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZURhdGVUaW1lTGlrZShlKSB8fCBwYXJzZVllYXJNb250aE9ubHkoZSkgfHwgcGFyc2VNb250aERheU9ubHkoZSk7XG4gIHJldHVybiBuID8gbi5jYWxlbmRhciA6IGU7XG59XG5cbmZ1bmN0aW9uIFooZSkge1xuICBjb25zdCBuID0gcGFyc2VEYXRlVGltZUxpa2UoZSk7XG4gIHJldHVybiBuICYmIChuLnRpbWVab25lIHx8IG4uaiAmJiBzaSB8fCBuLm9mZnNldCkgfHwgZTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVab25lZERhdGVUaW1lKGUsIG4sIHQgPSAwLCBvID0gMCkge1xuICBjb25zdCByID0gTShlLnRpbWVab25lKSwgaSA9IEwocik7XG4gIGxldCBhO1xuICByZXR1cm4gY2hlY2tJc29EYXRlVGltZUZpZWxkcyhlKSwgYSA9IGUuQyA/IGdldE1hdGNoaW5nSW5zdGFudEZvcihpLCBlLCBuLCB0LCBvLCAhaS4kLCBlLmopIDogZ2V0U3RhcnRPZkRheUluc3RhbnRGb3IoaSwgZSksIFxuICBfZShhLCByLCB1KGUuY2FsZW5kYXIpKTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVEYXRlVGltZShlKSB7XG4gIHJldHVybiByZXNvbHZlU2xvdHNDYWxlbmRhcihjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoY2hlY2tJc29EYXRlVGltZUZpZWxkcyhlKSkpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZURhdGUoZSkge1xuICByZXR1cm4gcmVzb2x2ZVNsb3RzQ2FsZW5kYXIoY2hlY2tJc29EYXRlSW5Cb3VuZHMoY2hlY2tJc29EYXRlRmllbGRzKGUpKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90c0NhbGVuZGFyKGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5lLFxuICAgIGNhbGVuZGFyOiB1KGUuY2FsZW5kYXIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWVMaWtlKGUpIHtcbiAgY29uc3QgbiA9IHZpLmV4ZWMoZSk7XG4gIHJldHVybiBuID8gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBlWzEwXSwgdCA9IFwiWlwiID09PSAobiB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBpc29ZZWFyOiBvcmdhbml6ZUlzb1llYXJQYXJ0cyhlKSxcbiAgICAgIGlzb01vbnRoOiBwYXJzZUludChlWzRdKSxcbiAgICAgIGlzb0RheTogcGFyc2VJbnQoZVs1XSksXG4gICAgICAuLi5vcmdhbml6ZVRpbWVQYXJ0cyhlLnNsaWNlKDUpKSxcbiAgICAgIC4uLm9yZ2FuaXplQW5ub3RhdGlvblBhcnRzKGVbMTZdKSxcbiAgICAgIEM6IEJvb2xlYW4oZVs2XSksXG4gICAgICBqOiB0LFxuICAgICAgb2Zmc2V0OiB0ID8gdm9pZCAwIDogblxuICAgIH07XG4gIH0pKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXJNb250aE9ubHkoZSkge1xuICBjb25zdCBuID0gTmkuZXhlYyhlKTtcbiAgcmV0dXJuIG4gPyAoZSA9PiAoe1xuICAgIGlzb1llYXI6IG9yZ2FuaXplSXNvWWVhclBhcnRzKGUpLFxuICAgIGlzb01vbnRoOiBwYXJzZUludChlWzRdKSxcbiAgICBpc29EYXk6IDEsXG4gICAgLi4ub3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZVs1XSlcbiAgfSkpKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoRGF5T25seShlKSB7XG4gIGNvbnN0IG4gPSB5aS5leGVjKGUpO1xuICByZXR1cm4gbiA/IChlID0+ICh7XG4gICAgaXNvWWVhcjogQnIsXG4gICAgaXNvTW9udGg6IHBhcnNlSW50KGVbMV0pLFxuICAgIGlzb0RheTogcGFyc2VJbnQoZVsyXSksXG4gICAgLi4ub3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZVszXSlcbiAgfSkpKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9mZnNldE5hbm9NYXliZShlLCBuKSB7XG4gIGNvbnN0IHQgPSBFaS5leGVjKGUpO1xuICByZXR1cm4gdCA/ICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSBlWzRdIHx8IGVbNV07XG4gICAgaWYgKG4gJiYgdCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZFN1YnN0cmluZyh0KSk7XG4gICAgfVxuICAgIHJldHVybiAoZSA9PiB7XG4gICAgICBpZiAoTWF0aC5hYnMoZSkgPj0gVW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSkoKHBhcnNlSW50MChlWzJdKSAqIHpvICsgcGFyc2VJbnQwKGVbM10pICogWm8gKyBwYXJzZUludDAoZVs0XSkgKiBSbyArIHBhcnNlU3Vic2VjTmFubyhlWzVdIHx8IFwiXCIpKSAqIHBhcnNlU2lnbihlWzFdKSk7XG4gIH0pKHQsIG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBvcmdhbml6ZUlzb1llYXJQYXJ0cyhlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZVNpZ24oZVsxXSksIHQgPSBwYXJzZUludChlWzJdIHx8IGVbM10pO1xuICBpZiAobiA8IDAgJiYgIXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKC0wKSk7XG4gIH1cbiAgcmV0dXJuIG4gKiB0O1xufVxuXG5mdW5jdGlvbiBvcmdhbml6ZVRpbWVQYXJ0cyhlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZUludDAoZVszXSk7XG4gIHJldHVybiB7XG4gICAgLi4ubmFub1RvSXNvVGltZUFuZERheShwYXJzZVN1YnNlY05hbm8oZVs0XSB8fCBcIlwiKSlbMF0sXG4gICAgaXNvSG91cjogcGFyc2VJbnQwKGVbMV0pLFxuICAgIGlzb01pbnV0ZTogcGFyc2VJbnQwKGVbMl0pLFxuICAgIGlzb1NlY29uZDogNjAgPT09IG4gPyA1OSA6IG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gb3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZSkge1xuICBsZXQgbiwgdDtcbiAgY29uc3QgbyA9IFtdO1xuICBpZiAoZS5yZXBsYWNlKFNpLCAoKGUsIHIsIGkpID0+IHtcbiAgICBjb25zdCBhID0gQm9vbGVhbihyKSwgW3MsIGNdID0gaS5zcGxpdChcIj1cIikucmV2ZXJzZSgpO1xuICAgIGlmIChjKSB7XG4gICAgICBpZiAoXCJ1LWNhXCIgPT09IGMpIHtcbiAgICAgICAgby5wdXNoKHMpLCBuIHx8IChuID0gYSk7XG4gICAgICB9IGVsc2UgaWYgKGEgfHwgL1tBLVpdLy50ZXN0KGMpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICAgIHQgPSBzO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSkpLCBvLmxlbmd0aCA+IDEgJiYgbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGltZVpvbmU6IHQsXG4gICAgY2FsZW5kYXI6IG9bMF0gfHwgbFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN1YnNlY05hbm8oZSkge1xuICByZXR1cm4gcGFyc2VJbnQoZS5wYWRFbmQoOSwgXCIwXCIpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnRXhwKGUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke2V9JGAsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduKGUpIHtcbiAgcmV0dXJuIGUgJiYgXCIrXCIgIT09IGUgPyAtMSA6IDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50MChlKSB7XG4gIHJldHVybiB2b2lkIDAgPT09IGUgPyAwIDogcGFyc2VJbnQoZSk7XG59XG5cbmZ1bmN0aW9uIFplKGUpIHtcbiAgcmV0dXJuIE0obShlKSk7XG59XG5cbmZ1bmN0aW9uIE0oZSkge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IFNlKG4pIDogbiA/IChlID0+IHtcbiAgICBpZiAoT2kudGVzdChlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRihlKSk7XG4gICAgfVxuICAgIGlmIChiaS50ZXN0KGUpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwbyk7XG4gICAgfVxuICAgIHJldHVybiBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIvXCIpLm1hcCgoKGUsIG4pID0+IChlLmxlbmd0aCA8PSAzIHx8IC9cXGQvLnRlc3QoZSkpICYmICEvZXRjfHlhcC8udGVzdChlKSA/IGUudG9VcHBlckNhc2UoKSA6IGUucmVwbGFjZSgvYmFqYXxkdW1vbnR8W2Etel0rL2csICgoZSwgdCkgPT4gZS5sZW5ndGggPD0gMiAmJiAhbiB8fCBcImluXCIgPT09IGUgfHwgXCJjaGF0XCIgPT09IGUgPyBlLnRvVXBwZXJDYXNlKCkgOiBlLmxlbmd0aCA+IDIgfHwgIXQgPyBjYXBpdGFsaXplKGUpLnJlcGxhY2UoL2lzbGFuZHxub3JvbmhhfG11cmRvfHJpdmFkYXZpYXx1cnZpbGxlLywgY2FwaXRhbGl6ZSkgOiBlKSkpKS5qb2luKFwiL1wiKTtcbiAgfSkoZSkgOiBzaTtcbn1cblxuZnVuY3Rpb24gZ2V0VGltZVpvbmVBdG9taWMoZSkge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IG4gOiBuID8gbi5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSA6IHNpO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lWm9uZUVzc2VuY2UoZSkge1xuICBjb25zdCBuID0gcGFyc2VPZmZzZXROYW5vTWF5YmUoZSA9IGUudG9VcHBlckNhc2UoKSwgMSk7XG4gIHJldHVybiB2b2lkIDAgIT09IG4gPyBuIDogZSAhPT0gc2kgPyB3aShlKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gS2UoZSwgbikge1xuICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGUuZXBvY2hOYW5vc2Vjb25kcywgbi5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24gQmUoZSwgbikge1xuICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGUuZXBvY2hOYW5vc2Vjb25kcywgbi5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24gSyhlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBlKG5vcm1hbGl6ZU9wdGlvbnMoaSkucmVsYXRpdmVUbyksIHMgPSBNYXRoLm1heChnZXRNYXhEdXJhdGlvblVuaXQobyksIGdldE1heER1cmF0aW9uVW5pdChyKSk7XG4gIGlmIChhbGxQcm9wc0VxdWFsKHAsIG8sIHIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzVW5pZm9ybVVuaXQocywgYSkpIHtcbiAgICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKG8pLCBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhyKSk7XG4gIH1cbiAgaWYgKCFhKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoeW8pO1xuICB9XG4gIGNvbnN0IFtjLCB1LCBmXSA9IGNyZWF0ZU1hcmtlclN5c3RlbShuLCB0LCBhKSwgbCA9IGNyZWF0ZU1hcmtlclRvRXBvY2hOYW5vKGYpLCBkID0gY3JlYXRlTW92ZU1hcmtlcihmKTtcbiAgcmV0dXJuIGNvbXBhcmVCaWdOYW5vcyhsKGQodSwgYywgbykpLCBsKGQodSwgYywgcikpKTtcbn1cblxuZnVuY3Rpb24gWXQoZSwgbikge1xuICByZXR1cm4gdGUoZSwgbikgfHwgRHQoZSwgbik7XG59XG5cbmZ1bmN0aW9uIHRlKGUsIG4pIHtcbiAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGlzb1RvRXBvY2hNaWxsaShlKSwgaXNvVG9FcG9jaE1pbGxpKG4pKTtcbn1cblxuZnVuY3Rpb24gRHQoZSwgbikge1xuICByZXR1cm4gY29tcGFyZU51bWJlcnMoaXNvVGltZUZpZWxkc1RvTmFubyhlKSwgaXNvVGltZUZpZWxkc1RvTmFubyhuKSk7XG59XG5cbmZ1bmN0aW9uIFZlKGUsIG4pIHtcbiAgcmV0dXJuICFLZShlLCBuKTtcbn1cblxuZnVuY3Rpb24gQ2UoZSwgbikge1xuICByZXR1cm4gIUJlKGUsIG4pICYmICEhaXNUaW1lWm9uZUlkc0VxdWFsKGUudGltZVpvbmUsIG4udGltZVpvbmUpICYmIGUuY2FsZW5kYXIgPT09IG4uY2FsZW5kYXI7XG59XG5cbmZ1bmN0aW9uIEN0KGUsIG4pIHtcbiAgcmV0dXJuICFZdChlLCBuKSAmJiBlLmNhbGVuZGFyID09PSBuLmNhbGVuZGFyO1xufVxuXG5mdW5jdGlvbiByZShlLCBuKSB7XG4gIHJldHVybiAhdGUoZSwgbikgJiYgZS5jYWxlbmRhciA9PT0gbi5jYWxlbmRhcjtcbn1cblxuZnVuY3Rpb24gJHQoZSwgbikge1xuICByZXR1cm4gIXRlKGUsIG4pICYmIGUuY2FsZW5kYXIgPT09IG4uY2FsZW5kYXI7XG59XG5cbmZ1bmN0aW9uIEx0KGUsIG4pIHtcbiAgcmV0dXJuICF0ZShlLCBuKSAmJiBlLmNhbGVuZGFyID09PSBuLmNhbGVuZGFyO1xufVxuXG5mdW5jdGlvbiBzdChlLCBuKSB7XG4gIHJldHVybiAhRHQoZSwgbik7XG59XG5cbmZ1bmN0aW9uIGlzVGltZVpvbmVJZHNFcXVhbChlLCBuKSB7XG4gIGlmIChlID09PSBuKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0VGltZVpvbmVBdG9taWMoZSkgPT09IGdldFRpbWVab25lQXRvbWljKG4pO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiBFZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSByZWZpbmVEaWZmT3B0aW9ucyhlLCBvLCAzLCA1KSwgaSA9IGRpZmZFcG9jaE5hbm9zKG4uZXBvY2hOYW5vc2Vjb25kcywgdC5lcG9jaE5hbm9zZWNvbmRzLCAuLi5yKTtcbiAgcmV0dXJuIE9lKGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyhpKSA6IGkpO1xufVxuXG5mdW5jdGlvbiB3ZShlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBnZXRDb21tb25DYWxlbmRhcklkKG8uY2FsZW5kYXIsIHIuY2FsZW5kYXIpLCBbcywgYywgdSwgZl0gPSByZWZpbmVEaWZmT3B0aW9ucyh0LCBpLCA1KSwgbCA9IG8uZXBvY2hOYW5vc2Vjb25kcywgZCA9IHIuZXBvY2hOYW5vc2Vjb25kcywgbSA9IGNvbXBhcmVCaWdOYW5vcyhkLCBsKTtcbiAgbGV0IHA7XG4gIGlmIChtKSB7XG4gICAgaWYgKHMgPCA2KSB7XG4gICAgICBwID0gZGlmZkVwb2NoTmFub3MobCwgZCwgcywgYywgdSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSBuKCgoZSwgbikgPT4ge1xuICAgICAgICBpZiAoIWlzVGltZVpvbmVJZHNFcXVhbChlLCBuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0pKG8udGltZVpvbmUsIHIudGltZVpvbmUpKSwgbCA9IGUoYSk7XG4gICAgICBwID0gZGlmZlpvbmVkRXBvY2hzQmlnKGwsIHQsIG8sIHIsIG0sIHMsIGkpLCBwID0gcm91bmRSZWxhdGl2ZUR1cmF0aW9uKHAsIGQsIHMsIGMsIHUsIGYsIGwsIG8sIGV4dHJhY3RFcG9jaE5hbm8sIFB0KG1vdmVab25lZEVwb2NocywgdCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwID0gcHI7XG4gIH1cbiAgcmV0dXJuIE9lKHQgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyhwKSA6IHApO1xufVxuXG5mdW5jdGlvbiBJdChlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBnZXRDb21tb25DYWxlbmRhcklkKHQuY2FsZW5kYXIsIG8uY2FsZW5kYXIpLCBbYSwgcywgYywgdV0gPSByZWZpbmVEaWZmT3B0aW9ucyhuLCByLCA2KSwgZiA9IGlzb1RvRXBvY2hOYW5vKHQpLCBsID0gaXNvVG9FcG9jaE5hbm8obyksIGQgPSBjb21wYXJlQmlnTmFub3MobCwgZik7XG4gIGxldCBtO1xuICBpZiAoZCkge1xuICAgIGlmIChhIDw9IDYpIHtcbiAgICAgIG0gPSBkaWZmRXBvY2hOYW5vcyhmLCBsLCBhLCBzLCBjLCB1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IGUoaSk7XG4gICAgICBtID0gZGlmZkRhdGVUaW1lc0JpZyhuLCB0LCBvLCBkLCBhLCByKSwgbSA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihtLCBsLCBhLCBzLCBjLCB1LCBuLCB0LCBpc29Ub0Vwb2NoTmFubywgbW92ZURhdGVUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IHByO1xuICB9XG4gIHJldHVybiBPZShuID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobSkgOiBtKTtcbn1cblxuZnVuY3Rpb24gb2UoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0Q29tbW9uQ2FsZW5kYXJJZCh0LmNhbGVuZGFyLCBvLmNhbGVuZGFyKTtcbiAgcmV0dXJuIGRpZmZEYXRlTGlrZShuLCAoKCkgPT4gZShpKSksIHQsIG8sIC4uLnJlZmluZURpZmZPcHRpb25zKG4sIHIsIDYsIDksIDYpKTtcbn1cblxuZnVuY3Rpb24genQoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0Q29tbW9uQ2FsZW5kYXJJZCh0LmNhbGVuZGFyLCBvLmNhbGVuZGFyKSwgYSA9IHJlZmluZURpZmZPcHRpb25zKG4sIHIsIDksIDksIDgpLCBzID0gZShpKSwgYyA9IG1vdmVUb0RheU9mTW9udGhVbnNhZmUocywgdCksIHUgPSBtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKHMsIG8pO1xuICByZXR1cm4gYy5pc29ZZWFyID09PSB1Lmlzb1llYXIgJiYgYy5pc29Nb250aCA9PT0gdS5pc29Nb250aCAmJiBjLmlzb0RheSA9PT0gdS5pc29EYXkgPyBPZShwcikgOiBkaWZmRGF0ZUxpa2UobiwgKCgpID0+IHMpLCBjaGVja0lzb0RhdGVJbkJvdW5kcyhjKSwgY2hlY2tJc29EYXRlSW5Cb3VuZHModSksIC4uLmEsIDgpO1xufVxuXG5mdW5jdGlvbiBkaWZmRGF0ZUxpa2UoZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYyA9IDYpIHtcbiAgY29uc3QgdSA9IGlzb1RvRXBvY2hOYW5vKHQpLCBmID0gaXNvVG9FcG9jaE5hbm8obyk7XG4gIGlmICh2b2lkIDAgPT09IHUgfHwgdm9pZCAwID09PSBmKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIGxldCBsO1xuICBpZiAoY29tcGFyZUJpZ05hbm9zKGYsIHUpKSB7XG4gICAgaWYgKDYgPT09IHIpIHtcbiAgICAgIGwgPSBkaWZmRXBvY2hOYW5vcyh1LCBmLCByLCBpLCBhLCBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZSA9IG4oKTtcbiAgICAgIGwgPSBlLk4odCwgbywgciksIGkgPT09IGMgJiYgMSA9PT0gYSB8fCAobCA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihsLCBmLCByLCBpLCBhLCBzLCBlLCB0LCBpc29Ub0Vwb2NoTmFubywgbW92ZURhdGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbCA9IHByO1xuICB9XG4gIHJldHVybiBPZShlID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobCkgOiBsKTtcbn1cblxuZnVuY3Rpb24gaXQoZSwgbiwgdCwgbykge1xuICBjb25zdCBbciwgaSwgYSwgc10gPSByZWZpbmVEaWZmT3B0aW9ucyhlLCBvLCA1LCA1KSwgYyA9IHJvdW5kQnlJbmMoZGlmZlRpbWVzKG4sIHQpLCBjb21wdXRlTmFub0luYyhpLCBhKSwgcyksIHUgPSB7XG4gICAgLi4ucHIsXG4gICAgLi4ubmFub1RvRHVyYXRpb25UaW1lRmllbGRzKGMsIHIpXG4gIH07XG4gIHJldHVybiBPZShlID8gbmVnYXRlRHVyYXRpb25GaWVsZHModSkgOiB1KTtcbn1cblxuZnVuY3Rpb24gZGlmZlpvbmVkRXBvY2hzRXhhY3QoZSwgbiwgdCwgbywgciwgaSkge1xuICBjb25zdCBhID0gY29tcGFyZUJpZ05hbm9zKG8uZXBvY2hOYW5vc2Vjb25kcywgdC5lcG9jaE5hbm9zZWNvbmRzKTtcbiAgcmV0dXJuIGEgPyByIDwgNiA/IGRpZmZFcG9jaE5hbm9zRXhhY3QodC5lcG9jaE5hbm9zZWNvbmRzLCBvLmVwb2NoTmFub3NlY29uZHMsIHIpIDogZGlmZlpvbmVkRXBvY2hzQmlnKG4sIGUsIHQsIG8sIGEsIHIsIGkpIDogcHI7XG59XG5cbmZ1bmN0aW9uIGRpZmZEYXRlVGltZXNFeGFjdChlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBpc29Ub0Vwb2NoTmFubyhuKSwgYSA9IGlzb1RvRXBvY2hOYW5vKHQpLCBzID0gY29tcGFyZUJpZ05hbm9zKGEsIGkpO1xuICByZXR1cm4gcyA/IG8gPD0gNiA/IGRpZmZFcG9jaE5hbm9zRXhhY3QoaSwgYSwgbykgOiBkaWZmRGF0ZVRpbWVzQmlnKGUsIG4sIHQsIHMsIG8sIHIpIDogcHI7XG59XG5cbmZ1bmN0aW9uIGRpZmZab25lZEVwb2Noc0JpZyhlLCBuLCB0LCBvLCByLCBpLCBhKSB7XG4gIGNvbnN0IFtzLCBjLCB1XSA9ICgoZSwgbiwgdCwgbykgPT4ge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU1pZCgpIHtcbiAgICAgIHJldHVybiBmID0ge1xuICAgICAgICAuLi5tb3ZlQnlEYXlzKGEsIGMrKyAqIC1vKSxcbiAgICAgICAgLi4uaVxuICAgICAgfSwgbCA9IGdldFNpbmdsZUluc3RhbnRGb3IoZSwgZiksIGNvbXBhcmVCaWdOYW5vcyhzLCBsKSA9PT0gLW87XG4gICAgfVxuICAgIGNvbnN0IHIgPSBoZShuLCBlKSwgaSA9IG5uKHcsIHIpLCBhID0gaGUodCwgZSksIHMgPSB0LmVwb2NoTmFub3NlY29uZHM7XG4gICAgbGV0IGMgPSAwO1xuICAgIGNvbnN0IHUgPSBkaWZmVGltZXMociwgYSk7XG4gICAgbGV0IGYsIGw7XG4gICAgaWYgKE1hdGguc2lnbih1KSA9PT0gLW8gJiYgYysrLCB1cGRhdGVNaWQoKSAmJiAoLTEgPT09IG8gfHwgdXBkYXRlTWlkKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gICAgfVxuICAgIGNvbnN0IGQgPSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKGwsIHMpKTtcbiAgICByZXR1cm4gWyByLCBmLCBkIF07XG4gIH0pKG4sIHQsIG8sIHIpO1xuICB2YXIgZiwgbDtcbiAgcmV0dXJuIHtcbiAgICAuLi42ID09PSBpID8gKGYgPSBzLCBsID0gYywge1xuICAgICAgLi4ucHIsXG4gICAgICBkYXlzOiBkaWZmRGF5cyhmLCBsKVxuICAgIH0pIDogZS5OKHMsIGMsIGksIGEpLFxuICAgIC4uLm5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyh1KVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaWZmRGF0ZVRpbWVzQmlnKGUsIG4sIHQsIG8sIHIsIGkpIHtcbiAgY29uc3QgW2EsIHMsIGNdID0gKChlLCBuLCB0KSA9PiB7XG4gICAgbGV0IG8gPSBuLCByID0gZGlmZlRpbWVzKGUsIG4pO1xuICAgIHJldHVybiBNYXRoLnNpZ24ocikgPT09IC10ICYmIChvID0gbW92ZUJ5RGF5cyhuLCAtdCksIHIgKz0gVW8gKiB0KSwgWyBlLCBvLCByIF07XG4gIH0pKG4sIHQsIG8pO1xuICByZXR1cm4ge1xuICAgIC4uLmUuTihhLCBzLCByLCBpKSxcbiAgICAuLi5uYW5vVG9EdXJhdGlvblRpbWVGaWVsZHMoYylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkVwb2NoTmFub3MoZSwgbiwgdCwgbywgciwgaSkge1xuICByZXR1cm4ge1xuICAgIC4uLnByLFxuICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhyb3VuZEJpZ05hbm8oZGlmZkJpZ05hbm9zKGUsIG4pLCBvLCByLCBpKSwgdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkVwb2NoTmFub3NFeGFjdChlLCBuLCB0KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucHIsXG4gICAgLi4ubmFub1RvRHVyYXRpb25EYXlUaW1lRmllbGRzKGRpZmZCaWdOYW5vcyhlLCBuKSwgdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkRheXMoZSwgbikge1xuICByZXR1cm4gZGlmZkVwb2NoTWlsbGlCeURheShpc29Ub0Vwb2NoTWlsbGkoZSksIGlzb1RvRXBvY2hNaWxsaShuKSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZFcG9jaE1pbGxpQnlEYXkoZSwgbikge1xuICByZXR1cm4gTWF0aC50cnVuYygobiAtIGUpIC8ga28pO1xufVxuXG5mdW5jdGlvbiBkaWZmVGltZXMoZSwgbikge1xuICByZXR1cm4gaXNvVGltZUZpZWxkc1RvTmFubyhuKSAtIGlzb1RpbWVGaWVsZHNUb05hbm8oZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbW1vbkNhbGVuZGFySWQoZSwgbikge1xuICBpZiAoZSAhPT0gbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGxvKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU5hdGl2ZVdlZWtPZlllYXIoZSkge1xuICByZXR1cm4gdGhpcy5tKGUpWzBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTmF0aXZlWWVhck9mV2VlayhlKSB7XG4gIHJldHVybiB0aGlzLm0oZSlbMV07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVOYXRpdmVEYXlPZlllYXIoZSkge1xuICBjb25zdCBbbl0gPSB0aGlzLnYoZSk7XG4gIHJldHVybiBkaWZmRXBvY2hNaWxsaUJ5RGF5KHRoaXMucChuKSwgaXNvVG9FcG9jaE1pbGxpKGUpKSArIDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhDb2RlKGUpIHtcbiAgY29uc3QgbiA9IEJpLmV4ZWMoZSk7XG4gIGlmICghbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRNb250aENvZGUoZSkpO1xuICB9XG4gIHJldHVybiBbIHBhcnNlSW50KG5bMV0pLCBCb29sZWFuKG5bMl0pIF07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoQ29kZShlLCBuKSB7XG4gIHJldHVybiBcIk1cIiArIGJvKGUpICsgKG4gPyBcIkxcIiA6IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBtb250aENvZGVOdW1iZXJUb01vbnRoKGUsIG4sIHQpIHtcbiAgcmV0dXJuIGUgKyAobiB8fCB0ICYmIGUgPj0gdCA/IDEgOiAwKTtcbn1cblxuZnVuY3Rpb24gbW9udGhUb01vbnRoQ29kZU51bWJlcihlLCBuKSB7XG4gIHJldHVybiBlIC0gKG4gJiYgZSA+PSBuID8gMSA6IDApO1xufVxuXG5mdW5jdGlvbiBlcmFZZWFyVG9ZZWFyKGUsIG4pIHtcbiAgcmV0dXJuIChuICsgZSkgKiAoTWF0aC5zaWduKG4pIHx8IDEpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyRXJhT3JpZ2lucyhlKSB7XG4gIHJldHVybiBpcltnZXRDYWxlbmRhcklkQmFzZShlKV07XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YShlKSB7XG4gIHJldHVybiBzcltnZXRDYWxlbmRhcklkQmFzZShlKV07XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFySWRCYXNlKGUpIHtcbiAgcmV0dXJuIGNvbXB1dGVDYWxlbmRhcklkQmFzZShlLmlkIHx8IGwpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnRsQ2FsZW5kYXIoZSkge1xuICBmdW5jdGlvbiBlcG9jaE1pbGxpVG9JbnRsRmllbGRzKGUpIHtcbiAgICByZXR1cm4gKChlLCBuKSA9PiAoe1xuICAgICAgLi4ucGFyc2VJbnRsWWVhcihlLCBuKSxcbiAgICAgIG86IGUubW9udGgsXG4gICAgICBkYXk6IHBhcnNlSW50KGUuZGF5KVxuICAgIH0pKShoYXNoSW50bEZvcm1hdFBhcnRzKG4sIGUpLCB0KTtcbiAgfVxuICBjb25zdCBuID0gQ2koZSksIHQgPSBjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSk7XG4gIHJldHVybiB7XG4gICAgaWQ6IGUsXG4gICAgaDogY3JlYXRlSW50bEZpZWxkQ2FjaGUoZXBvY2hNaWxsaVRvSW50bEZpZWxkcyksXG4gICAgbDogY3JlYXRlSW50bFllYXJEYXRhQ2FjaGUoZXBvY2hNaWxsaVRvSW50bEZpZWxkcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50bEZpZWxkQ2FjaGUoZSkge1xuICByZXR1cm4gb24oKG4gPT4ge1xuICAgIGNvbnN0IHQgPSBpc29Ub0Vwb2NoTWlsbGkobik7XG4gICAgcmV0dXJuIGUodCk7XG4gIH0pLCBXZWFrTWFwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50bFllYXJEYXRhQ2FjaGUoZSkge1xuICBjb25zdCBuID0gZSgwKS55ZWFyIC0gT3I7XG4gIHJldHVybiBvbigodCA9PiB7XG4gICAgbGV0IG8sIHIgPSBpc29BcmdzVG9FcG9jaE1pbGxpKHQgLSBuKSwgaSA9IDA7XG4gICAgY29uc3QgYSA9IFtdLCBzID0gW107XG4gICAgZG8ge1xuICAgICAgciArPSA0MDAgKiBrbztcbiAgICB9IHdoaWxlICgobyA9IGUocikpLnllYXIgPD0gdCk7XG4gICAgZG8ge1xuICAgICAgaWYgKHIgKz0gKDEgLSBvLmRheSkgKiBrbywgby55ZWFyID09PSB0ICYmIChhLnB1c2gociksIHMucHVzaChvLm8pKSwgciAtPSBrbywgKytpID4gMTAwIHx8IHIgPCAtUHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZm8pO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKChvID0gZShyKSkueWVhciA+PSB0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaTogYS5yZXZlcnNlKCksXG4gICAgICB1OiBGbyhzLnJldmVyc2UoKSlcbiAgICB9O1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50bFllYXIoZSwgbikge1xuICBsZXQgdCwgbywgciA9IHBhcnNlSW50bFBhcnRzWWVhcihlKTtcbiAgaWYgKGUuZXJhKSB7XG4gICAgY29uc3QgaSA9IGlyW25dLCBhID0gYXJbbl0gfHwge307XG4gICAgdm9pZCAwICE9PSBpICYmICh0ID0gXCJpc2xhbWljXCIgPT09IG4gPyBcImFoXCIgOiBlLmVyYS5ub3JtYWxpemUoXCJORkRcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgXCJcIiksIFxuICAgIFwiYmNcIiA9PT0gdCB8fCBcImJcIiA9PT0gdCA/IHQgPSBcImJjZVwiIDogXCJhZFwiID09PSB0IHx8IFwiYVwiID09PSB0ID8gdCA9IFwiY2VcIiA6IFwiYmVmb3Jlcm9jXCIgPT09IHQgJiYgKHQgPSBcImJyb2NcIiksIFxuICAgIHQgPSBhW3RdIHx8IHQsIG8gPSByLCByID0gZXJhWWVhclRvWWVhcihvLCBpW3RdIHx8IDApKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVyYTogdCxcbiAgICBlcmFZZWFyOiBvLFxuICAgIHllYXI6IHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJbnRsUGFydHNZZWFyKGUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGUucmVsYXRlZFllYXIgfHwgZS55ZWFyKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxEYXRlUGFydHMoZSkge1xuICBjb25zdCB7eWVhcjogbiwgbzogdCwgZGF5OiBvfSA9IHRoaXMuaChlKSwge3U6IHJ9ID0gdGhpcy5sKG4pO1xuICByZXR1cm4gWyBuLCByW3RdICsgMSwgbyBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bEVwb2NoTWlsbGkoZSwgbiA9IDEsIHQgPSAxKSB7XG4gIHJldHVybiB0aGlzLmwoZSkuaVtuIC0gMV0gKyAodCAtIDEpICoga287XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRsTW9udGhDb2RlUGFydHMoZSwgbikge1xuICBjb25zdCB0ID0gY29tcHV0ZUludGxMZWFwTW9udGguY2FsbCh0aGlzLCBlKTtcbiAgcmV0dXJuIFsgbW9udGhUb01vbnRoQ29kZU51bWJlcihuLCB0KSwgdCA9PT0gbiBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bExlYXBNb250aChlKSB7XG4gIGNvbnN0IG4gPSBxdWVyeU1vbnRoU3RyaW5ncyh0aGlzLCBlKSwgdCA9IHF1ZXJ5TW9udGhTdHJpbmdzKHRoaXMsIGUgLSAxKSwgbyA9IG4ubGVuZ3RoO1xuICBpZiAobyA+IHQubGVuZ3RoKSB7XG4gICAgY29uc3QgZSA9IGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YSh0aGlzKTtcbiAgICBpZiAoZSA8IDApIHtcbiAgICAgIHJldHVybiAtZTtcbiAgICB9XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBvOyBlKyspIHtcbiAgICAgIGlmIChuW2VdICE9PSB0W2VdKSB7XG4gICAgICAgIHJldHVybiBlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxEYXlzSW5ZZWFyKGUpIHtcbiAgcmV0dXJuIGRpZmZFcG9jaE1pbGxpQnlEYXkoY29tcHV0ZUludGxFcG9jaE1pbGxpLmNhbGwodGhpcywgZSksIGNvbXB1dGVJbnRsRXBvY2hNaWxsaS5jYWxsKHRoaXMsIGUgKyAxKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRsRGF5c0luTW9udGgoZSwgbikge1xuICBjb25zdCB7aTogdH0gPSB0aGlzLmwoZSk7XG4gIGxldCBvID0gbiArIDEsIHIgPSB0O1xuICByZXR1cm4gbyA+IHQubGVuZ3RoICYmIChvID0gMSwgciA9IHRoaXMubChlICsgMSkuaSksIGRpZmZFcG9jaE1pbGxpQnlEYXkodFtuIC0gMV0sIHJbbyAtIDFdKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxNb250aHNJblllYXIoZSkge1xuICByZXR1cm4gdGhpcy5sKGUpLmkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bEVyYVBhcnRzKGUpIHtcbiAgY29uc3QgbiA9IHRoaXMuaChlKTtcbiAgcmV0dXJuIFsgbi5lcmEsIG4uZXJhWWVhciBdO1xufVxuXG5mdW5jdGlvbiBxdWVyeU1vbnRoU3RyaW5ncyhlLCBuKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlLmwobikudSk7XG59XG5cbmZ1bmN0aW9uIE10KGUpIHtcbiAgcmV0dXJuIHUobShlKSk7XG59XG5cbmZ1bmN0aW9uIHUoZSkge1xuICBpZiAoKGUgPSBlLnRvTG93ZXJDYXNlKCkpICE9PSBsICYmIGUgIT09IG9yKSB7XG4gICAgY29uc3QgbiA9IENpKGUpLnJlc29sdmVkT3B0aW9ucygpLmNhbGVuZGFyO1xuICAgIGlmIChjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSkgIT09IGNvbXB1dGVDYWxlbmRhcklkQmFzZShuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYyhlKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSkge1xuICByZXR1cm4gXCJpc2xhbWljY1wiID09PSBlICYmIChlID0gXCJpc2xhbWljXCIpLCBlLnNwbGl0KFwiLVwiKVswXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmF0aXZlT3BzQ3JlYXRvcihlLCBuKSB7XG4gIHJldHVybiB0ID0+IHQgPT09IGwgPyBlIDogdCA9PT0gb3IgfHwgdCA9PT0gcnIgPyBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoZSksIHtcbiAgICBpZDogdFxuICB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShuKSwga2kodCkpO1xufVxuXG5mdW5jdGlvbiAkKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IHJlZmluZUNhbGVuZGFyRmllbGRzKHQsIG8sIFhvLCBbXSwgeG8pO1xuICBpZiAodm9pZCAwICE9PSByLnRpbWVab25lKSB7XG4gICAgY29uc3QgbyA9IHQuRihyKSwgaSA9IHJlZmluZVRpbWVCYWcociksIGEgPSBlKHIudGltZVpvbmUpO1xuICAgIHJldHVybiB7XG4gICAgICBlcG9jaE5hbm9zZWNvbmRzOiBnZXRNYXRjaGluZ0luc3RhbnRGb3IobihhKSwge1xuICAgICAgICAuLi5vLFxuICAgICAgICAuLi5pXG4gICAgICB9LCB2b2lkIDAgIT09IHIub2Zmc2V0ID8gcGFyc2VPZmZzZXROYW5vKHIub2Zmc2V0KSA6IHZvaWQgMCksXG4gICAgICB0aW1lWm9uZTogYVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50LkYociksXG4gICAgLi4uTnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gTmUoZSwgbiwgdCwgbywgciwgaSkge1xuICBjb25zdCBhID0gcmVmaW5lQ2FsZW5kYXJGaWVsZHModCwgciwgWG8sIGpvLCB4byksIHMgPSBlKGEudGltZVpvbmUpLCBbYywgdSwgZl0gPSBqZShpKSwgbCA9IHQuRihhLCBmYWJyaWNhdGVPdmVyZmxvd09wdGlvbnMoYykpLCBkID0gcmVmaW5lVGltZUJhZyhhLCBjKTtcbiAgcmV0dXJuIF9lKGdldE1hdGNoaW5nSW5zdGFudEZvcihuKHMpLCB7XG4gICAgLi4ubCxcbiAgICAuLi5kXG4gIH0sIHZvaWQgMCAhPT0gYS5vZmZzZXQgPyBwYXJzZU9mZnNldE5hbm8oYS5vZmZzZXQpIDogdm9pZCAwLCB1LCBmKSwgcywgbyk7XG59XG5cbmZ1bmN0aW9uIEF0KGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIFhvLCBbXSwgTyksIHIgPSBtdCh0KTtcbiAgcmV0dXJuIGp0KGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyh7XG4gICAgLi4uZS5GKG8sIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyhyKSksXG4gICAgLi4ucmVmaW5lVGltZUJhZyhvLCByKVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIG1lKGUsIG4sIHQsIG8gPSBbXSkge1xuICBjb25zdCByID0gcmVmaW5lQ2FsZW5kYXJGaWVsZHMoZSwgbiwgWG8sIG8pO1xuICByZXR1cm4gZS5GKHIsIHQpO1xufVxuXG5mdW5jdGlvbiBYdChlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSByZWZpbmVDYWxlbmRhckZpZWxkcyhlLCBuLCBLbywgbyk7XG4gIHJldHVybiBlLksociwgdCk7XG59XG5cbmZ1bmN0aW9uIFJ0KGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIHQsIFhvLCBKbyk7XG4gIHJldHVybiBuICYmIHZvaWQgMCAhPT0gci5tb250aCAmJiB2b2lkIDAgPT09IHIubW9udGhDb2RlICYmIHZvaWQgMCA9PT0gci55ZWFyICYmIChyLnllYXIgPSBCciksIFxuICBlLl8ociwgbyk7XG59XG5cbmZ1bmN0aW9uIFR0KGUsIG4pIHtcbiAgcmV0dXJuIFN0KHJlZmluZVRpbWVCYWcocmVmaW5lRmllbGRzKGUsIHFvLCBbXSwgMSksIG10KG4pKSk7XG59XG5cbmZ1bmN0aW9uIHEoZSkge1xuICBjb25zdCBuID0gcmVmaW5lRmllbGRzKGUsIHVyKTtcbiAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cyh7XG4gICAgLi4ucHIsXG4gICAgLi4ublxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIHQsIG8gPSBbXSwgciA9IFtdKSB7XG4gIHJldHVybiByZWZpbmVGaWVsZHMobiwgWyAuLi5lLmZpZWxkcyh0KSwgLi4uciBdLnNvcnQoKSwgbyk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUZpZWxkcyhlLCBuLCB0LCBvID0gIXQpIHtcbiAgY29uc3QgciA9IHt9O1xuICBsZXQgaSwgYSA9IDA7XG4gIGZvciAoY29uc3QgbyBvZiBuKSB7XG4gICAgaWYgKG8gPT09IGkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGR1cGxpY2F0ZUZpZWxkcyhvKSk7XG4gICAgfVxuICAgIGlmIChcImNvbnN0cnVjdG9yXCIgPT09IG8gfHwgXCJfX3Byb3RvX19cIiA9PT0gbykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZm9yYmlkZGVuRmllbGQobykpO1xuICAgIH1cbiAgICBsZXQgbiA9IGVbb107XG4gICAgaWYgKHZvaWQgMCAhPT0gbikge1xuICAgICAgYSA9IDEsIExpW29dICYmIChuID0gTGlbb10obiwgbykpLCByW29dID0gbjtcbiAgICB9IGVsc2UgaWYgKHQpIHtcbiAgICAgIGlmICh0LmluY2x1ZGVzKG8pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWlzc2luZ0ZpZWxkKG8pKTtcbiAgICAgIH1cbiAgICAgIHJbb10gPSB0cltvXTtcbiAgICB9XG4gICAgaSA9IG87XG4gIH1cbiAgaWYgKG8gJiYgIWEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5vVmFsaWRGaWVsZHMobikpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiByZWZpbmVUaW1lQmFnKGUsIG4pIHtcbiAgcmV0dXJuIGNvbnN0cmFpbklzb1RpbWVGaWVsZHMoeGkoe1xuICAgIC4uLnRyLFxuICAgIC4uLmVcbiAgfSksIG4pO1xufVxuXG5mdW5jdGlvbiBEZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogaSwgdGltZVpvbmU6IGF9ID0gdCwgcyA9IGUoaSksIGMgPSBuKGEpLCB1ID0gWyAuLi5zLmZpZWxkcyhYbyksIC4uLkxvIF0uc29ydCgpLCBmID0gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBoZShlLCBMKSwgdCA9IFNlKG4ub2Zmc2V0TmFub3NlY29uZHMpLCBvID0gamkoZS5jYWxlbmRhciksIFtyLCBpLCBhXSA9IG8udihuKSwgW3MsIGNdID0gby5xKHIsIGkpLCB1ID0gZm9ybWF0TW9udGhDb2RlKHMsIGMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi4kaShuKSxcbiAgICAgIHllYXI6IHIsXG4gICAgICBtb250aENvZGU6IHUsXG4gICAgICBkYXk6IGEsXG4gICAgICBvZmZzZXQ6IHRcbiAgICB9O1xuICB9KSh0KSwgbCA9IHJlZmluZUZpZWxkcyhvLCB1KSwgZCA9IHMuayhmLCBsKSwgbSA9IHtcbiAgICAuLi5mLFxuICAgIC4uLmxcbiAgfSwgW3AsIGgsIGddID0gamUociwgMik7XG4gIHJldHVybiBfZShnZXRNYXRjaGluZ0luc3RhbnRGb3IoYywge1xuICAgIC4uLnMuRihkLCBmYWJyaWNhdGVPdmVyZmxvd09wdGlvbnMocCkpLFxuICAgIC4uLmNvbnN0cmFpbklzb1RpbWVGaWVsZHMoeGkobSksIHApXG4gIH0sIHBhcnNlT2Zmc2V0TmFubyhtLm9mZnNldCksIGgsIGcpLCBhLCBpKTtcbn1cblxuZnVuY3Rpb24gZ3QoZSwgbiwgdCwgbykge1xuICBjb25zdCByID0gZShuLmNhbGVuZGFyKSwgaSA9IFsgLi4uci5maWVsZHMoWG8pLCAuLi5PIF0uc29ydCgpLCBhID0ge1xuICAgIC4uLmNvbXB1dGVEYXRlRXNzZW50aWFscyhzID0gbiksXG4gICAgaG91cjogcy5pc29Ib3VyLFxuICAgIG1pbnV0ZTogcy5pc29NaW51dGUsXG4gICAgc2Vjb25kOiBzLmlzb1NlY29uZCxcbiAgICBtaWxsaXNlY29uZDogcy5pc29NaWxsaXNlY29uZCxcbiAgICBtaWNyb3NlY29uZDogcy5pc29NaWNyb3NlY29uZCxcbiAgICBuYW5vc2Vjb25kOiBzLmlzb05hbm9zZWNvbmRcbiAgfTtcbiAgdmFyIHM7XG4gIGNvbnN0IGMgPSByZWZpbmVGaWVsZHModCwgaSksIHUgPSBtdChvKSwgZiA9IHIuayhhLCBjKSwgbCA9IHtcbiAgICAuLi5hLFxuICAgIC4uLmNcbiAgfTtcbiAgcmV0dXJuIGp0KGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyh7XG4gICAgLi4uci5GKGYsIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyh1KSksXG4gICAgLi4uY29uc3RyYWluSXNvVGltZUZpZWxkcyh4aShsKSwgdSlcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBlZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSBlKG4uY2FsZW5kYXIpLCBpID0gci5maWVsZHMoWG8pLnNvcnQoKSwgYSA9IGNvbXB1dGVEYXRlRXNzZW50aWFscyhuKSwgcyA9IHJlZmluZUZpZWxkcyh0LCBpKSwgYyA9IHIuayhhLCBzKTtcbiAgcmV0dXJuIHIuRihjLCBvKTtcbn1cblxuZnVuY3Rpb24gV3QoZSwgbiwgdCwgbykge1xuICBjb25zdCByID0gZShuLmNhbGVuZGFyKSwgaSA9IHIuZmllbGRzKEtvKS5zb3J0KCksIGEgPSAoZSA9PiB7XG4gICAgY29uc3QgbiA9IGppKGUuY2FsZW5kYXIpLCBbdCwgb10gPSBuLnYoZSksIFtyLCBpXSA9IG4ucSh0LCBvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogdCxcbiAgICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKHIsIGkpXG4gICAgfTtcbiAgfSkobiksIHMgPSByZWZpbmVGaWVsZHModCwgaSksIGMgPSByLmsoYSwgcyk7XG4gIHJldHVybiByLksoYywgbyk7XG59XG5cbmZ1bmN0aW9uIEV0KGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IGUobi5jYWxlbmRhciksIGkgPSByLmZpZWxkcyhYbykuc29ydCgpLCBhID0gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBqaShlLmNhbGVuZGFyKSwgW3QsIG8sIHJdID0gbi52KGUpLCBbaSwgYV0gPSBuLnEodCwgbyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKGksIGEpLFxuICAgICAgZGF5OiByXG4gICAgfTtcbiAgfSkobiksIHMgPSByZWZpbmVGaWVsZHModCwgaSksIGMgPSByLmsoYSwgcyk7XG4gIHJldHVybiByLl8oYywgbyk7XG59XG5cbmZ1bmN0aW9uIHJ0KGUsIG4sIHQpIHtcbiAgcmV0dXJuIFN0KCgoZSwgbiwgdCkgPT4gcmVmaW5lVGltZUJhZyh7XG4gICAgLi4ubm4ocW8sIGUpLFxuICAgIC4uLnJlZmluZUZpZWxkcyhuLCBxbylcbiAgfSwgbXQodCkpKShlLCBuLCB0KSk7XG59XG5cbmZ1bmN0aW9uIEEoZSwgbikge1xuICByZXR1cm4gT2UoKHQgPSBlLCBvID0gbiwgY2hlY2tEdXJhdGlvblVuaXRzKHtcbiAgICAuLi50LFxuICAgIC4uLnJlZmluZUZpZWxkcyhvLCB1cilcbiAgfSkpKTtcbiAgdmFyIHQsIG87XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0lzbyhlLCBuLCB0LCBvLCByKSB7XG4gIG4gPSBubih0ID0gZS5maWVsZHModCksIG4pLCBvID0gcmVmaW5lRmllbGRzKG8sIHIgPSBlLmZpZWxkcyhyKSwgW10pO1xuICBsZXQgaSA9IGUuayhuLCBvKTtcbiAgcmV0dXJuIGkgPSByZWZpbmVGaWVsZHMoaSwgWyAuLi50LCAuLi5yIF0uc29ydCgpLCBbXSksIGUuRihpKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lWWVhcihlLCBuKSB7XG4gIGNvbnN0IHQgPSBnZXRDYWxlbmRhckVyYU9yaWdpbnMoZSksIG8gPSBhcltlLmlkIHx8IFwiXCJdIHx8IHt9O1xuICBsZXQge2VyYTogciwgZXJhWWVhcjogaSwgeWVhcjogYX0gPSBuO1xuICBpZiAodm9pZCAwICE9PSByIHx8IHZvaWQgMCAhPT0gaSkge1xuICAgIGlmICh2b2lkIDAgPT09IHIgfHwgdm9pZCAwID09PSBpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGlvKTtcbiAgICB9XG4gICAgaWYgKCF0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihybyk7XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0W29bcl0gfHwgcl07XG4gICAgaWYgKHZvaWQgMCA9PT0gZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVyYShyKSk7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBlcmFZZWFyVG9ZZWFyKGksIGUpO1xuICAgIGlmICh2b2lkIDAgIT09IGEgJiYgYSAhPT0gbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYW8pO1xuICAgIH1cbiAgICBhID0gbjtcbiAgfSBlbHNlIGlmICh2b2lkIDAgPT09IGEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1pc3NpbmdZZWFyKHQpKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lTW9udGgoZSwgbiwgdCwgbykge1xuICBsZXQge21vbnRoOiByLCBtb250aENvZGU6IGl9ID0gbjtcbiAgaWYgKHZvaWQgMCAhPT0gaSkge1xuICAgIGNvbnN0IG4gPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlLkwodCksIFtpLCBhXSA9IHBhcnNlTW9udGhDb2RlKG4pO1xuICAgICAgbGV0IHMgPSBtb250aENvZGVOdW1iZXJUb01vbnRoKGksIGEsIHIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbiA9IGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YShlKTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICBpZiAocyA+IG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgICAgICAgICAgaWYgKDEgPT09IG8pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocyAhPT0gLW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gciAmJiAxID09PSBvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih1byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9KShlLCBpLCB0LCBvKTtcbiAgICBpZiAodm9pZCAwICE9PSByICYmIHIgIT09IG4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHNvKTtcbiAgICB9XG4gICAgciA9IG4sIG8gPSAxO1xuICB9IGVsc2UgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY28pO1xuICB9XG4gIHJldHVybiBjbGFtcEVudGl0eShcIm1vbnRoXCIsIHIsIDEsIGUuQih0KSwgbyk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZURheShlLCBuLCB0LCBvLCByKSB7XG4gIHJldHVybiBjbGFtcFByb3AobiwgXCJkYXlcIiwgMSwgZS5VKG8sIHQpLCByKTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlRmllbGRzKGUsIG4sIHQsIG8pIHtcbiAgbGV0IHIgPSAwO1xuICBjb25zdCBpID0gW107XG4gIGZvciAoY29uc3QgZSBvZiB0KSB7XG4gICAgdm9pZCAwICE9PSBuW2VdID8gciA9IDEgOiBpLnB1c2goZSk7XG4gIH1cbiAgaWYgKE9iamVjdC5hc3NpZ24oZSwgbiksIHIpIHtcbiAgICBmb3IgKGNvbnN0IG4gb2YgbyB8fCBpKSB7XG4gICAgICBkZWxldGUgZVtuXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZURhdGVFc3NlbnRpYWxzKGUpIHtcbiAgY29uc3QgbiA9IGppKGUuY2FsZW5kYXIpLCBbdCwgbywgcl0gPSBuLnYoZSksIFtpLCBhXSA9IG4ucSh0LCBvKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiB0LFxuICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKGksIGEpLFxuICAgIGRheTogclxuICB9O1xufVxuXG5mdW5jdGlvbiBxZShlKSB7XG4gIHJldHVybiB4ZShjaGVja0Vwb2NoTmFub0luQm91bmRzKGJpZ0ludFRvQmlnTmFubyh0b0JpZ0ludChlKSkpKTtcbn1cblxuZnVuY3Rpb24geWUoZSwgbiwgdCwgbywgciA9IGwpIHtcbiAgcmV0dXJuIF9lKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoYmlnSW50VG9CaWdOYW5vKHRvQmlnSW50KHQpKSksIG4obyksIGUocikpO1xufVxuXG5mdW5jdGlvbiBadChuLCB0LCBvLCByLCBpID0gMCwgYSA9IDAsIHMgPSAwLCBjID0gMCwgdSA9IDAsIGYgPSAwLCBkID0gbCkge1xuICByZXR1cm4ganQoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMoZSh0b0ludGVnZXIsIHppcFByb3BzKFRyLCBbIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUsIGYgXSkpKSksIG4oZCkpO1xufVxuXG5mdW5jdGlvbiB1ZShuLCB0LCBvLCByLCBpID0gbCkge1xuICByZXR1cm4gVyhjaGVja0lzb0RhdGVJbkJvdW5kcyhjaGVja0lzb0RhdGVGaWVsZHMoZSh0b0ludGVnZXIsIHtcbiAgICBpc29ZZWFyOiB0LFxuICAgIGlzb01vbnRoOiBvLFxuICAgIGlzb0RheTogclxuICB9KSkpLCBuKGkpKTtcbn1cblxuZnVuY3Rpb24gUXQoZSwgbiwgdCwgbyA9IGwsIHIgPSAxKSB7XG4gIGNvbnN0IGkgPSB0b0ludGVnZXIobiksIGEgPSB0b0ludGVnZXIodCksIHMgPSBlKG8pO1xuICByZXR1cm4gY3JlYXRlUGxhaW5ZZWFyTW9udGhTbG90cyhjaGVja0lzb1llYXJNb250aEluQm91bmRzKGNoZWNrSXNvRGF0ZUZpZWxkcyh7XG4gICAgaXNvWWVhcjogaSxcbiAgICBpc29Nb250aDogYSxcbiAgICBpc29EYXk6IHRvSW50ZWdlcihyKVxuICB9KSksIHMpO1xufVxuXG5mdW5jdGlvbiBrdChlLCBuLCB0LCBvID0gbCwgciA9IEJyKSB7XG4gIGNvbnN0IGkgPSB0b0ludGVnZXIobiksIGEgPSB0b0ludGVnZXIodCksIHMgPSBlKG8pO1xuICByZXR1cm4gY3JlYXRlUGxhaW5Nb250aERheVNsb3RzKGNoZWNrSXNvRGF0ZUluQm91bmRzKGNoZWNrSXNvRGF0ZUZpZWxkcyh7XG4gICAgaXNvWWVhcjogdG9JbnRlZ2VyKHIpLFxuICAgIGlzb01vbnRoOiBpLFxuICAgIGlzb0RheTogYVxuICB9KSksIHMpO1xufVxuXG5mdW5jdGlvbiB1dChuID0gMCwgdCA9IDAsIG8gPSAwLCByID0gMCwgaSA9IDAsIGEgPSAwKSB7XG4gIHJldHVybiBTdChjb25zdHJhaW5Jc29UaW1lRmllbGRzKGUodG9JbnRlZ2VyLCB6aXBQcm9wcyh3LCBbIG4sIHQsIG8sIHIsIGksIGEgXSkpLCAxKSk7XG59XG5cbmZ1bmN0aW9uIGoobiA9IDAsIHQgPSAwLCBvID0gMCwgciA9IDAsIGkgPSAwLCBhID0gMCwgcyA9IDAsIGMgPSAwLCB1ID0gMCwgZiA9IDApIHtcbiAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cyhlKHRvU3RyaWN0SW50ZWdlciwgemlwUHJvcHMocCwgWyBuLCB0LCBvLCByLCBpLCBhLCBzLCBjLCB1LCBmIF0pKSkpO1xufVxuXG5mdW5jdGlvbiBKZShlLCBuLCB0ID0gbCkge1xuICByZXR1cm4gX2UoZS5lcG9jaE5hbm9zZWNvbmRzLCBuLCB0KTtcbn1cblxuZnVuY3Rpb24gYmUoZSkge1xuICByZXR1cm4geGUoZS5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24geXQoZSwgbikge1xuICByZXR1cm4ganQoaGUobiwgZSkpO1xufVxuXG5mdW5jdGlvbiBmZShlLCBuKSB7XG4gIHJldHVybiBXKGhlKG4sIGUpKTtcbn1cblxuZnVuY3Rpb24gZHQoZSwgbikge1xuICByZXR1cm4gU3QoaGUobiwgZSkpO1xufVxuXG5mdW5jdGlvbiBidChlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICBjb25zdCByID0gKGUgPT4gZWkobm9ybWFsaXplT3B0aW9ucyhlKSkpKG8pO1xuICAgIHJldHVybiBnZXRTaW5nbGVJbnN0YW50Rm9yKGUobiksIHQsIHIpO1xuICB9KShlLCB0LCBuLCBvKTtcbiAgcmV0dXJuIF9lKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMociksIHQsIG4uY2FsZW5kYXIpO1xufVxuXG5mdW5jdGlvbiBhZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBlKHIudGltZVpvbmUpLCBhID0gci5wbGFpblRpbWUsIHMgPSB2b2lkIDAgIT09IGEgPyBuKGEpIDogdm9pZCAwLCBjID0gdChpKTtcbiAgbGV0IHU7XG4gIHJldHVybiB1ID0gcyA/IGdldFNpbmdsZUluc3RhbnRGb3IoYywge1xuICAgIC4uLm8sXG4gICAgLi4uc1xuICB9KSA6IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKGMsIHtcbiAgICAuLi5vLFxuICAgIC4uLk50XG4gIH0pLCBfZSh1LCBpLCBvLmNhbGVuZGFyKTtcbn1cblxuZnVuY3Rpb24gaWUoZSwgbiA9IE50KSB7XG4gIHJldHVybiBqdChjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLmUsXG4gICAgLi4ublxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGxlKGUsIG4sIHQpIHtcbiAgcmV0dXJuICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSByZWZpbmVDYWxlbmRhckZpZWxkcyhlLCBuLCBRbyk7XG4gICAgcmV0dXJuIGUuSyh0LCB2b2lkIDApO1xuICB9KShlKG4uY2FsZW5kYXIpLCB0KTtcbn1cblxuZnVuY3Rpb24gc2UoZSwgbiwgdCkge1xuICByZXR1cm4gKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIG5yKTtcbiAgICByZXR1cm4gZS5fKHQpO1xuICB9KShlKG4uY2FsZW5kYXIpLCB0KTtcbn1cblxuZnVuY3Rpb24gSHQoZSwgbiwgdCwgbykge1xuICByZXR1cm4gKChlLCBuLCB0KSA9PiBjb252ZXJ0VG9Jc28oZSwgbiwgUW8sIHJlcXVpcmVPYmplY3RMaWtlKHQpLCBKbykpKGUobi5jYWxlbmRhciksIHQsIG8pO1xufVxuXG5mdW5jdGlvbiBWdChlLCBuLCB0LCBvKSB7XG4gIHJldHVybiAoKGUsIG4sIHQpID0+IGNvbnZlcnRUb0lzbyhlLCBuLCBuciwgcmVxdWlyZU9iamVjdExpa2UodCksIEdvKSkoZShuLmNhbGVuZGFyKSwgdCwgbyk7XG59XG5cbmZ1bmN0aW9uICRlKGUpIHtcbiAgcmV0dXJuIHhlKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoR2UodG9TdHJpY3RJbnRlZ2VyKGUpLCBRZSkpKTtcbn1cblxuZnVuY3Rpb24gSGUoZSkge1xuICByZXR1cm4geGUoY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhiaWdJbnRUb0JpZ05hbm8odG9CaWdJbnQoZSkpKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnNUcmFuc2Zvcm1lcihlLCBuLCB0KSB7XG4gIGNvbnN0IG8gPSBuZXcgU2V0KHQpO1xuICByZXR1cm4gKHIsIGkpID0+IHtcbiAgICBjb25zdCBhID0gdCAmJiBoYXNBbnlQcm9wc0J5TmFtZShyLCB0KTtcbiAgICBpZiAoIWhhc0FueVByb3BzQnlOYW1lKHIgPSAoKGUsIG4pID0+IHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbyBpbiBuKSB7XG4gICAgICAgIGUuaGFzKG8pIHx8ICh0W29dID0gbltvXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9KShvLCByKSwgZSkpIHtcbiAgICAgIGlmIChpICYmIGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZm9ybWF0dGluZyBvcHRpb25zXCIpO1xuICAgICAgfVxuICAgICAgciA9IHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgLi4uclxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHQgJiYgKHIudGltZVpvbmUgPSBzaSwgWyBcImZ1bGxcIiwgXCJsb25nXCIgXS5pbmNsdWRlcyhyLkopICYmIChyLkogPSBcIm1lZGl1bVwiKSksIFxuICAgIHI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFEoZSwgbiA9IGFuLCB0ID0gMCkge1xuICBjb25zdCBbbywgLCAsIHJdID0gZTtcbiAgcmV0dXJuIChpLCBhID0gTmEsIC4uLnMpID0+IHtcbiAgICBjb25zdCBjID0gbihyICYmIHIoLi4ucyksIGksIGEsIG8sIHQpLCB1ID0gYy5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICByZXR1cm4gWyBjLCAuLi50b0Vwb2NoTWlsbGlzKGUsIHUsIHMpIF07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFuKGUsIG4sIHQsIG8sIHIpIHtcbiAgaWYgKHQgPSBvKHQsIHIpLCBlKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gdC50aW1lWm9uZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihTbyk7XG4gICAgfVxuICAgIHQudGltZVpvbmUgPSBlO1xuICB9XG4gIHJldHVybiBuZXcgZW4obiwgdCk7XG59XG5cbmZ1bmN0aW9uIHRvRXBvY2hNaWxsaXMoZSwgbiwgdCkge1xuICBjb25zdCBbLCBvLCByXSA9IGU7XG4gIHJldHVybiB0Lm1hcCgoZSA9PiAoZS5jYWxlbmRhciAmJiAoKGUsIG4sIHQpID0+IHtcbiAgICBpZiAoKHQgfHwgZSAhPT0gbCkgJiYgZSAhPT0gbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IobG8pO1xuICAgIH1cbiAgfSkoZS5jYWxlbmRhciwgbi5jYWxlbmRhciwgciksIG8oZSwgbikpKSk7XG59XG5cbmZ1bmN0aW9uIGdlKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IG4udGltZVpvbmUsIHIgPSBlKG8pLCBpID0ge1xuICAgIC4uLmhlKG4sIHIpLFxuICAgIC4uLnQgfHwgTnRcbiAgfTtcbiAgbGV0IGE7XG4gIHJldHVybiBhID0gdCA/IGdldE1hdGNoaW5nSW5zdGFudEZvcihyLCBpLCBpLm9mZnNldE5hbm9zZWNvbmRzLCAyKSA6IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKHIsIGkpLCBcbiAgX2UoYSwgbywgbi5jYWxlbmRhcik7XG59XG5cbmZ1bmN0aW9uIE90KGUsIG4gPSBOdCkge1xuICByZXR1cm4ganQoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHtcbiAgICAuLi5lLFxuICAgIC4uLm5cbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBwdChlLCBuKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICBjYWxlbmRhcjogblxuICB9O1xufVxuXG5mdW5jdGlvbiBQZShlLCBuKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICB0aW1lWm9uZTogblxuICB9O1xufVxuXG5mdW5jdGlvbiB0bihlKSB7XG4gIGNvbnN0IG4gPSBYZSgpO1xuICByZXR1cm4gZXBvY2hOYW5vVG9Jc28obiwgZS5SKG4pKTtcbn1cblxuZnVuY3Rpb24gWGUoKSB7XG4gIHJldHVybiBHZShEYXRlLm5vdygpLCBRZSk7XG59XG5cbmZ1bmN0aW9uIFVlKCkge1xuICByZXR1cm4gdmEgfHwgKHZhID0gKG5ldyBlbikucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpO1xufVxuXG5jb25zdCBleHBlY3RlZEludGVnZXIgPSAoZSwgbikgPT4gYE5vbi1pbnRlZ2VyICR7ZX06ICR7bn1gLCBleHBlY3RlZFBvc2l0aXZlID0gKGUsIG4pID0+IGBOb24tcG9zaXRpdmUgJHtlfTogJHtufWAsIGV4cGVjdGVkRmluaXRlID0gKGUsIG4pID0+IGBOb24tZmluaXRlICR7ZX06ICR7bn1gLCBmb3JiaWRkZW5CaWdJbnRUb051bWJlciA9IGUgPT4gYENhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byAke2V9YCwgaW52YWxpZEJpZ0ludCA9IGUgPT4gYEludmFsaWQgYmlnaW50OiAke2V9YCwgbm8gPSBcIkNhbm5vdCBjb252ZXJ0IFN5bWJvbCB0byBzdHJpbmdcIiwgb28gPSBcIkludmFsaWQgb2JqZWN0XCIsIG51bWJlck91dE9mUmFuZ2UgPSAoZSwgbiwgdCwgbywgcikgPT4gciA/IG51bWJlck91dE9mUmFuZ2UoZSwgcltuXSwgclt0XSwgcltvXSkgOiBpbnZhbGlkRW50aXR5KGUsIG4pICsgYDsgbXVzdCBiZSBiZXR3ZWVuICR7dH0tJHtvfWAsIGludmFsaWRFbnRpdHkgPSAoZSwgbikgPT4gYEludmFsaWQgJHtlfTogJHtufWAsIG1pc3NpbmdGaWVsZCA9IGUgPT4gYE1pc3NpbmcgJHtlfWAsIGZvcmJpZGRlbkZpZWxkID0gZSA9PiBgSW52YWxpZCBmaWVsZCAke2V9YCwgZHVwbGljYXRlRmllbGRzID0gZSA9PiBgRHVwbGljYXRlIGZpZWxkICR7ZX1gLCBub1ZhbGlkRmllbGRzID0gZSA9PiBcIk5vIHZhbGlkIGZpZWxkczogXCIgKyBlLmpvaW4oKSwgaSA9IFwiSW52YWxpZCBiYWdcIiwgaW52YWxpZENob2ljZSA9IChlLCBuLCB0KSA9PiBpbnZhbGlkRW50aXR5KGUsIG4pICsgXCI7IG11c3QgYmUgXCIgKyBPYmplY3Qua2V5cyh0KS5qb2luKCksIGIgPSBcIkNhbm5vdCB1c2UgdmFsdWVPZlwiLCBhID0gXCJJbnZhbGlkIGNhbGxpbmcgY29udGV4dFwiLCBybyA9IFwiRm9yYmlkZGVuIGVyYS9lcmFZZWFyXCIsIGlvID0gXCJNaXNtYXRjaGluZyBlcmEvZXJhWWVhclwiLCBhbyA9IFwiTWlzbWF0Y2hpbmcgeWVhci9lcmFZZWFyXCIsIGludmFsaWRFcmEgPSBlID0+IGBJbnZhbGlkIGVyYTogJHtlfWAsIG1pc3NpbmdZZWFyID0gZSA9PiBcIk1pc3NpbmcgeWVhclwiICsgKGUgPyBcIi9lcmEvZXJhWWVhclwiIDogXCJcIiksIGludmFsaWRNb250aENvZGUgPSBlID0+IGBJbnZhbGlkIG1vbnRoQ29kZTogJHtlfWAsIHNvID0gXCJNaXNtYXRjaGluZyBtb250aC9tb250aENvZGVcIiwgY28gPSBcIk1pc3NpbmcgbW9udGgvbW9udGhDb2RlXCIsIHVvID0gXCJJbnZhbGlkIGxlYXAgbW9udGhcIiwgZm8gPSBcIkludmFsaWQgcHJvdG9jb2wgcmVzdWx0c1wiLCBjID0gZSA9PiBpbnZhbGlkRW50aXR5KFwiQ2FsZW5kYXJcIiwgZSksIGxvID0gXCJNaXNtYXRjaGluZyBDYWxlbmRhcnNcIiwgRiA9IGUgPT4gaW52YWxpZEVudGl0eShcIlRpbWVab25lXCIsIGUpLCBtbyA9IFwiTWlzbWF0Y2hpbmcgVGltZVpvbmVzXCIsIHBvID0gXCJGb3JiaWRkZW4gSUNVIFRpbWVab25lXCIsIGhvID0gXCJPdXQtb2YtYm91bmRzIG9mZnNldFwiLCBnbyA9IFwiT3V0LW9mLWJvdW5kcyBUaW1lWm9uZSBnYXBcIiwgRG8gPSBcIkludmFsaWQgVGltZVpvbmUgb2Zmc2V0XCIsIFRvID0gXCJBbWJpZ3VvdXMgb2Zmc2V0XCIsIElvID0gXCJPdXQtb2YtYm91bmRzIGRhdGVcIiwgTW8gPSBcIk91dC1vZi1ib3VuZHMgZHVyYXRpb25cIiwgTm8gPSBcIkNhbm5vdCBtaXggZHVyYXRpb24gc2lnbnNcIiwgeW8gPSBcIk1pc3NpbmcgcmVsYXRpdmVUb1wiLCB2byA9IFwiQ2Fubm90IHVzZSBsYXJnZSB1bml0c1wiLCBQbyA9IFwiUmVxdWlyZWQgc21hbGxlc3RVbml0IG9yIGxhcmdlc3RVbml0XCIsIEVvID0gXCJzbWFsbGVzdFVuaXQgPiBsYXJnZXN0VW5pdFwiLCBmYWlsZWRQYXJzZSA9IGUgPT4gYENhbm5vdCBwYXJzZTogJHtlfWAsIGludmFsaWRTdWJzdHJpbmcgPSBlID0+IGBJbnZhbGlkIHN1YnN0cmluZzogJHtlfWAsIHJuID0gZSA9PiBgQ2Fubm90IGZvcm1hdCAke2V9YCwgbG4gPSBcIk1pc21hdGNoaW5nIHR5cGVzIGZvciBmb3JtYXR0aW5nXCIsIFNvID0gXCJDYW5ub3Qgc3BlY2lmeSBUaW1lWm9uZVwiLCBGbyA9IC8qQF9fUFVSRV9fKi8gUHQoZywgKChlLCBuKSA9PiBuKSksIHdvID0gLypAX19QVVJFX18qLyBQdChnLCAoKGUsIG4sIHQpID0+IHQpKSwgYm8gPSAvKkBfX1BVUkVfXyovIFB0KHBhZE51bWJlciwgMiksIE9vID0ge1xuICBuYW5vc2Vjb25kOiAwLFxuICBtaWNyb3NlY29uZDogMSxcbiAgbWlsbGlzZWNvbmQ6IDIsXG4gIHNlY29uZDogMyxcbiAgbWludXRlOiA0LFxuICBob3VyOiA1LFxuICBkYXk6IDYsXG4gIHdlZWs6IDcsXG4gIG1vbnRoOiA4LFxuICB5ZWFyOiA5XG59LCBCbyA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmtleXMoT28pLCBrbyA9IDg2NGU1LCBDbyA9IDFlMywgWW8gPSAxZTMsIFFlID0gMWU2LCBSbyA9IDFlOSwgWm8gPSA2ZTEwLCB6byA9IDM2ZTExLCBVbyA9IDg2NGUxMSwgQW8gPSBbIDEsIFlvLCBRZSwgUm8sIFpvLCB6bywgVW8gXSwgTyA9IC8qQF9fUFVSRV9fKi8gQm8uc2xpY2UoMCwgNiksIHFvID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyhPKSwgV28gPSBbIFwib2Zmc2V0XCIgXSwgam8gPSBbIFwidGltZVpvbmVcIiBdLCBMbyA9IC8qQF9fUFVSRV9fKi8gTy5jb25jYXQoV28pLCB4byA9IC8qQF9fUFVSRV9fKi8gTG8uY29uY2F0KGpvKSwgJG8gPSBbIFwiZXJhXCIsIFwiZXJhWWVhclwiIF0sIEhvID0gLypAX19QVVJFX18qLyAkby5jb25jYXQoWyBcInllYXJcIiBdKSwgR28gPSBbIFwieWVhclwiIF0sIFZvID0gWyBcIm1vbnRoQ29kZVwiIF0sIF9vID0gLypAX19QVVJFX18qLyBbIFwibW9udGhcIiBdLmNvbmNhdChWbyksIEpvID0gWyBcImRheVwiIF0sIEtvID0gLypAX19QVVJFX18qLyBfby5jb25jYXQoR28pLCBRbyA9IC8qQF9fUFVSRV9fKi8gVm8uY29uY2F0KEdvKSwgWG8gPSAvKkBfX1BVUkVfXyovIEpvLmNvbmNhdChLbyksIGVyID0gLypAX19QVVJFX18qLyBKby5jb25jYXQoX28pLCBuciA9IC8qQF9fUFVSRV9fKi8gSm8uY29uY2F0KFZvKSwgdHIgPSAvKkBfX1BVUkVfXyovIHdvKE8sIDApLCBsID0gXCJpc284NjAxXCIsIG9yID0gXCJncmVnb3J5XCIsIHJyID0gXCJqYXBhbmVzZVwiLCBpciA9IHtcbiAgW29yXToge1xuICAgIFwiZ3JlZ29yeS1pbnZlcnNlXCI6IC0xLFxuICAgIGdyZWdvcnk6IDBcbiAgfSxcbiAgW3JyXToge1xuICAgIFwiamFwYW5lc2UtaW52ZXJzZVwiOiAtMSxcbiAgICBqYXBhbmVzZTogMCxcbiAgICBtZWlqaTogMTg2NyxcbiAgICB0YWlzaG86IDE5MTEsXG4gICAgc2hvd2E6IDE5MjUsXG4gICAgaGVpc2VpOiAxOTg4LFxuICAgIHJlaXdhOiAyMDE4XG4gIH0sXG4gIGV0aGlvcGljOiB7XG4gICAgZXRoaW9hYTogMCxcbiAgICBldGhpb3BpYzogNTUwMFxuICB9LFxuICBjb3B0aWM6IHtcbiAgICBcImNvcHRpYy1pbnZlcnNlXCI6IC0xLFxuICAgIGNvcHRpYzogMFxuICB9LFxuICByb2M6IHtcbiAgICBcInJvYy1pbnZlcnNlXCI6IC0xLFxuICAgIHJvYzogMFxuICB9LFxuICBidWRkaGlzdDoge1xuICAgIGJlOiAwXG4gIH0sXG4gIGlzbGFtaWM6IHtcbiAgICBhaDogMFxuICB9LFxuICBpbmRpYW46IHtcbiAgICBzYWthOiAwXG4gIH0sXG4gIHBlcnNpYW46IHtcbiAgICBhcDogMFxuICB9XG59LCBhciA9IHtcbiAgW29yXToge1xuICAgIGJjZTogXCJncmVnb3J5LWludmVyc2VcIixcbiAgICBjZTogXCJncmVnb3J5XCJcbiAgfSxcbiAgW3JyXToge1xuICAgIGJjZTogXCJqYXBhbmVzZS1pbnZlcnNlXCIsXG4gICAgY2U6IFwiamFwYW5lc2VcIlxuICB9LFxuICBldGhpb3BpYzoge1xuICAgIGVyYTA6IFwiZXRoaW9hYVwiLFxuICAgIGVyYTE6IFwiZXRoaW9waWNcIlxuICB9LFxuICBjb3B0aWM6IHtcbiAgICBlcmEwOiBcImNvcHRpYy1pbnZlcnNlXCIsXG4gICAgZXJhMTogXCJjb3B0aWNcIlxuICB9LFxuICByb2M6IHtcbiAgICBicm9jOiBcInJvYy1pbnZlcnNlXCIsXG4gICAgbWluZ3VvOiBcInJvY1wiXG4gIH1cbn0sIHNyID0ge1xuICBjaGluZXNlOiAxMyxcbiAgZGFuZ2k6IDEzLFxuICBoZWJyZXc6IC02XG59LCBtID0gLypAX19QVVJFX18qLyBQdChyZXF1aXJlVHlwZSwgXCJzdHJpbmdcIiksIEQgPSAvKkBfX1BVUkVfXyovIFB0KHJlcXVpcmVUeXBlLCBcImJvb2xlYW5cIiksIGNyID0gLypAX19QVVJFX18qLyBQdChyZXF1aXJlVHlwZSwgXCJudW1iZXJcIiksIHAgPSAvKkBfX1BVUkVfXyovIEJvLm1hcCgoZSA9PiBlICsgXCJzXCIpKSwgdXIgPSAvKkBfX1BVUkVfXyovIHNvcnRTdHJpbmdzKHApLCBmciA9IC8qQF9fUFVSRV9fKi8gcC5zbGljZSgwLCA2KSwgbHIgPSAvKkBfX1BVUkVfXyovIHAuc2xpY2UoNiksIGRyID0gLypAX19QVVJFX18qLyBsci5zbGljZSgxKSwgbXIgPSAvKkBfX1BVUkVfXyovIEZvKHApLCBwciA9IC8qQF9fUFVSRV9fKi8gd28ocCwgMCksIGhyID0gLypAX19QVVJFX18qLyB3byhmciwgMCksIGdyID0gLypAX19QVVJFX18qLyBQdCh6ZXJvT3V0UHJvcHMsIHApLCB3ID0gWyBcImlzb05hbm9zZWNvbmRcIiwgXCJpc29NaWNyb3NlY29uZFwiLCBcImlzb01pbGxpc2Vjb25kXCIsIFwiaXNvU2Vjb25kXCIsIFwiaXNvTWludXRlXCIsIFwiaXNvSG91clwiIF0sIERyID0gWyBcImlzb0RheVwiLCBcImlzb01vbnRoXCIsIFwiaXNvWWVhclwiIF0sIFRyID0gLypAX19QVVJFX18qLyB3LmNvbmNhdChEciksIElyID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyhEciksIE1yID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyh3KSwgTnIgPSAvKkBfX1BVUkVfXyovIHNvcnRTdHJpbmdzKFRyKSwgTnQgPSAvKkBfX1BVUkVfXyovIHdvKE1yLCAwKSwgeXIgPSAvKkBfX1BVUkVfXyovIFB0KHplcm9PdXRQcm9wcywgVHIpLCB2ciA9IDFlOCwgUHIgPSB2ciAqIGtvLCBFciA9IFsgdnIsIDAgXSwgU3IgPSBbIC12ciwgMCBdLCBGciA9IDI3NTc2MCwgd3IgPSAtMjcxODIxLCBlbiA9IEludGwuRGF0ZVRpbWVGb3JtYXQsIGJyID0gXCJlbi1HQlwiLCBPciA9IDE5NzAsIEJyID0gMTk3Miwga3IgPSAxMiwgQ3IgPSAvKkBfX1BVUkVfXyovIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoMTg2OCwgOSwgOCksIFlyID0gLypAX19QVVJFX18qLyBvbihjb21wdXRlSmFwYW5lc2VFcmFQYXJ0cywgV2Vha01hcCksIFJyID0gXCJzbWFsbGVzdFVuaXRcIiwgWnIgPSBcInVuaXRcIiwgenIgPSBcInJvdW5kaW5nSW5jcmVtZW50XCIsIFVyID0gXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzXCIsIEFyID0gXCJyZWxhdGl2ZVRvXCIsIHFyID0gXCJkaXJlY3Rpb25cIiwgV3IgPSB7XG4gIGNvbnN0cmFpbjogMCxcbiAgcmVqZWN0OiAxXG59LCBqciA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmtleXMoV3IpLCBMciA9IHtcbiAgY29tcGF0aWJsZTogMCxcbiAgcmVqZWN0OiAxLFxuICBlYXJsaWVyOiAyLFxuICBsYXRlcjogM1xufSwgeHIgPSB7XG4gIHJlamVjdDogMCxcbiAgdXNlOiAxLFxuICBwcmVmZXI6IDIsXG4gIGlnbm9yZTogM1xufSwgJHIgPSB7XG4gIGF1dG86IDAsXG4gIG5ldmVyOiAxLFxuICBjcml0aWNhbDogMixcbiAgYWx3YXlzOiAzXG59LCBIciA9IHtcbiAgYXV0bzogMCxcbiAgbmV2ZXI6IDEsXG4gIGNyaXRpY2FsOiAyXG59LCBHciA9IHtcbiAgYXV0bzogMCxcbiAgbmV2ZXI6IDFcbn0sIFZyID0ge1xuICBmbG9vcjogMCxcbiAgaGFsZkZsb29yOiAxLFxuICBjZWlsOiAyLFxuICBoYWxmQ2VpbDogMyxcbiAgdHJ1bmM6IDQsXG4gIGhhbGZUcnVuYzogNSxcbiAgZXhwYW5kOiA2LFxuICBoYWxmRXhwYW5kOiA3LFxuICBoYWxmRXZlbjogOFxufSwgX3IgPSB7XG4gIHByZXZpb3VzOiAtMSxcbiAgbmV4dDogMVxufSwgSnIgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZVVuaXRPcHRpb24sIFJyKSwgS3IgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZVVuaXRPcHRpb24sIFwibGFyZ2VzdFVuaXRcIiksIFFyID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVVbml0T3B0aW9uLCBaciksIFhyID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVDaG9pY2VPcHRpb24sIFwib3ZlcmZsb3dcIiwgV3IpLCBlaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcImRpc2FtYmlndWF0aW9uXCIsIExyKSwgbmkgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZUNob2ljZU9wdGlvbiwgXCJvZmZzZXRcIiwgeHIpLCB0aSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcImNhbGVuZGFyTmFtZVwiLCAkciksIG9pID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVDaG9pY2VPcHRpb24sIFwidGltZVpvbmVOYW1lXCIsIEhyKSwgcmkgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZUNob2ljZU9wdGlvbiwgXCJvZmZzZXRcIiwgR3IpLCBpaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcInJvdW5kaW5nTW9kZVwiLCBWciksIFV0ID0gXCJQbGFpblllYXJNb250aFwiLCBxdCA9IFwiUGxhaW5Nb250aERheVwiLCBHID0gXCJQbGFpbkRhdGVcIiwgeCA9IFwiUGxhaW5EYXRlVGltZVwiLCBmdCA9IFwiUGxhaW5UaW1lXCIsIHogPSBcIlpvbmVkRGF0ZVRpbWVcIiwgUmUgPSBcIkluc3RhbnRcIiwgTiA9IFwiRHVyYXRpb25cIiwgYWkgPSBbIE1hdGguZmxvb3IsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGguZmxvb3IoZSkgOiBNYXRoLnJvdW5kKGUpLCBNYXRoLmNlaWwsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGguY2VpbChlKSA6IE1hdGgucm91bmQoZSksIE1hdGgudHJ1bmMsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGgudHJ1bmMoZSkgfHwgMCA6IE1hdGgucm91bmQoZSksIGUgPT4gZSA8IDAgPyBNYXRoLmZsb29yKGUpIDogTWF0aC5jZWlsKGUpLCBlID0+IE1hdGguc2lnbihlKSAqIE1hdGgucm91bmQoTWF0aC5hYnMoZSkpIHx8IDAsIGUgPT4gaGFzSGFsZihlKSA/IChlID0gTWF0aC50cnVuYyhlKSB8fCAwKSArIGUgJSAyIDogTWF0aC5yb3VuZChlKSBdLCBzaSA9IFwiVVRDXCIsIGNpID0gNTE4NGUzLCB1aSA9IC8qQF9fUFVSRV9fKi8gaXNvQXJnc1RvRXBvY2hTZWMoMTg0NyksIGZpID0gLypAX19QVVJFX18qLyBpc29BcmdzVG9FcG9jaFNlYygvKkBfX1BVUkVfXyovICgvKkBfX1BVUkVfXyovIG5ldyBEYXRlKS5nZXRVVENGdWxsWWVhcigpICsgMTApLCBsaSA9IC8wKyQvLCBoZSA9IC8qQF9fUFVSRV9fKi8gb24oX3pvbmVkRXBvY2hTbG90c1RvSXNvLCBXZWFrTWFwKSwgZGkgPSAyICoqIDMyIC0gMSwgTCA9IC8qQF9fUFVSRV9fKi8gb24oKGUgPT4ge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IG5ldyBJbnRsVGltZVpvbmUobikgOiBuZXcgRml4ZWRUaW1lWm9uZShuIHx8IDApO1xufSkpO1xuXG5jbGFzcyBGaXhlZFRpbWVab25lIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuJCA9IGU7XG4gIH1cbiAgUigpIHtcbiAgICByZXR1cm4gdGhpcy4kO1xuICB9XG4gIEkoZSkge1xuICAgIHJldHVybiAoZSA9PiB7XG4gICAgICBjb25zdCBuID0gaXNvVG9FcG9jaE5hbm8oe1xuICAgICAgICAuLi5lLFxuICAgICAgICAuLi5OdFxuICAgICAgfSk7XG4gICAgICBpZiAoIW4gfHwgTWF0aC5hYnMoblswXSkgPiAxZTgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICAgICAgfVxuICAgIH0pKGUpLCBbIGlzb1RvRXBvY2hOYW5vV2l0aE9mZnNldChlLCB0aGlzLiQpIF07XG4gIH1cbiAgTygpIHt9XG59XG5cbmNsYXNzIEludGxUaW1lWm9uZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm5uID0gKGUgPT4ge1xuICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0U2VjKGUpIHtcbiAgICAgICAgY29uc3QgaSA9IGNsYW1wTnVtYmVyKGUsIG8sIHIpLCBbYSwgc10gPSBjb21wdXRlUGVyaW9kKGkpLCBjID0gbihhKSwgdSA9IG4ocyk7XG4gICAgICAgIHJldHVybiBjID09PSB1ID8gYyA6IHBpbmNoKHQoYSwgcyksIGMsIHUsIGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGluY2gobiwgdCwgbywgcikge1xuICAgICAgICBsZXQgaSwgYTtcbiAgICAgICAgZm9yICg7KHZvaWQgMCA9PT0gciB8fCB2b2lkIDAgPT09IChpID0gciA8IG5bMF0gPyB0IDogciA+PSBuWzFdID8gbyA6IHZvaWQgMCkpICYmIChhID0gblsxXSAtIG5bMF0pOyApIHtcbiAgICAgICAgICBjb25zdCB0ID0gblswXSArIE1hdGguZmxvb3IoYSAvIDIpO1xuICAgICAgICAgIGUodCkgPT09IG8gPyBuWzFdID0gdCA6IG5bMF0gPSB0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSBvbihlKSwgdCA9IG9uKGNyZWF0ZVNwbGl0VHVwbGUpO1xuICAgICAgbGV0IG8gPSB1aSwgciA9IGZpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG4oZSkge1xuICAgICAgICAgIGNvbnN0IG4gPSBnZXRPZmZzZXRTZWMoZSAtIDg2NDAwKSwgdCA9IGdldE9mZnNldFNlYyhlICsgODY0MDApLCBvID0gZSAtIG4sIHIgPSBlIC0gdDtcbiAgICAgICAgICBpZiAobiA9PT0gdCkge1xuICAgICAgICAgICAgcmV0dXJuIFsgbyBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpID0gZ2V0T2Zmc2V0U2VjKG8pO1xuICAgICAgICAgIHJldHVybiBpID09PSBnZXRPZmZzZXRTZWMocikgPyBbIGUgLSBpIF0gOiBuID4gdCA/IFsgbywgciBdIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIHJuOiBnZXRPZmZzZXRTZWMsXG4gICAgICAgIE8oZSwgaSkge1xuICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcE51bWJlcihlLCBvLCByKTtcbiAgICAgICAgICBsZXQgW3MsIGNdID0gY29tcHV0ZVBlcmlvZChhKTtcbiAgICAgICAgICBjb25zdCB1ID0gY2kgKiBpLCBmID0gaSA8IDAgPyAoKSA9PiBjID4gbyB8fCAobyA9IGEsIDApIDogKCkgPT4gcyA8IHIgfHwgKHIgPSBhLCBcbiAgICAgICAgICAwKTtcbiAgICAgICAgICBmb3IgKDtmKCk7ICkge1xuICAgICAgICAgICAgY29uc3QgbyA9IG4ocyksIHIgPSBuKGMpO1xuICAgICAgICAgICAgaWYgKG8gIT09IHIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHQocywgYyk7XG4gICAgICAgICAgICAgIHBpbmNoKG4sIG8sIHIpO1xuICAgICAgICAgICAgICBjb25zdCBhID0gblswXTtcbiAgICAgICAgICAgICAgaWYgKChjb21wYXJlTnVtYmVycyhhLCBlKSB8fCAxKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9IHUsIGMgKz0gdTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKGUgPT4gbiA9PiB7XG4gICAgICBjb25zdCB0ID0gaGFzaEludGxGb3JtYXRQYXJ0cyhlLCBuICogQ28pO1xuICAgICAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoU2VjKHBhcnNlSW50bFBhcnRzWWVhcih0KSwgcGFyc2VJbnQodC5tb250aCksIHBhcnNlSW50KHQuZGF5KSwgcGFyc2VJbnQodC5ob3VyKSwgcGFyc2VJbnQodC5taW51dGUpLCBwYXJzZUludCh0LnNlY29uZCkpIC0gbjtcbiAgICB9KShlKSk7XG4gIH1cbiAgUihlKSB7XG4gICAgcmV0dXJuIHRoaXMubm4ucm4oKGUgPT4gZXBvY2hOYW5vVG9TZWNNb2QoZSlbMF0pKGUpKSAqIFJvO1xuICB9XG4gIEkoZSkge1xuICAgIGNvbnN0IFtuLCB0XSA9IFsgaXNvQXJnc1RvRXBvY2hTZWMoKG8gPSBlKS5pc29ZZWFyLCBvLmlzb01vbnRoLCBvLmlzb0RheSwgby5pc29Ib3VyLCBvLmlzb01pbnV0ZSwgby5pc29TZWNvbmQpLCBvLmlzb01pbGxpc2Vjb25kICogUWUgKyBvLmlzb01pY3Jvc2Vjb25kICogWW8gKyBvLmlzb05hbm9zZWNvbmQgXTtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gdGhpcy5ubi50bihuKS5tYXAoKGUgPT4gY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhtb3ZlQmlnTmFubyhHZShlLCBSbyksIHQpKSkpO1xuICB9XG4gIE8oZSwgbikge1xuICAgIGNvbnN0IFt0LCBvXSA9IGVwb2NoTmFub1RvU2VjTW9kKGUpLCByID0gdGhpcy5ubi5PKHQgKyAobiA+IDAgfHwgbyA/IDEgOiAwKSwgbik7XG4gICAgaWYgKHZvaWQgMCAhPT0gcikge1xuICAgICAgcmV0dXJuIEdlKHIsIFJvKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbWkgPSBcIihbKy1dKVwiLCBwaSA9IFwiKD86Wy4sXShcXFxcZHsxLDl9KSk/XCIsIGhpID0gYCg/Oig/OiR7bWl9KFxcXFxkezZ9KSl8KFxcXFxkezR9KSktPyhcXFxcZHsyfSlgLCBnaSA9IFwiKFxcXFxkezJ9KSg/Ojo/KFxcXFxkezJ9KSg/Ojo/KFxcXFxkezJ9KVwiICsgcGkgKyBcIik/KT9cIiwgRGkgPSBtaSArIGdpLCBUaSA9IGhpICsgXCItPyhcXFxcZHsyfSkoPzpbVCBdXCIgKyBnaSArIFwiKFp8XCIgKyBEaSArIFwiKT8pP1wiLCBJaSA9IFwiXFxcXFsoIT8pKFteXFxcXF1dKilcXFxcXVwiLCBNaSA9IGAoKD86JHtJaX0pezAsOX0pYCwgTmkgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlZ0V4cChoaSArIE1pKSwgeWkgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlZ0V4cChcIig/Oi0tKT8oXFxcXGR7Mn0pLT8oXFxcXGR7Mn0pXCIgKyBNaSksIHZpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoVGkgKyBNaSksIFBpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoXCJUP1wiICsgZ2kgKyBcIig/OlwiICsgRGkgKyBcIik/XCIgKyBNaSksIEVpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoRGkpLCBTaSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJlZ0V4cChJaSwgXCJnXCIpLCBGaSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVnRXhwKGAke21pfT9QKFxcXFxkK1kpPyhcXFxcZCtNKT8oXFxcXGQrVyk/KFxcXFxkK0QpPyg/OlQoPzooXFxcXGQrKSR7cGl9SCk/KD86KFxcXFxkKykke3BpfU0pPyg/OihcXFxcZCspJHtwaX1TKT8pP2ApLCB3aSA9IC8qQF9fUFVSRV9fKi8gb24oKGUgPT4gbmV3IGVuKGJyLCB7XG4gIHRpbWVab25lOiBlLFxuICBlcmE6IFwic2hvcnRcIixcbiAgeWVhcjogXCJudW1lcmljXCIsXG4gIG1vbnRoOiBcIm51bWVyaWNcIixcbiAgZGF5OiBcIm51bWVyaWNcIixcbiAgaG91cjogXCJudW1lcmljXCIsXG4gIG1pbnV0ZTogXCJudW1lcmljXCIsXG4gIHNlY29uZDogXCJudW1lcmljXCJcbn0pKSksIGJpID0gL14oQUN8QUV8QUd8QVJ8QVN8QkV8QlN8Q0F8Q058Q1N8Q1R8RUF8RUN8SUV8SVN8SlN8TUl8TkV8TlN8UEx8UE58UFJ8UFN8U1N8VlMpVCQvLCBPaSA9IC9bXlxcd1xcLzorLV0rLywgQmkgPSAvXk0oXFxkezJ9KShMPykkLywga2kgPSAvKkBfX1BVUkVfXyovIG9uKGNyZWF0ZUludGxDYWxlbmRhciksIENpID0gLypAX19QVVJFX18qLyBvbigoZSA9PiBuZXcgZW4oYnIsIHtcbiAgY2FsZW5kYXI6IGUsXG4gIHRpbWVab25lOiBzaSxcbiAgZXJhOiBcInNob3J0XCIsXG4gIHllYXI6IFwibnVtZXJpY1wiLFxuICBtb250aDogXCJzaG9ydFwiLFxuICBkYXk6IFwibnVtZXJpY1wiXG59KSkpLCBZaSA9IHtcbiAgUChlLCBuLCB0KSB7XG4gICAgY29uc3QgbyA9IG10KHQpO1xuICAgIGxldCByLCB7eWVhcnM6IGksIG1vbnRoczogYSwgd2Vla3M6IHMsIGRheXM6IGN9ID0gbjtcbiAgICBpZiAoYyArPSBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhuLCA1KVswXSwgaSB8fCBhKSB7XG4gICAgICByID0gKChlLCBuLCB0LCBvLCByKSA9PiB7XG4gICAgICAgIGxldCBbaSwgYSwgc10gPSBlLnYobik7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgY29uc3QgW24sIG9dID0gZS5xKGksIGEpO1xuICAgICAgICAgIGkgKz0gdCwgYSA9IG1vbnRoQ29kZU51bWJlclRvTW9udGgobiwgbywgZS5MKGkpKSwgYSA9IGNsYW1wRW50aXR5KFwibW9udGhcIiwgYSwgMSwgZS5CKGkpLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbyAmJiAoW2ksIGFdID0gZS51bihpLCBhLCBvKSksIHMgPSBjbGFtcEVudGl0eShcImRheVwiLCBzLCAxLCBlLlUoaSwgYSksIHIpLCBcbiAgICAgICAgZS5wKGksIGEsIHMpO1xuICAgICAgfSkodGhpcywgZSwgaSwgYSwgbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcyAmJiAhYykge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHIgPSBpc29Ub0Vwb2NoTWlsbGkoZSk7XG4gICAgfVxuICAgIGlmICh2b2lkIDAgPT09IHIpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKElvKTtcbiAgICB9XG4gICAgcmV0dXJuIHIgKz0gKDcgKiBzICsgYykgKiBrbywgY2hlY2tJc29EYXRlSW5Cb3VuZHMoZXBvY2hNaWxsaVRvSXNvKHIpKTtcbiAgfSxcbiAgTihlLCBuLCB0KSB7XG4gICAgaWYgKHQgPD0gNykge1xuICAgICAgbGV0IG8gPSAwLCByID0gZGlmZkRheXMoe1xuICAgICAgICAuLi5lLFxuICAgICAgICAuLi5OdFxuICAgICAgfSwge1xuICAgICAgICAuLi5uLFxuICAgICAgICAuLi5OdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gNyA9PT0gdCAmJiAoW28sIHJdID0gZGl2TW9kVHJ1bmMociwgNykpLCB7XG4gICAgICAgIC4uLnByLFxuICAgICAgICB3ZWVrczogbyxcbiAgICAgICAgZGF5czogclxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHRoaXMudihlKSwgciA9IHRoaXMudihuKTtcbiAgICBsZXQgW2ksIGEsIHNdID0gKChlLCBuLCB0LCBvLCByLCBpLCBhKSA9PiB7XG4gICAgICBsZXQgcyA9IHIgLSBuLCBjID0gaSAtIHQsIHUgPSBhIC0gbztcbiAgICAgIGlmIChzIHx8IGMpIHtcbiAgICAgICAgY29uc3QgZiA9IE1hdGguc2lnbihzIHx8IGMpO1xuICAgICAgICBsZXQgbCA9IGUuVShyLCBpKSwgZCA9IDA7XG4gICAgICAgIGlmIChNYXRoLnNpZ24odSkgPT09IC1mKSB7XG4gICAgICAgICAgY29uc3QgbyA9IGw7XG4gICAgICAgICAgW3IsIGldID0gZS51bihyLCBpLCAtZiksIHMgPSByIC0gbiwgYyA9IGkgLSB0LCBsID0gZS5VKHIsIGkpLCBkID0gZiA8IDAgPyAtbyA6IGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUgPSBhIC0gTWF0aC5taW4obywgbCkgKyBkLCBzKSB7XG4gICAgICAgICAgY29uc3QgW28sIGFdID0gZS5xKG4sIHQpLCBbdSwgbF0gPSBlLnEociwgaSk7XG4gICAgICAgICAgaWYgKGMgPSB1IC0gbyB8fCBOdW1iZXIobCkgLSBOdW1iZXIoYSksIE1hdGguc2lnbihjKSA9PT0gLWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBmIDwgMCAmJiAtZS5CKHIpO1xuICAgICAgICAgICAgcyA9IChyIC09IGYpIC0gbiwgYyA9IGkgLSBtb250aENvZGVOdW1iZXJUb01vbnRoKG8sIGEsIGUuTChyKSkgKyAodCB8fCBlLkIocikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsgcywgYywgdSBdO1xuICAgIH0pKHRoaXMsIC4uLm8sIC4uLnIpO1xuICAgIHJldHVybiA4ID09PSB0ICYmIChhICs9IHRoaXMuY24oaSwgb1swXSksIGkgPSAwKSwge1xuICAgICAgLi4ucHIsXG4gICAgICB5ZWFyczogaSxcbiAgICAgIG1vbnRoczogYSxcbiAgICAgIGRheXM6IHNcbiAgICB9O1xuICB9LFxuICBGKGUsIG4pIHtcbiAgICBjb25zdCB0ID0gbXQobiksIG8gPSByZWZpbmVZZWFyKHRoaXMsIGUpLCByID0gcmVmaW5lTW9udGgodGhpcywgZSwgbywgdCksIGkgPSByZWZpbmVEYXkodGhpcywgZSwgciwgbywgdCk7XG4gICAgcmV0dXJuIFcoY2hlY2tJc29EYXRlSW5Cb3VuZHModGhpcy5WKG8sIHIsIGkpKSwgdGhpcy5pZCB8fCBsKTtcbiAgfSxcbiAgSyhlLCBuKSB7XG4gICAgY29uc3QgdCA9IG10KG4pLCBvID0gcmVmaW5lWWVhcih0aGlzLCBlKSwgciA9IHJlZmluZU1vbnRoKHRoaXMsIGUsIG8sIHQpO1xuICAgIHJldHVybiBjcmVhdGVQbGFpblllYXJNb250aFNsb3RzKGNoZWNrSXNvWWVhck1vbnRoSW5Cb3VuZHModGhpcy5WKG8sIHIsIDEpKSwgdGhpcy5pZCB8fCBsKTtcbiAgfSxcbiAgXyhlLCBuKSB7XG4gICAgY29uc3QgdCA9IG10KG4pO1xuICAgIGxldCBvLCByLCBpLCBhID0gdm9pZCAwICE9PSBlLmVyYVllYXIgfHwgdm9pZCAwICE9PSBlLnllYXIgPyByZWZpbmVZZWFyKHRoaXMsIGUpIDogdm9pZCAwO1xuICAgIGNvbnN0IHMgPSAhdGhpcy5pZDtcbiAgICBpZiAodm9pZCAwID09PSBhICYmIHMgJiYgKGEgPSBCciksIHZvaWQgMCAhPT0gYSkge1xuICAgICAgY29uc3QgbiA9IHJlZmluZU1vbnRoKHRoaXMsIGUsIGEsIHQpO1xuICAgICAgbyA9IHJlZmluZURheSh0aGlzLCBlLCBuLCBhLCB0KTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLkwoYSk7XG4gICAgICByID0gbW9udGhUb01vbnRoQ29kZU51bWJlcihuLCBzKSwgaSA9IG4gPT09IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUubW9udGhDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY28pO1xuICAgICAgfVxuICAgICAgaWYgKFtyLCBpXSA9IHBhcnNlTW9udGhDb2RlKGUubW9udGhDb2RlKSwgdGhpcy5pZCAmJiB0aGlzLmlkICE9PSBvciAmJiB0aGlzLmlkICE9PSBycikge1xuICAgICAgICBpZiAodGhpcy5pZCAmJiBcImNvcHRpY1wiID09PSBjb21wdXRlQ2FsZW5kYXJJZEJhc2UodGhpcy5pZCkgJiYgMCA9PT0gdCkge1xuICAgICAgICAgIGNvbnN0IG4gPSBpIHx8IDEzICE9PSByID8gMzAgOiA2O1xuICAgICAgICAgIG8gPSBlLmRheSwgbyA9IGNsYW1wTnVtYmVyKG8sIDEsIG4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWQgJiYgXCJjaGluZXNlXCIgPT09IGNvbXB1dGVDYWxlbmRhcklkQmFzZSh0aGlzLmlkKSAmJiAwID09PSB0KSB7XG4gICAgICAgICAgY29uc3QgbiA9ICFpIHx8IDEgIT09IHIgJiYgOSAhPT0gciAmJiAxMCAhPT0gciAmJiAxMSAhPT0gciAmJiAxMiAhPT0gciA/IDMwIDogMjk7XG4gICAgICAgICAgbyA9IGUuZGF5LCBvID0gY2xhbXBOdW1iZXIobywgMSwgbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IGUuZGF5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0gcmVmaW5lRGF5KHRoaXMsIGUsIHJlZmluZU1vbnRoKHRoaXMsIGUsIEJyLCB0KSwgQnIsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5HKHIsIGksIG8pO1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW5ub3QgZ3Vlc3MgeWVhclwiKTtcbiAgICB9XG4gICAgY29uc3QgW3UsIGZdID0gYztcbiAgICByZXR1cm4gY3JlYXRlUGxhaW5Nb250aERheVNsb3RzKGNoZWNrSXNvRGF0ZUluQm91bmRzKHRoaXMuVih1LCBmLCBvKSksIHRoaXMuaWQgfHwgbCk7XG4gIH0sXG4gIGZpZWxkcyhlKSB7XG4gICAgcmV0dXJuIGdldENhbGVuZGFyRXJhT3JpZ2lucyh0aGlzKSAmJiBlLmluY2x1ZGVzKFwieWVhclwiKSA/IFsgLi4uZSwgLi4uJG8gXSA6IGU7XG4gIH0sXG4gIGsoZSwgbikge1xuICAgIGNvbnN0IHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGUpO1xuICAgIHJldHVybiBzcGxpY2VGaWVsZHModCwgbiwgX28pLCBnZXRDYWxlbmRhckVyYU9yaWdpbnModGhpcykgJiYgKHNwbGljZUZpZWxkcyh0LCBuLCBIbyksIFxuICAgIHRoaXMuaWQgPT09IHJyICYmIHNwbGljZUZpZWxkcyh0LCBuLCBlciwgJG8pKSwgdDtcbiAgfSxcbiAgaW5MZWFwWWVhcihlKSB7XG4gICAgY29uc3QgW25dID0gdGhpcy52KGUpO1xuICAgIHJldHVybiB0aGlzLnNuKG4pO1xuICB9LFxuICBtb250aHNJblllYXIoZSkge1xuICAgIGNvbnN0IFtuXSA9IHRoaXMudihlKTtcbiAgICByZXR1cm4gdGhpcy5CKG4pO1xuICB9LFxuICBkYXlzSW5Nb250aChlKSB7XG4gICAgY29uc3QgW24sIHRdID0gdGhpcy52KGUpO1xuICAgIHJldHVybiB0aGlzLlUobiwgdCk7XG4gIH0sXG4gIGRheXNJblllYXIoZSkge1xuICAgIGNvbnN0IFtuXSA9IHRoaXMudihlKTtcbiAgICByZXR1cm4gdGhpcy5mbihuKTtcbiAgfSxcbiAgZGF5T2ZZZWFyOiBjb21wdXRlTmF0aXZlRGF5T2ZZZWFyLFxuICBlcmEoZSkge1xuICAgIHJldHVybiB0aGlzLmhuKGUpWzBdO1xuICB9LFxuICBlcmFZZWFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5obihlKVsxXTtcbiAgfSxcbiAgbW9udGhDb2RlKGUpIHtcbiAgICBjb25zdCBbbiwgdF0gPSB0aGlzLnYoZSksIFtvLCByXSA9IHRoaXMucShuLCB0KTtcbiAgICByZXR1cm4gZm9ybWF0TW9udGhDb2RlKG8sIHIpO1xuICB9LFxuICBkYXlPZldlZWs6IGNvbXB1dGVJc29EYXlPZldlZWssXG4gIGRheXNJbldlZWsoKSB7XG4gICAgcmV0dXJuIDc7XG4gIH1cbn0sIFJpID0ge1xuICB2OiBjb21wdXRlSXNvRGF0ZVBhcnRzLFxuICBobjogY29tcHV0ZUlzb0VyYVBhcnRzLFxuICBxOiBjb21wdXRlSXNvTW9udGhDb2RlUGFydHNcbn0sIFppID0ge1xuICBkYXlPZlllYXI6IGNvbXB1dGVOYXRpdmVEYXlPZlllYXIsXG4gIHY6IGNvbXB1dGVJc29EYXRlUGFydHMsXG4gIHA6IGlzb0FyZ3NUb0Vwb2NoTWlsbGlcbn0sIHppID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBaaSwge1xuICB3ZWVrT2ZZZWFyOiBjb21wdXRlTmF0aXZlV2Vla09mWWVhcixcbiAgeWVhck9mV2VlazogY29tcHV0ZU5hdGl2ZVllYXJPZldlZWssXG4gIG0oZSkge1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrU2hpZnQoZSkge1xuICAgICAgcmV0dXJuICg3IC0gZSA8IG4gPyA3IDogMCkgLSBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla3NJblllYXIoZSkge1xuICAgICAgY29uc3QgbiA9IGNvbXB1dGVJc29EYXlzSW5ZZWFyKGYgKyBlKSwgdCA9IGUgfHwgMSwgbyA9IGNvbXB1dGVXZWVrU2hpZnQobW9kRmxvb3IoYSArIG4gKiB0LCA3KSk7XG4gICAgICByZXR1cm4gYyA9IChuICsgKG8gLSBzKSAqIHQpIC8gNztcbiAgICB9XG4gICAgY29uc3QgbiA9IHRoaXMuaWQgPyAxIDogNCwgdCA9IGNvbXB1dGVJc29EYXlPZldlZWsoZSksIG8gPSB0aGlzLmRheU9mWWVhcihlKSwgciA9IG1vZEZsb29yKHQgLSAxLCA3KSwgaSA9IG8gLSAxLCBhID0gbW9kRmxvb3IociAtIGksIDcpLCBzID0gY29tcHV0ZVdlZWtTaGlmdChhKTtcbiAgICBsZXQgYywgdSA9IE1hdGguZmxvb3IoKGkgLSBzKSAvIDcpICsgMSwgZiA9IGUuaXNvWWVhcjtcbiAgICByZXR1cm4gdSA/IHUgPiBjb21wdXRlV2Vla3NJblllYXIoMCkgJiYgKHUgPSAxLCBmKyspIDogKHUgPSBjb21wdXRlV2Vla3NJblllYXIoLTEpLCBcbiAgICBmLS0pLCBbIHUsIGYsIGMgXTtcbiAgfVxufSksIFVpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBZaSwgemksIHtcbiAgdjogY29tcHV0ZUlzb0RhdGVQYXJ0cyxcbiAgaG46IGNvbXB1dGVJc29FcmFQYXJ0cyxcbiAgcTogY29tcHV0ZUlzb01vbnRoQ29kZVBhcnRzLFxuICBHKGUsIG4pIHtcbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiBbIEJyLCBlIF07XG4gICAgfVxuICB9LFxuICBzbjogY29tcHV0ZUlzb0luTGVhcFllYXIsXG4gIEwoKSB7fSxcbiAgQjogY29tcHV0ZUlzb01vbnRoc0luWWVhcixcbiAgY246IGUgPT4gZSAqIGtyLFxuICBVOiBjb21wdXRlSXNvRGF5c0luTW9udGgsXG4gIGZuOiBjb21wdXRlSXNvRGF5c0luWWVhcixcbiAgVjogKGUsIG4sIHQpID0+ICh7XG4gICAgaXNvWWVhcjogZSxcbiAgICBpc29Nb250aDogbixcbiAgICBpc29EYXk6IHRcbiAgfSksXG4gIHA6IGlzb0FyZ3NUb0Vwb2NoTWlsbGksXG4gIHVuOiAoZSwgbiwgdCkgPT4gKGUgKz0gZGl2VHJ1bmModCwga3IpLCAobiArPSBtb2RUcnVuYyh0LCBrcikpIDwgMSA/IChlLS0sIG4gKz0ga3IpIDogbiA+IGtyICYmIChlKyssIFxuICBuIC09IGtyKSwgWyBlLCBuIF0pLFxuICB5ZWFyKGUpIHtcbiAgICByZXR1cm4gZS5pc29ZZWFyO1xuICB9LFxuICBtb250aChlKSB7XG4gICAgcmV0dXJuIGUuaXNvTW9udGg7XG4gIH0sXG4gIGRheTogZSA9PiBlLmlzb0RheVxufSksIEFpID0ge1xuICB2OiBjb21wdXRlSW50bERhdGVQYXJ0cyxcbiAgaG46IGNvbXB1dGVJbnRsRXJhUGFydHMsXG4gIHE6IGNvbXB1dGVJbnRsTW9udGhDb2RlUGFydHNcbn0sIHFpID0ge1xuICBkYXlPZlllYXI6IGNvbXB1dGVOYXRpdmVEYXlPZlllYXIsXG4gIHY6IGNvbXB1dGVJbnRsRGF0ZVBhcnRzLFxuICBwOiBjb21wdXRlSW50bEVwb2NoTWlsbGksXG4gIHdlZWtPZlllYXI6IGNvbXB1dGVOYXRpdmVXZWVrT2ZZZWFyLFxuICB5ZWFyT2ZXZWVrOiBjb21wdXRlTmF0aXZlWWVhck9mV2VlayxcbiAgbSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn0sIFdpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBZaSwgcWksIHtcbiAgdjogY29tcHV0ZUludGxEYXRlUGFydHMsXG4gIGhuOiBjb21wdXRlSW50bEVyYVBhcnRzLFxuICBxOiBjb21wdXRlSW50bE1vbnRoQ29kZVBhcnRzLFxuICBHKGUsIG4sIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5pZCAmJiBcImNoaW5lc2VcIiA9PT0gY29tcHV0ZUNhbGVuZGFySWRCYXNlKHRoaXMuaWQpID8gKChlLCBuLCB0KSA9PiB7XG4gICAgICBpZiAobikge1xuICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTY1MTtcblxuICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTQ3IDogMTc2NTtcblxuICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTY2IDogMTk1NTtcblxuICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTYzIDogMTk0NDtcblxuICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTcxIDogMTk1MjtcblxuICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTYwIDogMTk0MTtcblxuICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTY4IDogMTkzODtcblxuICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTU3IDogMTcxODtcblxuICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAxODMyO1xuXG4gICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAxODcwO1xuXG4gICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAxODE0O1xuXG4gICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHJldHVybiAxODkwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMTk3MjtcbiAgICB9KShlLCBuLCB0KSA6IEJyO1xuICAgIGxldCBbciwgaSwgYV0gPSBjb21wdXRlSW50bERhdGVQYXJ0cy5jYWxsKHRoaXMsIHtcbiAgICAgIGlzb1llYXI6IG8sXG4gICAgICBpc29Nb250aDoga3IsXG4gICAgICBpc29EYXk6IDMxXG4gICAgfSk7XG4gICAgY29uc3QgcyA9IGNvbXB1dGVJbnRsTGVhcE1vbnRoLmNhbGwodGhpcywgciksIGMgPSBpID09PSBzO1xuICAgIDEgPT09IChjb21wYXJlTnVtYmVycyhlLCBtb250aFRvTW9udGhDb2RlTnVtYmVyKGksIHMpKSB8fCBjb21wYXJlTnVtYmVycyhOdW1iZXIobiksIE51bWJlcihjKSkgfHwgY29tcGFyZU51bWJlcnModCwgYSkpICYmIHItLTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IDEwMDsgbysrKSB7XG4gICAgICBjb25zdCBpID0gciAtIG8sIGEgPSBjb21wdXRlSW50bExlYXBNb250aC5jYWxsKHRoaXMsIGkpLCBzID0gbW9udGhDb2RlTnVtYmVyVG9Nb250aChlLCBuLCBhKTtcbiAgICAgIGlmIChuID09PSAocyA9PT0gYSkgJiYgdCA8PSBjb21wdXRlSW50bERheXNJbk1vbnRoLmNhbGwodGhpcywgaSwgcykpIHtcbiAgICAgICAgcmV0dXJuIFsgaSwgcyBdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc24oZSkge1xuICAgIGNvbnN0IG4gPSBjb21wdXRlSW50bERheXNJblllYXIuY2FsbCh0aGlzLCBlKTtcbiAgICByZXR1cm4gbiA+IGNvbXB1dGVJbnRsRGF5c0luWWVhci5jYWxsKHRoaXMsIGUgLSAxKSAmJiBuID4gY29tcHV0ZUludGxEYXlzSW5ZZWFyLmNhbGwodGhpcywgZSArIDEpO1xuICB9LFxuICBMOiBjb21wdXRlSW50bExlYXBNb250aCxcbiAgQjogY29tcHV0ZUludGxNb250aHNJblllYXIsXG4gIGNuKGUsIG4pIHtcbiAgICBjb25zdCB0ID0gbiArIGUsIG8gPSBNYXRoLnNpZ24oZSksIHIgPSBvIDwgMCA/IC0xIDogMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgZSA9IG47IGUgIT09IHQ7IGUgKz0gbykge1xuICAgICAgaSArPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIGUgKyByKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sXG4gIFU6IGNvbXB1dGVJbnRsRGF5c0luTW9udGgsXG4gIGZuOiBjb21wdXRlSW50bERheXNJblllYXIsXG4gIFYoZSwgbiwgdCkge1xuICAgIHJldHVybiBlcG9jaE1pbGxpVG9Jc28oY29tcHV0ZUludGxFcG9jaE1pbGxpLmNhbGwodGhpcywgZSwgbiwgdCkpO1xuICB9LFxuICBwOiBjb21wdXRlSW50bEVwb2NoTWlsbGksXG4gIHVuKGUsIG4sIHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgaWYgKG4gKz0gdCwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKElvKTtcbiAgICAgIH1cbiAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICBmb3IgKDtuIDwgMTsgKSB7XG4gICAgICAgICAgbiArPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIC0tZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBmb3IgKDtuID4gKHQgPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIGUpKTsgKSB7XG4gICAgICAgICAgbiAtPSB0LCBlKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsgZSwgbiBdO1xuICB9LFxuICB5ZWFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5oKGUpLnllYXI7XG4gIH0sXG4gIG1vbnRoKGUpIHtcbiAgICBjb25zdCB7eWVhcjogbiwgbzogdH0gPSB0aGlzLmgoZSksIHt1OiBvfSA9IHRoaXMubChuKTtcbiAgICByZXR1cm4gb1t0XSArIDE7XG4gIH0sXG4gIGRheShlKSB7XG4gICAgcmV0dXJuIHRoaXMuaChlKS5kYXk7XG4gIH1cbn0pLCBqaSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlTmF0aXZlT3BzQ3JlYXRvcihSaSwgQWkpLCBDID0gLypAX19QVVJFX18qLyBjcmVhdGVOYXRpdmVPcHNDcmVhdG9yKFVpLCBXaSksIExpID0ge1xuICAuLi57XG4gICAgZXJhOiB0b1N0cmluZ1ZpYVByaW1pdGl2ZSxcbiAgICBlcmFZZWFyOiB0b0ludGVnZXIsXG4gICAgeWVhcjogdG9JbnRlZ2VyLFxuICAgIG1vbnRoOiB0b1Bvc2l0aXZlSW50ZWdlcixcbiAgICBtb250aENvZGUoZSkge1xuICAgICAgY29uc3QgbiA9IHRvU3RyaW5nVmlhUHJpbWl0aXZlKGUpO1xuICAgICAgcmV0dXJuIHBhcnNlTW9udGhDb2RlKG4pLCBuO1xuICAgIH0sXG4gICAgZGF5OiB0b1Bvc2l0aXZlSW50ZWdlclxuICB9LFxuICAuLi4vKkBfX1BVUkVfXyovIHdvKE8sIHRvSW50ZWdlciksXG4gIC4uLi8qQF9fUFVSRV9fKi8gd28ocCwgdG9TdHJpY3RJbnRlZ2VyKSxcbiAgb2Zmc2V0KGUpIHtcbiAgICBjb25zdCBuID0gdG9TdHJpbmdWaWFQcmltaXRpdmUoZSk7XG4gICAgcmV0dXJuIHBhcnNlT2Zmc2V0TmFubyhuKSwgbjtcbiAgfVxufSwgeGkgPSAvKkBfX1BVUkVfXyovIFB0KHJlbWFwUHJvcHMsIE8sIHcpLCAkaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVtYXBQcm9wcywgdywgTyksIEhpID0gXCJudW1lcmljXCIsIEdpID0gWyBcInRpbWVab25lTmFtZVwiIF0sIFZpID0ge1xuICBtb250aDogSGksXG4gIGRheTogSGlcbn0sIF9pID0ge1xuICB5ZWFyOiBIaSxcbiAgbW9udGg6IEhpXG59LCBKaSA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmFzc2lnbih7fSwgX2ksIHtcbiAgZGF5OiBIaVxufSksIEtpID0ge1xuICBob3VyOiBIaSxcbiAgbWludXRlOiBIaSxcbiAgc2Vjb25kOiBIaVxufSwgUWkgPSAvKkBfX1BVUkVfXyovIE9iamVjdC5hc3NpZ24oe30sIEppLCBLaSksIFhpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBRaSwge1xuICB0aW1lWm9uZU5hbWU6IFwic2hvcnRcIlxufSksIGVhID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhfaSksIG5hID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhWaSksIHRhID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhKaSksIG9hID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhLaSksIHJhID0gWyBcImRhdGVTdHlsZVwiIF0sIGlhID0gLypAX19QVVJFX18qLyBlYS5jb25jYXQocmEpLCBhYSA9IC8qQF9fUFVSRV9fKi8gbmEuY29uY2F0KHJhKSwgc2EgPSAvKkBfX1BVUkVfXyovIHRhLmNvbmNhdChyYSwgWyBcIndlZWtkYXlcIiBdKSwgY2EgPSAvKkBfX1BVUkVfXyovIG9hLmNvbmNhdChbIFwiZGF5UGVyaW9kXCIsIFwidGltZVN0eWxlXCIsIFwiZnJhY3Rpb25hbFNlY29uZERpZ2l0c1wiIF0pLCB1YSA9IC8qQF9fUFVSRV9fKi8gc2EuY29uY2F0KGNhKSwgZmEgPSAvKkBfX1BVUkVfXyovIEdpLmNvbmNhdChjYSksIGxhID0gLypAX19QVVJFX18qLyBHaS5jb25jYXQoc2EpLCBkYSA9IC8qQF9fUFVSRV9fKi8gR2kuY29uY2F0KFsgXCJkYXlcIiwgXCJ3ZWVrZGF5XCIgXSwgY2EpLCBtYSA9IC8qQF9fUFVSRV9fKi8gR2kuY29uY2F0KFsgXCJ5ZWFyXCIsIFwid2Vla2RheVwiIF0sIGNhKSwgcGEgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZU9wdGlvbnNUcmFuc2Zvcm1lcih1YSwgUWkpLCBoYSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlT3B0aW9uc1RyYW5zZm9ybWVyKHVhLCBYaSksIGdhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIodWEsIFFpLCBHaSksIERhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoc2EsIEppLCBmYSksIFRhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoY2EsIEtpLCBsYSksIElhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoaWEsIF9pLCBkYSksIE1hID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoYWEsIFZpLCBtYSksIE5hID0ge30sIHlhID0gLypAX19QVVJFX18qLyBuZXcgZW4odm9pZCAwLCB7XG4gIGNhbGVuZGFyOiBsXG59KS5yZXNvbHZlZE9wdGlvbnMoKS5jYWxlbmRhciA9PT0gbCwgVSA9IFsgcGEsIEkgXSwgb3QgPSBbIGhhLCBJLCAwLCAoZSwgbikgPT4ge1xuICBjb25zdCB0ID0gZS50aW1lWm9uZTtcbiAgaWYgKG4gJiYgbi50aW1lWm9uZSAhPT0gdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1vKTtcbiAgfVxuICByZXR1cm4gdDtcbn0gXSwgWCA9IFsgZ2EsIGlzb1RvRXBvY2hNaWxsaSBdLCBfID0gWyBEYSwgaXNvVG9FcG9jaE1pbGxpIF0sIHR0ID0gWyBUYSwgZSA9PiBpc29UaW1lRmllbGRzVG9OYW5vKGUpIC8gUWUgXSwgZXQgPSBbIElhLCBpc29Ub0Vwb2NoTWlsbGksIHlhIF0sIG50ID0gWyBNYSwgaXNvVG9FcG9jaE1pbGxpLCB5YSBdO1xuXG5sZXQgdmE7XG5cbmV4cG9ydCB7IE4gYXMgRHVyYXRpb25CcmFuZGluZywgUmUgYXMgSW5zdGFudEJyYW5kaW5nLCBHIGFzIFBsYWluRGF0ZUJyYW5kaW5nLCB4IGFzIFBsYWluRGF0ZVRpbWVCcmFuZGluZywgcXQgYXMgUGxhaW5Nb250aERheUJyYW5kaW5nLCBmdCBhcyBQbGFpblRpbWVCcmFuZGluZywgVXQgYXMgUGxhaW5ZZWFyTW9udGhCcmFuZGluZywgZW4gYXMgUmF3RGF0ZVRpbWVGb3JtYXQsIHogYXMgWm9uZWREYXRlVGltZUJyYW5kaW5nLCBZIGFzIGFic0R1cmF0aW9uLCBFIGFzIGFkZER1cmF0aW9ucywgUHQgYXMgYmluZEFyZ3MsIEsgYXMgY29tcGFyZUR1cmF0aW9ucywgS2UgYXMgY29tcGFyZUluc3RhbnRzLCB0ZSBhcyBjb21wYXJlSXNvRGF0ZUZpZWxkcywgWXQgYXMgY29tcGFyZUlzb0RhdGVUaW1lRmllbGRzLCBEdCBhcyBjb21wYXJlSXNvVGltZUZpZWxkcywgQmUgYXMgY29tcGFyZVpvbmVkRGF0ZVRpbWVzLCBUZSBhcyBjb21wdXRlWm9uZWRIb3Vyc0luRGF5LCB2ZSBhcyBjb21wdXRlWm9uZWRTdGFydE9mRGF5LCBqIGFzIGNvbnN0cnVjdER1cmF0aW9uU2xvdHMsIHFlIGFzIGNvbnN0cnVjdEluc3RhbnRTbG90cywgdWUgYXMgY29uc3RydWN0UGxhaW5EYXRlU2xvdHMsIFp0IGFzIGNvbnN0cnVjdFBsYWluRGF0ZVRpbWVTbG90cywga3QgYXMgY29uc3RydWN0UGxhaW5Nb250aERheVNsb3RzLCB1dCBhcyBjb25zdHJ1Y3RQbGFpblRpbWVTbG90cywgUXQgYXMgY29uc3RydWN0UGxhaW5ZZWFyTW9udGhTbG90cywgeWUgYXMgY29uc3RydWN0Wm9uZWREYXRlVGltZVNsb3RzLCBPZSBhcyBjcmVhdGVEdXJhdGlvblNsb3RzLCBhbiBhcyBjcmVhdGVGb3JtYXRGb3JQcmVwLCBRIGFzIGNyZWF0ZUZvcm1hdFByZXBwZXIsIHQgYXMgY3JlYXRlR2V0dGVyRGVzY3JpcHRvcnMsIHhlIGFzIGNyZWF0ZUluc3RhbnRTbG90cywgciBhcyBjcmVhdGVOYW1lRGVzY3JpcHRvcnMsIEMgYXMgY3JlYXRlTmF0aXZlU3RhbmRhcmRPcHMsIFcgYXMgY3JlYXRlUGxhaW5EYXRlU2xvdHMsIGp0IGFzIGNyZWF0ZVBsYWluRGF0ZVRpbWVTbG90cywgU3QgYXMgY3JlYXRlUGxhaW5UaW1lU2xvdHMsIG4gYXMgY3JlYXRlUHJvcERlc2NyaXB0b3JzLCBvIGFzIGNyZWF0ZVN0cmluZ1RhZ0Rlc2NyaXB0b3JzLCBfZSBhcyBjcmVhdGVab25lZERhdGVUaW1lU2xvdHMsIF8gYXMgZGF0ZUNvbmZpZywgWCBhcyBkYXRlVGltZUNvbmZpZywgRWUgYXMgZGlmZkluc3RhbnRzLCBJdCBhcyBkaWZmUGxhaW5EYXRlVGltZXMsIG9lIGFzIGRpZmZQbGFpbkRhdGVzLCBpdCBhcyBkaWZmUGxhaW5UaW1lcywgenQgYXMgZGlmZlBsYWluWWVhck1vbnRoLCB3ZSBhcyBkaWZmWm9uZWREYXRlVGltZXMsIHAgYXMgZHVyYXRpb25GaWVsZE5hbWVzQXNjLCBBIGFzIGR1cmF0aW9uV2l0aEZpZWxkcywgJGUgYXMgZXBvY2hNaWxsaVRvSW5zdGFudCwgSGUgYXMgZXBvY2hOYW5vVG9JbnN0YW50LCBiIGFzIGZvcmJpZGRlblZhbHVlT2YsIGsgYXMgZm9ybWF0RHVyYXRpb25Jc28sIGtlIGFzIGZvcm1hdEluc3RhbnRJc28sIFNlIGFzIGZvcm1hdE9mZnNldE5hbm8sIGNlIGFzIGZvcm1hdFBsYWluRGF0ZUlzbywgRnQgYXMgZm9ybWF0UGxhaW5EYXRlVGltZUlzbywgSnQgYXMgZm9ybWF0UGxhaW5Nb250aERheUlzbywgY3QgYXMgZm9ybWF0UGxhaW5UaW1lSXNvLCBLdCBhcyBmb3JtYXRQbGFpblllYXJNb250aElzbywgRmUgYXMgZm9ybWF0Wm9uZWREYXRlVGltZUlzbywgWGUgYXMgZ2V0Q3VycmVudEVwb2NoTmFubywgdG4gYXMgZ2V0Q3VycmVudElzb0RhdGVUaW1lLCBVZSBhcyBnZXRDdXJyZW50VGltZVpvbmVJZCwgeSBhcyBnZXREdXJhdGlvbkJsYW5rLCBJIGFzIGdldEVwb2NoTWlsbGksIHYgYXMgZ2V0RXBvY2hOYW5vLCBVIGFzIGluc3RhbnRDb25maWcsIEplIGFzIGluc3RhbnRUb1pvbmVkRGF0ZVRpbWUsIFZlIGFzIGluc3RhbnRzRXF1YWwsIGkgYXMgaW52YWxpZEJhZywgYyBhcyBpbnZhbGlkQ2FsZW5kYXIsIGEgYXMgaW52YWxpZENhbGxpbmdDb250ZXh0LCBybiBhcyBpbnZhbGlkRm9ybWF0VHlwZSwgRiBhcyBpbnZhbGlkVGltZVpvbmUsIHMgYXMgaXNPYmplY3RMaWtlLCBsIGFzIGlzb0NhbGVuZGFySWQsIE50IGFzIGlzb1RpbWVGaWVsZERlZmF1bHRzLCB3IGFzIGlzb1RpbWVGaWVsZE5hbWVzQXNjLCBnIGFzIG1hcFByb3BOYW1lcywgZSBhcyBtYXBQcm9wcywgb24gYXMgbWVtb2l6ZSwgbG4gYXMgbWlzbWF0Y2hpbmdGb3JtYXRUeXBlcywgbnQgYXMgbW9udGhEYXlDb25maWcsIFllIGFzIG1vdmVJbnN0YW50LCBuZSBhcyBtb3ZlUGxhaW5EYXRlLCB3dCBhcyBtb3ZlUGxhaW5EYXRlVGltZSwgYXQgYXMgbW92ZVBsYWluVGltZSwgR3QgYXMgbW92ZVBsYWluWWVhck1vbnRoLCBwZSBhcyBtb3ZlWm9uZWREYXRlVGltZSwgUWUgYXMgbmFub0luTWlsbGksIEIgYXMgbmVnYXRlRHVyYXRpb24sIEdlIGFzIG51bWJlclRvQmlnTmFubywgZiBhcyBwYXJzZUNhbGVuZGFySWQsIFIgYXMgcGFyc2VEdXJhdGlvbiwgV2UgYXMgcGFyc2VJbnN0YW50LCBkZSBhcyBwYXJzZVBsYWluRGF0ZSwgQnQgYXMgcGFyc2VQbGFpbkRhdGVUaW1lLCB4dCBhcyBwYXJzZVBsYWluTW9udGhEYXksIGh0IGFzIHBhcnNlUGxhaW5UaW1lLCBfdCBhcyBwYXJzZVBsYWluWWVhck1vbnRoLCBIIGFzIHBhcnNlUmVsYXRpdmVUb1Nsb3RzLCBaIGFzIHBhcnNlVGltZVpvbmVJZCwgQWUgYXMgcGFyc2Vab25lZERhdGVUaW1lLCBidCBhcyBwbGFpbkRhdGVUaW1lVG9ab25lZERhdGVUaW1lLCBndCBhcyBwbGFpbkRhdGVUaW1lV2l0aEZpZWxkcywgT3QgYXMgcGxhaW5EYXRlVGltZVdpdGhQbGFpblRpbWUsIEN0IGFzIHBsYWluRGF0ZVRpbWVzRXF1YWwsIGllIGFzIHBsYWluRGF0ZVRvUGxhaW5EYXRlVGltZSwgc2UgYXMgcGxhaW5EYXRlVG9QbGFpbk1vbnRoRGF5LCBsZSBhcyBwbGFpbkRhdGVUb1BsYWluWWVhck1vbnRoLCBhZSBhcyBwbGFpbkRhdGVUb1pvbmVkRGF0ZVRpbWUsIGVlIGFzIHBsYWluRGF0ZVdpdGhGaWVsZHMsIHJlIGFzIHBsYWluRGF0ZXNFcXVhbCwgVnQgYXMgcGxhaW5Nb250aERheVRvUGxhaW5EYXRlLCBFdCBhcyBwbGFpbk1vbnRoRGF5V2l0aEZpZWxkcywgTHQgYXMgcGxhaW5Nb250aERheXNFcXVhbCwgcnQgYXMgcGxhaW5UaW1lV2l0aEZpZWxkcywgc3QgYXMgcGxhaW5UaW1lc0VxdWFsLCBIdCBhcyBwbGFpblllYXJNb250aFRvUGxhaW5EYXRlLCBXdCBhcyBwbGFpblllYXJNb250aFdpdGhGaWVsZHMsICR0IGFzIHBsYWluWWVhck1vbnRoc0VxdWFsLCBubiBhcyBwbHVja1Byb3BzLCBMIGFzIHF1ZXJ5TmF0aXZlVGltZVpvbmUsIE10IGFzIHJlZmluZUNhbGVuZGFySWQsIE1lIGFzIHJlZmluZURpcmVjdGlvbk9wdGlvbnMsIHEgYXMgcmVmaW5lRHVyYXRpb25CYWcsICQgYXMgcmVmaW5lTWF5YmVab25lZERhdGVUaW1lQmFnLCBtdCBhcyByZWZpbmVPdmVyZmxvd09wdGlvbnMsIG1lIGFzIHJlZmluZVBsYWluRGF0ZUJhZywgQXQgYXMgcmVmaW5lUGxhaW5EYXRlVGltZUJhZywgUnQgYXMgcmVmaW5lUGxhaW5Nb250aERheUJhZywgVHQgYXMgcmVmaW5lUGxhaW5UaW1lQmFnLCBYdCBhcyByZWZpbmVQbGFpblllYXJNb250aEJhZywgWmUgYXMgcmVmaW5lVGltZVpvbmVJZCwgTmUgYXMgcmVmaW5lWm9uZWREYXRlVGltZUJhZywgamUgYXMgcmVmaW5lWm9uZWRGaWVsZE9wdGlvbnMsIEQgYXMgcmVxdWlyZUJvb2xlYW4sIFQgYXMgcmVxdWlyZUludGVnZXIsIFMgYXMgcmVxdWlyZUludGVnZXJPclVuZGVmaW5lZCwgemUgYXMgcmVxdWlyZU51bWJlcklzSW50ZWdlciwgaCBhcyByZXF1aXJlUG9zaXRpdmVJbnRlZ2VyLCBQIGFzIHJlcXVpcmVQb3NpdGl2ZUludGVnZXJPclVuZGVmaW5lZCwgbSBhcyByZXF1aXJlU3RyaW5nLCBkIGFzIHJlcXVpcmVTdHJpbmdPclVuZGVmaW5lZCwgdSBhcyByZXNvbHZlQ2FsZW5kYXJJZCwgTSBhcyByZXNvbHZlVGltZVpvbmVJZCwgViBhcyByb3VuZER1cmF0aW9uLCBMZSBhcyByb3VuZEluc3RhbnQsIHZ0IGFzIHJvdW5kUGxhaW5EYXRlVGltZSwgbHQgYXMgcm91bmRQbGFpblRpbWUsIEllIGFzIHJvdW5kWm9uZWREYXRlVGltZSwgcHQgYXMgc2xvdHNXaXRoQ2FsZW5kYXJJZCwgUGUgYXMgc2xvdHNXaXRoVGltZVpvbmVJZCwgdHQgYXMgdGltZUNvbmZpZywgTyBhcyB0aW1lRmllbGROYW1lc0FzYywgSiBhcyB0b3RhbER1cmF0aW9uLCBldCBhcyB5ZWFyTW9udGhDb25maWcsIG90IGFzIHpvbmVkQ29uZmlnLCBiZSBhcyB6b25lZERhdGVUaW1lVG9JbnN0YW50LCBmZSBhcyB6b25lZERhdGVUaW1lVG9QbGFpbkRhdGUsIHl0IGFzIHpvbmVkRGF0ZVRpbWVUb1BsYWluRGF0ZVRpbWUsIGR0IGFzIHpvbmVkRGF0ZVRpbWVUb1BsYWluVGltZSwgRGUgYXMgem9uZWREYXRlVGltZVdpdGhGaWVsZHMsIGdlIGFzIHpvbmVkRGF0ZVRpbWVXaXRoUGxhaW5UaW1lLCBDZSBhcyB6b25lZERhdGVUaW1lc0VxdWFsLCBoZSBhcyB6b25lZEVwb2NoU2xvdHNUb0lzbyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/temporal-polyfill/chunks/internal.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/temporal-polyfill/global.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/temporal-polyfill/global.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/classApi.js */ \"(rsc)/./node_modules/temporal-polyfill/chunks/classApi.js\");\n/* harmony import */ var _chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/internal.js */ \"(rsc)/./node_modules/temporal-polyfill/chunks/internal.js\");\n\n\n\n\nObject.defineProperties(globalThis, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  Temporal: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.Temporal\n})), Object.defineProperties(Intl, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  DateTimeFormat: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.DateTimeFormat\n})), Object.defineProperties(Date.prototype, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  toTemporalInstant: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.toTemporalInstant\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvZ2xvYmFsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBcUc7O0FBRW5DOztBQUVsRSxvQ0FBb0MsMEVBQUM7QUFDckMsWUFBWSx5REFBRTtBQUNkLENBQUMsa0NBQWtDLDBFQUFDO0FBQ3BDLGtCQUFrQiwrREFBRTtBQUNwQixDQUFDLDRDQUE0QywwRUFBQztBQUM5QyxxQkFBcUIsa0VBQUU7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL25pa2l0YS9EZXNrdG9wL2ZvY3VzcGhlcmUvbm9kZV9tb2R1bGVzL3RlbXBvcmFsLXBvbHlmaWxsL2dsb2JhbC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVtcG9yYWwgYXMgWG4sIERhdGVUaW1lRm9ybWF0IGFzIF9uLCB0b1RlbXBvcmFsSW5zdGFudCBhcyBqYSB9IGZyb20gXCIuL2NodW5rcy9jbGFzc0FwaS5qc1wiO1xuXG5pbXBvcnQgeyBjcmVhdGVQcm9wRGVzY3JpcHRvcnMgYXMgbiB9IGZyb20gXCIuL2NodW5rcy9pbnRlcm5hbC5qc1wiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhnbG9iYWxUaGlzLCBuKHtcbiAgVGVtcG9yYWw6IFhuXG59KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEludGwsIG4oe1xuICBEYXRlVGltZUZvcm1hdDogX25cbn0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIG4oe1xuICB0b1RlbXBvcmFsSW5zdGFudDogamFcbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/temporal-polyfill/global.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/temporal-polyfill/chunks/classApi.js":
/*!***********************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/classApi.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DateTimeFormat: () => (/* binding */ _n),\n/* harmony export */   IntlExtended: () => (/* binding */ eo),\n/* harmony export */   Temporal: () => (/* binding */ Xn),\n/* harmony export */   toTemporalInstant: () => (/* binding */ toTemporalInstant)\n/* harmony export */ });\n/* harmony import */ var _internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./internal.js */ \"(ssr)/./node_modules/temporal-polyfill/chunks/internal.js\");\nfunction createSlotClass(i, l, s, c, u) {\n  function Class(...t) {\n    if (!(this instanceof Class)) {\n      throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n    }\n    un(this, l(...t));\n  }\n  function bindMethod(t, e) {\n    return Object.defineProperties((function(...e) {\n      return t.call(this, getSpecificSlots(this), ...e);\n    }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(e));\n  }\n  function getSpecificSlots(t) {\n    const e = cn(t);\n    if (!e || e.branding !== i) {\n      throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n    }\n    return e;\n  }\n  return Object.defineProperties(Class.prototype, {\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createGetterDescriptors)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)(bindMethod, s)),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)(bindMethod, c)),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal.\" + i)\n  }), Object.defineProperties(Class, {\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)(u),\n    ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(i)\n  }), [ Class, t => {\n    const e = Object.create(Class.prototype);\n    return un(e, t), e;\n  }, getSpecificSlots ];\n}\n\nfunction rejectInvalidBag(t) {\n  if (cn(t) || void 0 !== t.calendar || void 0 !== t.timeZone) {\n    throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidBag);\n  }\n  return t;\n}\n\nfunction getCalendarIdFromBag(t) {\n  return extractCalendarIdFromBag(t) || _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId;\n}\n\nfunction extractCalendarIdFromBag(t) {\n  const {calendar: e} = t;\n  if (void 0 !== e) {\n    return refineCalendarArg(e);\n  }\n}\n\nfunction refineCalendarArg(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const {calendar: e} = cn(t) || {};\n    if (!e) {\n      throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCalendar)(t));\n    }\n    return e;\n  }\n  return (t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.resolveCalendarId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseCalendarId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString)(t))))(t);\n}\n\nfunction createCalendarGetters(t) {\n  const e = {};\n  for (const n in t) {\n    e[n] = t => {\n      const {calendar: e} = t;\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(e)[n](t);\n    };\n  }\n  return e;\n}\n\nfunction neverValueOf() {\n  throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.forbiddenValueOf);\n}\n\nfunction refineTimeZoneArg(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const {timeZone: e} = cn(t) || {};\n    if (!e) {\n      throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidTimeZone)(t));\n    }\n    return e;\n  }\n  return (t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.resolveTimeZoneId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseTimeZoneId)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString)(t))))(t);\n}\n\nfunction toDurationSlots(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const e = cn(t);\n    return e && e.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.DurationBranding ? e : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineDurationBag)(t);\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseDuration)(t);\n}\n\nfunction refinePublicRelativeTo(t) {\n  if (void 0 !== t) {\n    if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n      const e = cn(t) || {};\n      switch (e.branding) {\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n        return e;\n\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n        return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(e);\n      }\n      const n = getCalendarIdFromBag(t);\n      return {\n        ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineMaybeZonedDateTimeBag)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(n), t),\n        calendar: n\n      };\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseRelativeToSlots)(t);\n  }\n}\n\nfunction toPlainTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)(n);\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainTimeBag)(t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainTime)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction optionalToPlainTimeFields(t) {\n  return void 0 === t ? void 0 : toPlainTimeSlots(t);\n}\n\nfunction toPlainDateTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateTimeSlots)({\n        ...n,\n        ..._internal_js__WEBPACK_IMPORTED_MODULE_0__.isoTimeFieldDefaults\n      });\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainDateTimeBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainDateTime)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainMonthDaySlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    if (n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainMonthDayBranding) {\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n    }\n    const o = extractCalendarIdFromBag(t);\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainMonthDayBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(o || _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId), !o, t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainMonthDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainYearMonthSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    return n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainYearMonthBranding ? ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n) : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainYearMonthBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toPlainDateSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t) || {};\n    switch (n.branding) {\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(n);\n\n     case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, n);\n    }\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refinePlainDateBag)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(getCalendarIdFromBag(t)), t, e);\n  }\n  const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parsePlainDate)(t);\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineOverflowOptions)(e), n;\n}\n\nfunction toZonedDateTimeSlots(t, e) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const n = cn(t);\n    if (n && n.branding === _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding) {\n      return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineZonedFieldOptions)(e), n;\n    }\n    const o = getCalendarIdFromBag(t);\n    return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineZonedDateTimeBag)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps)(o), o, t, e);\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseZonedDateTime)(t, e);\n}\n\nfunction adaptDateMethods(t) {\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapProps)((t => e => t(slotsToIso(e))), t);\n}\n\nfunction slotsToIso(t) {\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedEpochSlotsToIso)(t, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone);\n}\n\nfunction toInstantSlots(t) {\n  if ((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(t)) {\n    const e = cn(t);\n    if (e) {\n      switch (e.branding) {\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.InstantBranding:\n        return e;\n\n       case _internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding:\n        return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)(e.epochNanoseconds);\n      }\n    }\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.parseInstant)(t);\n}\n\nfunction toTemporalInstant() {\n  const t = Date.prototype.valueOf.call(this);\n  return Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.numberToBigNano)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.requireNumberIsInteger)(t), _internal_js__WEBPACK_IMPORTED_MODULE_0__.nanoInMilli)));\n}\n\nfunction createDateTimeFormatClass() {\n  function DateTimeFormatFunc(t, e) {\n    return new DateTimeFormatNew(t, e);\n  }\n  function DateTimeFormatNew(t, e = Object.create(null)) {\n    to.set(this, ((t, e) => {\n      const n = new _internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat(t, e), o = n.resolvedOptions(), r = o.locale, a = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.pluckProps)(Object.keys(e), o), i = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.memoize)(createFormatPrepperForBranding), prepFormat = (t, ...e) => {\n        if (t) {\n          if (2 !== e.length) {\n            throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n          }\n          for (const t of e) {\n            if (void 0 === t) {\n              throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n            }\n          }\n        }\n        t || void 0 !== e[0] || (e = []);\n        const o = e.map((t => cn(t) || Number(t)));\n        let l, s = 0;\n        for (const t of o) {\n          const e = \"object\" == typeof t ? t.branding : void 0;\n          if (s++ && e !== l) {\n            throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.mismatchingFormatTypes);\n          }\n          l = e;\n        }\n        return l ? i(l)(r, a, ...o) : [ n, ...o ];\n      };\n      return prepFormat.X = n, prepFormat;\n    })(t, e));\n  }\n  const t = _internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat.prototype, e = Object.getOwnPropertyDescriptors(t), n = Object.getOwnPropertyDescriptors(_internal_js__WEBPACK_IMPORTED_MODULE_0__.RawDateTimeFormat);\n  for (const t in e) {\n    const n = e[t], o = t.startsWith(\"format\") && createFormatMethod(t);\n    \"function\" == typeof n.value ? n.value = \"constructor\" === t ? DateTimeFormatFunc : o || createProxiedMethod(t) : o && (n.get = function() {\n      if (!to.has(this)) {\n        throw new TypeError(_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidCallingContext);\n      }\n      return (...t) => o.apply(this, t);\n    }, Object.defineProperties(n.get, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(`get ${t}`)));\n  }\n  return n.prototype.value = DateTimeFormatNew.prototype = Object.create({}, e), Object.defineProperties(DateTimeFormatFunc, n), \n  DateTimeFormatFunc;\n}\n\nfunction createFormatMethod(t) {\n  return Object.defineProperties((function(...e) {\n    const n = to.get(this), [o, ...r] = n(t.includes(\"Range\"), ...e);\n    return o[t](...r);\n  }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(t));\n}\n\nfunction createProxiedMethod(t) {\n  return Object.defineProperties((function(...e) {\n    return to.get(this).X[t](...e);\n  }), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNameDescriptors)(t));\n}\n\nfunction createFormatPrepperForBranding(t) {\n  const e = Cn[t];\n  if (!e) {\n    throw new TypeError((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.invalidFormatType)(t));\n  }\n  return (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(e, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.memoize)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatForPrep), 1);\n}\n\n\n\nconst sn = /*@__PURE__*/ new WeakMap, cn = /*@__PURE__*/ sn.get.bind(sn), un = /*@__PURE__*/ sn.set.bind(sn), fn = {\n  era: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireStringOrUndefined,\n  eraYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireIntegerOrUndefined,\n  year: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireInteger,\n  month: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  daysInMonth: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  daysInYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  inLeapYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireBoolean,\n  monthsInYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, mn = {\n  monthCode: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireString\n}, dn = {\n  day: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, Sn = {\n  dayOfWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  dayOfYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger,\n  weekOfYear: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveIntegerOrUndefined,\n  yearOfWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requireIntegerOrUndefined,\n  daysInWeek: _internal_js__WEBPACK_IMPORTED_MODULE_0__.requirePositiveInteger\n}, Tn = /*@__PURE__*/ createCalendarGetters(/*@__PURE__*/ Object.assign({}, fn, mn, dn, Sn)), hn = /*@__PURE__*/ createCalendarGetters({\n  ...fn,\n  ...mn\n}), Dn = /*@__PURE__*/ createCalendarGetters({\n  ...mn,\n  ...dn\n}), Pn = {\n  calendarId: t => t.calendar\n}, gn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapPropNames)((t => e => e[t]), _internal_js__WEBPACK_IMPORTED_MODULE_0__.durationFieldNamesAsc.concat(\"sign\")), pn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.mapPropNames)(((t, e) => t => t[_internal_js__WEBPACK_IMPORTED_MODULE_0__.isoTimeFieldNamesAsc[e]]), _internal_js__WEBPACK_IMPORTED_MODULE_0__.timeFieldNamesAsc), On = {\n  epochMilliseconds: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getEpochMilli,\n  epochNanoseconds: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getEpochNano\n}, [wn, In, vn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.DurationBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructDurationSlots, {\n  ...gn,\n  blank: _internal_js__WEBPACK_IMPORTED_MODULE_0__.getDurationBlank\n}, {\n  with: (t, e) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.durationWithFields)(t, e)),\n  negated: t => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.negateDuration)(t)),\n  abs: t => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.absDuration)(t)),\n  add: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.addDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.addDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toDurationSlots(e), n)),\n  round: (t, e) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundDuration)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e)),\n  total: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.totalDuration)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toLocaleString(t, e, n) {\n    return Intl.DurationFormat ? new Intl.DurationFormat(e, n).format(this) : (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso)(t);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatDurationIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: t => In(toDurationSlots(t)),\n  compare: (t, e, n) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareDurations)(refinePublicRelativeTo, _internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, toDurationSlots(t), toDurationSlots(e), n)\n}), Cn = {\n  Instant: _internal_js__WEBPACK_IMPORTED_MODULE_0__.instantConfig,\n  PlainDateTime: _internal_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeConfig,\n  PlainDate: _internal_js__WEBPACK_IMPORTED_MODULE_0__.dateConfig,\n  PlainTime: _internal_js__WEBPACK_IMPORTED_MODULE_0__.timeConfig,\n  PlainYearMonth: _internal_js__WEBPACK_IMPORTED_MODULE_0__.yearMonthConfig,\n  PlainMonthDay: _internal_js__WEBPACK_IMPORTED_MODULE_0__.monthDayConfig\n}, bn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantConfig), Fn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedConfig), Mn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.dateTimeConfig), Zn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.dateConfig), yn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.timeConfig), jn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.yearMonthConfig), Nn = /*@__PURE__*/ (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createFormatPrepper)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.monthDayConfig), [An, Bn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainTimeBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainTimeSlots, pn, {\n  with(t, e, n) {\n    return Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainTimeWithFields)(this, rejectInvalidBag(e), n));\n  },\n  add: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainTime)(0, t, toDurationSlots(e))),\n  subtract: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainTime)(1, t, toDurationSlots(e))),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainTimes)(0, t, toPlainTimeSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainTimes)(1, t, toPlainTimeSlots(e), n)),\n  round: (t, e) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundPlainTime)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainTimesEqual)(t, toPlainTimeSlots(e)),\n  toLocaleString(t, e, n) {\n    const [o, r] = yn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainTimeIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainTimeIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Bn(toPlainTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoTimeFields)(toPlainTimeSlots(t), toPlainTimeSlots(e))\n}), [Yn, En] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateTimeBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainDateTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Tn,\n  ...pn\n}, {\n  with: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  withPlainTime: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeWithPlainTime)(t, optionalToPlainTimeFields(e))),\n  add: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainDateTimeSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainDateTimeSlots(e), n)),\n  round: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundPlainDateTime)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimesEqual)(t, toPlainDateTimeSlots(e)),\n  toZonedDateTime: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateTimeToZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, refineTimeZoneArg(e), n)),\n  toPlainDate: t => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)(t)),\n  toPlainTime: t => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)(t)),\n  toLocaleString(t, e, n) {\n    const [o, r] = Mn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateTimeIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateTimeIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => En(toPlainDateTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateTimeFields)(toPlainDateTimeSlots(t), toPlainDateTimeSlots(e))\n}), [Ln, Vn, Jn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainMonthDayBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainMonthDaySlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Dn\n}, {\n  with: (t, e, n) => Vn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDayWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDaysEqual)(t, toPlainMonthDaySlots(e)),\n  toPlainDate(t, e) {\n    return Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainMonthDayToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this, e));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = Nn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainMonthDayIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainMonthDayIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Vn(toPlainMonthDaySlots(t, e))\n}), [kn, qn, Rn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainYearMonthBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainYearMonthSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...hn\n}, {\n  with: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  add: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainYearMonthSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainYearMonthSlots(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthsEqual)(t, toPlainYearMonthSlots(e)),\n  toPlainDate(t, e) {\n    return Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainYearMonthToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this, e));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = jn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainYearMonthIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainYearMonthIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => qn(toPlainYearMonthSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateFields)(toPlainYearMonthSlots(t), toPlainYearMonthSlots(e))\n}), [xn, Wn, Gn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.PlainDateBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructPlainDateSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId), {\n  ...Pn,\n  ...Tn\n}, {\n  with: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  add: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.movePlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDates)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 0, t, toPlainDateSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffPlainDates)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, 1, t, toPlainDateSlots(e), n)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDatesEqual)(t, toPlainDateSlots(e)),\n  toZonedDateTime(t, e) {\n    const n = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.isObjectLike)(e) ? e : {\n      timeZone: e\n    };\n    return $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToZonedDateTime)(refineTimeZoneArg, toPlainTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, n));\n  },\n  toPlainDateTime: (t, e) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainDateTime)(t, optionalToPlainTimeFields(e))),\n  toPlainYearMonth(t) {\n    return qn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainYearMonth)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this));\n  },\n  toPlainMonthDay(t) {\n    return Vn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.plainDateToPlainMonthDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, t, this));\n  },\n  toLocaleString(t, e, n) {\n    const [o, r] = Zn(e, n, t);\n    return o.format(r);\n  },\n  toString: _internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateIso,\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatPlainDateIso)(t),\n  valueOf: neverValueOf\n}, {\n  from: (t, e) => Wn(toPlainDateSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareIsoDateFields)(toPlainDateSlots(t), toPlainDateSlots(e))\n}), [zn, $n] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.ZonedDateTimeBranding, (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.bindArgs)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.constructZonedDateTimeSlots, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineCalendarId, _internal_js__WEBPACK_IMPORTED_MODULE_0__.refineTimeZoneId), {\n  ...On,\n  ...Pn,\n  ...adaptDateMethods(Tn),\n  ...adaptDateMethods(pn),\n  offset: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatOffsetNano)(slotsToIso(t).offsetNanoseconds),\n  offsetNanoseconds: t => slotsToIso(t).offsetNanoseconds,\n  timeZoneId: t => t.timeZone,\n  hoursInDay: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.computeZonedHoursInDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)\n}, {\n  with: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeWithFields)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, rejectInvalidBag(e), n)),\n  withCalendar: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithCalendarId)(t, refineCalendarArg(e))),\n  withTimeZone: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.slotsWithTimeZoneId)(t, refineTimeZoneArg(e))),\n  withPlainTime: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeWithPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, optionalToPlainTimeFields(e))),\n  add: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toDurationSlots(e), n)),\n  subtract: (t, e, n) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toDurationSlots(e), n)),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createDurationSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffZonedDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 0, t, toZonedDateTimeSlots(e), n))),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createDurationSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffZonedDateTimes)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.createNativeStandardOps, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, 1, t, toZonedDateTimeSlots(e), n))),\n  round: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundZonedDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e)),\n  startOfDay: t => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.computeZonedStartOfDay)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimesEqual)(t, toZonedDateTimeSlots(e)),\n  toInstant: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToInstant)(t)),\n  toPlainDateTime: t => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDateTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toPlainDate: t => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainDate)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toPlainTime: t => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.zonedDateTimeToPlainTime)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t)),\n  toLocaleString(t, e, n = {}) {\n    const [o, r] = Fn(e, n, t);\n    return o.format(r);\n  },\n  toString: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatZonedDateTimeIso)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatZonedDateTimeIso)(_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t),\n  valueOf: neverValueOf,\n  getTimeZoneTransition(t, e) {\n    const {timeZone: n, epochNanoseconds: o} = t, r = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.refineDirectionOptions)(e), a = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(n).O(o, r);\n    return a ? $n({\n      ...t,\n      epochNanoseconds: a\n    }) : null;\n  }\n}, {\n  from: (t, e) => $n(toZonedDateTimeSlots(t, e)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareZonedDateTimes)(toZonedDateTimeSlots(t), toZonedDateTimeSlots(e))\n}), [Hn, Kn, Qn] = createSlotClass(_internal_js__WEBPACK_IMPORTED_MODULE_0__.InstantBranding, _internal_js__WEBPACK_IMPORTED_MODULE_0__.constructInstantSlots, On, {\n  add: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveInstant)(0, t, toDurationSlots(e))),\n  subtract: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.moveInstant)(1, t, toDurationSlots(e))),\n  until: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffInstants)(0, t, toInstantSlots(e), n)),\n  since: (t, e, n) => In((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.diffInstants)(1, t, toInstantSlots(e), n)),\n  round: (t, e) => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.roundInstant)(t, e)),\n  equals: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantsEqual)(t, toInstantSlots(e)),\n  toZonedDateTimeISO: (t, e) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.instantToZonedDateTime)(t, refineTimeZoneArg(e))),\n  toLocaleString(t, e, n) {\n    const [o, r] = bn(e, n, t);\n    return o.format(r);\n  },\n  toString: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatInstantIso)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t, e),\n  toJSON: t => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.formatInstantIso)(refineTimeZoneArg, _internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone, t),\n  valueOf: neverValueOf\n}, {\n  from: t => Kn(toInstantSlots(t)),\n  fromEpochMilliseconds: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.epochMilliToInstant)(t)),\n  fromEpochNanoseconds: t => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.epochNanoToInstant)(t)),\n  compare: (t, e) => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.compareInstants)(toInstantSlots(t), toInstantSlots(e))\n}), Un = /*@__PURE__*/ Object.defineProperties({}, {\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal.Now\"),\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n    timeZoneId: () => (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)(),\n    instant: () => Kn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createInstantSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentEpochNano)())),\n    zonedDateTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => $n((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createZonedDateTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentEpochNano)(), refineTimeZoneArg(t), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainDateTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => En((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t))), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainDateISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => Wn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainDateSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t))), _internal_js__WEBPACK_IMPORTED_MODULE_0__.isoCalendarId)),\n    plainTimeISO: (t = (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentTimeZoneId)()) => Bn((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPlainTimeSlots)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.getCurrentIsoDateTime)((0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.queryNativeTimeZone)(refineTimeZoneArg(t)))))\n  })\n}), Xn = /*@__PURE__*/ Object.defineProperties({}, {\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createStringTagDescriptors)(\"Temporal\"),\n  ...(0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n    PlainYearMonth: kn,\n    PlainMonthDay: Ln,\n    PlainDate: xn,\n    PlainTime: An,\n    PlainDateTime: Yn,\n    ZonedDateTime: zn,\n    Instant: Hn,\n    Duration: wn,\n    Now: Un\n  })\n}), _n = /*@__PURE__*/ createDateTimeFormatClass(), to = /*@__PURE__*/ new WeakMap, eo = /*@__PURE__*/ Object.defineProperties(Object.create(Intl), (0,_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  DateTimeFormat: _n\n}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvY2h1bmtzL2NsYXNzQXBpLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRyxtRUFBQztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLCtEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTyxxRUFBQyxDQUFDLHNEQUFDO0FBQ1YsT0FBTyxtRUFBQyxDQUFDLHNEQUFDO0FBQ1YsT0FBTyx3RUFBQztBQUNSLEdBQUc7QUFDSCxPQUFPLG1FQUFDO0FBQ1IsT0FBTyxtRUFBQztBQUNSLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQSx3QkFBd0Isb0RBQUM7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0NBQXdDLHVEQUFDO0FBQ3pDOztBQUVBO0FBQ0EsU0FBUyxhQUFhO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQLFdBQVcsYUFBYTtBQUN4QjtBQUNBLDBCQUEwQiw2REFBQztBQUMzQjtBQUNBO0FBQ0E7QUFDQSxlQUFlLCtEQUFDLENBQUMsNkRBQUMsQ0FBQywyREFBQztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsYUFBYTtBQUMxQixhQUFhLHFFQUFDO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzQkFBc0IsMERBQUM7QUFDdkI7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1AsV0FBVyxhQUFhO0FBQ3hCO0FBQ0EsMEJBQTBCLDZEQUFDO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQUMsQ0FBQyw2REFBQyxDQUFDLDJEQUFDO0FBQ3BCOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQO0FBQ0EsK0JBQStCLDBEQUFDLE9BQU8sK0RBQUM7QUFDeEM7QUFDQSxTQUFTLDJEQUFDO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBLFFBQVEsMERBQUM7QUFDVDtBQUNBO0FBQ0EsWUFBWSwrREFBQztBQUNiLFlBQVksMkRBQUM7QUFDYjs7QUFFQSxZQUFZLCtEQUFDO0FBQ2IsZUFBZSxrRUFBQztBQUNoQjtBQUNBO0FBQ0E7QUFDQSxXQUFXLHlFQUFDLG9CQUFvQiw2REFBQyxFQUFFLHFFQUFDO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLFdBQVcsa0VBQUM7QUFDWjtBQUNBOztBQUVBO0FBQ0EsTUFBTSwwREFBQztBQUNQO0FBQ0E7QUFDQSxVQUFVLDJEQUFFO0FBQ1osYUFBYSxtRUFBRTs7QUFFZixVQUFVLCtEQUFDO0FBQ1gsYUFBYSxtRUFBRSxLQUFLLGtFQUFFOztBQUV0QixVQUFVLCtEQUFDO0FBQ1gsYUFBYSxtRUFBRSxLQUFLLHNFQUFFLENBQUMsNkRBQUM7QUFDeEI7QUFDQSxXQUFXLGdFQUFFO0FBQ2I7QUFDQSxZQUFZLDREQUFFO0FBQ2QsU0FBUyxtRUFBRTtBQUNYOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBO0FBQ0EsVUFBVSwrREFBQztBQUNYLGFBQWEsbUVBQUU7O0FBRWYsVUFBVSwyREFBQztBQUNYLGFBQWEsbUVBQUUsS0FBSyxzRUFBRTtBQUN0QjtBQUNBLFdBQVcsOERBQUU7QUFDYixPQUFPOztBQUVQLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssMEVBQUUsQ0FBQyw2REFBQztBQUN4QjtBQUNBLFdBQVcsb0VBQUUsQ0FBQyxxRUFBQztBQUNmO0FBQ0EsWUFBWSxnRUFBRTtBQUNkLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLDRCQUE0QiwrREFBRTtBQUM5QixhQUFhLG1FQUFFO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsb0VBQUUsQ0FBQyxxRUFBQyxNQUFNLHVEQUFDO0FBQ3RCO0FBQ0EsWUFBWSxnRUFBRSxDQUFDLGlFQUFDO0FBQ2hCLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLCtCQUErQixnRUFBRSxJQUFJLG1FQUFFLFVBQVUscUVBQUUsQ0FBQyxxRUFBQztBQUNyRDtBQUNBLFlBQVksaUVBQUUsQ0FBQyxpRUFBQztBQUNoQixTQUFTLG1FQUFFO0FBQ1g7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1A7QUFDQTtBQUNBLFVBQVUsMkRBQUM7QUFDWCxhQUFhLG1FQUFFOztBQUVmLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssa0VBQUM7O0FBRXJCLFVBQVUsK0RBQUM7QUFDWCxhQUFhLG1FQUFFLEtBQUssc0VBQUUsQ0FBQyw2REFBQztBQUN4QjtBQUNBLFdBQVcsZ0VBQUUsQ0FBQyxxRUFBQztBQUNmO0FBQ0EsWUFBWSw0REFBRTtBQUNkLFNBQVMsbUVBQUU7QUFDWDs7QUFFQTtBQUNBLE1BQU0sMERBQUM7QUFDUDtBQUNBLDRCQUE0QiwrREFBQztBQUM3QixhQUFhLHFFQUFFO0FBQ2Y7QUFDQTtBQUNBLFdBQVcsb0VBQUUsb0JBQW9CLDZEQUFDLEVBQUUscUVBQUM7QUFDckM7QUFDQSxTQUFTLGdFQUFFO0FBQ1g7O0FBRUE7QUFDQSxTQUFTLHNEQUFDO0FBQ1Y7O0FBRUE7QUFDQSxTQUFTLGtFQUFFLElBQUksNkRBQUM7QUFDaEI7O0FBRUE7QUFDQSxNQUFNLDBEQUFDO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsWUFBWSx5REFBRTtBQUNkOztBQUVBLFlBQVksK0RBQUM7QUFDYixlQUFlLGdFQUFFO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLFNBQVMsMERBQUU7QUFDWDs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxnRUFBRSxDQUFDLDZEQUFFLENBQUMsb0VBQUUsS0FBSyxxREFBRTtBQUMzQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsMkRBQUUsbURBQW1ELHdEQUFFLHlCQUF5QixxREFBRTtBQUN0RztBQUNBO0FBQ0EsZ0NBQWdDLGdFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxnRUFBRTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0VBQUU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsWUFBWSwyREFBRSwwRkFBMEYsMkRBQUU7QUFDMUc7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQUM7QUFDN0I7QUFDQTtBQUNBLEtBQUssaUNBQWlDLG1FQUFDLFFBQVEsRUFBRTtBQUNqRDtBQUNBLDJFQUEyRTtBQUMzRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHLG1FQUFDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRyxHQUFHLG1FQUFDO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLCtEQUFFO0FBQzFCO0FBQ0EsU0FBUyxpRUFBQyxJQUFJLHFEQUFFLENBQUMsNkRBQUU7QUFDbkI7O0FBRWczSTs7QUFFaDNJO0FBQ0EsT0FBTyxrRUFBQztBQUNSLFdBQVcsbUVBQUM7QUFDWixRQUFRLHdEQUFDO0FBQ1QsU0FBUyxnRUFBQztBQUNWLGVBQWUsZ0VBQUM7QUFDaEIsY0FBYyxnRUFBQztBQUNmLGNBQWMsd0RBQUM7QUFDZixnQkFBZ0IsZ0VBQUM7QUFDakIsQ0FBQztBQUNELGFBQWEsdURBQUM7QUFDZCxDQUFDO0FBQ0QsT0FBTyxnRUFBQztBQUNSLENBQUM7QUFDRCxhQUFhLGdFQUFDO0FBQ2QsYUFBYSxnRUFBQztBQUNkLGNBQWMsMkVBQUM7QUFDZixjQUFjLG1FQUFDO0FBQ2YsY0FBYyxnRUFBQztBQUNmLENBQUMseUVBQXlFO0FBQzFFO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLENBQUMscUJBQXFCLDBEQUFDLG1CQUFtQiwrREFBQyxxQ0FBcUMsMERBQUMsbUJBQW1CLDhEQUFDLE9BQU8sMkRBQUM7QUFDN0cscUJBQXFCLHVEQUFDO0FBQ3RCLG9CQUFvQixzREFBQztBQUNyQixDQUFDLGlDQUFpQywwREFBQyxFQUFFLGdFQUFDO0FBQ3RDO0FBQ0EsU0FBUywwREFBQztBQUNWLENBQUM7QUFDRCxxQkFBcUIsZ0VBQUM7QUFDdEIsbUJBQW1CLDREQUFDO0FBQ3BCLGVBQWUseURBQUM7QUFDaEIsdUJBQXVCLDBEQUFDLHlCQUF5QixpRUFBQyxFQUFFLDZEQUFDO0FBQ3JELDRCQUE0QiwwREFBQyx5QkFBeUIsaUVBQUMsRUFBRSw2REFBQztBQUMxRCxzQkFBc0IsMkRBQUMseUJBQXlCLGlFQUFDLEVBQUUsNkRBQUM7QUFDcEQsbUJBQW1CLDJEQUFDLHlCQUF5QixpRUFBQyxFQUFFLDZEQUFDO0FBQ2pEO0FBQ0EsOEVBQThFLCtEQUFDO0FBQy9FLEdBQUc7QUFDSCxZQUFZLDJEQUFDO0FBQ2IsZUFBZSwrREFBQztBQUNoQjtBQUNBLENBQUM7QUFDRDtBQUNBLHdCQUF3Qiw4REFBQyx5QkFBeUIsaUVBQUMsRUFBRSw2REFBQztBQUN0RCxDQUFDO0FBQ0QsV0FBVyx1REFBQztBQUNaLGlCQUFpQix3REFBQztBQUNsQixhQUFhLG9EQUFDO0FBQ2QsYUFBYSxvREFBRTtBQUNmLGtCQUFrQix5REFBRTtBQUNwQixpQkFBaUIsd0RBQUU7QUFDbkIsQ0FBQyxxQkFBcUIsaUVBQUMsQ0FBQyx1REFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxxREFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx3REFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxvREFBQyxzQkFBc0IsaUVBQUMsQ0FBQyxvREFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx5REFBRSxzQkFBc0IsaUVBQUMsQ0FBQyx3REFBRSw4QkFBOEIsMkRBQUUsRUFBRSxpRUFBRTtBQUN2TjtBQUNBLGNBQWMsaUVBQUU7QUFDaEIsR0FBRztBQUNILG9CQUFvQiwyREFBRTtBQUN0Qix5QkFBeUIsMkRBQUU7QUFDM0IseUJBQXlCLDREQUFFO0FBQzNCLHlCQUF5Qiw0REFBRTtBQUMzQixzQkFBc0IsNERBQUU7QUFDeEIsb0JBQW9CLDZEQUFFO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFFO0FBQ2QsZUFBZSxnRUFBRTtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixrRUFBRTtBQUN2QixDQUFDLDhCQUE4QiwrREFBQyxFQUFFLHNEQUFFLENBQUMscUVBQUUsRUFBRSwwREFBRTtBQUMzQztBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLHFFQUFFLENBQUMsaUVBQUM7QUFDNUIsNkJBQTZCLGlFQUFFO0FBQy9CLDhCQUE4Qix3RUFBRTtBQUNoQyx1QkFBdUIsK0RBQUUsQ0FBQyxpRUFBQztBQUMzQiw0QkFBNEIsK0RBQUUsQ0FBQyxpRUFBQztBQUNoQyx5QkFBeUIsZ0VBQUUsQ0FBQyxpRUFBQztBQUM3Qix5QkFBeUIsZ0VBQUUsQ0FBQyxpRUFBQztBQUM3QixzQkFBc0IsZ0VBQUU7QUFDeEIsb0JBQW9CLGlFQUFFO0FBQ3RCLG1DQUFtQywwRUFBRSxDQUFDLDZEQUFDO0FBQ3ZDLHVCQUF1QixrRUFBQztBQUN4Qix1QkFBdUIsa0VBQUU7QUFDekI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksZ0VBQUU7QUFDZCxlQUFlLG9FQUFFO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLHNFQUFFO0FBQ3ZCLENBQUMsa0NBQWtDLCtEQUFFLEVBQUUsc0RBQUUsQ0FBQyxxRUFBRSxFQUFFLDBEQUFFO0FBQ2hEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLHFFQUFFLENBQUMsaUVBQUM7QUFDNUIsb0JBQW9CLGlFQUFFO0FBQ3RCO0FBQ0EsY0FBYyxzRUFBRSxDQUFDLGlFQUFDO0FBQ2xCLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsWUFBWSxnRUFBRTtBQUNkLGVBQWUsb0VBQUU7QUFDakI7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxDQUFDLGtDQUFrQyxnRUFBRSxFQUFFLHNEQUFFLENBQUMsc0VBQUUsRUFBRSwwREFBRTtBQUNoRDtBQUNBO0FBQ0EsQ0FBQztBQUNELHdCQUF3QixzRUFBRSxDQUFDLGlFQUFDO0FBQzVCLHVCQUF1QixnRUFBRSxDQUFDLGlFQUFDO0FBQzNCLDRCQUE0QixnRUFBRSxDQUFDLGlFQUFDO0FBQ2hDLHlCQUF5QixnRUFBRSxDQUFDLGlFQUFDO0FBQzdCLHlCQUF5QixnRUFBRSxDQUFDLGlFQUFDO0FBQzdCLG9CQUFvQixrRUFBRTtBQUN0QjtBQUNBLGNBQWMsdUVBQUUsQ0FBQyxpRUFBQztBQUNsQixHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILFlBQVksaUVBQUU7QUFDZCxlQUFlLHFFQUFFO0FBQ2pCO0FBQ0EsQ0FBQztBQUNEO0FBQ0EscUJBQXFCLGtFQUFFO0FBQ3ZCLENBQUMsa0NBQWtDLDJEQUFDLEVBQUUsc0RBQUUsQ0FBQyxpRUFBRSxFQUFFLDBEQUFFO0FBQy9DO0FBQ0E7QUFDQSxDQUFDO0FBQ0Qsd0JBQXdCLGlFQUFFLENBQUMsaUVBQUM7QUFDNUIsNkJBQTZCLGlFQUFFO0FBQy9CLHVCQUF1QiwyREFBRSxDQUFDLGlFQUFDO0FBQzNCLDRCQUE0QiwyREFBRSxDQUFDLGlFQUFDO0FBQ2hDLHlCQUF5Qiw0REFBRSxDQUFDLGlFQUFDO0FBQzdCLHlCQUF5Qiw0REFBRSxDQUFDLGlFQUFDO0FBQzdCLG9CQUFvQiw2REFBRTtBQUN0QjtBQUNBLGNBQWMsMERBQUM7QUFDZjtBQUNBO0FBQ0EsY0FBYyxzRUFBRSxzQ0FBc0MsNkRBQUM7QUFDdkQsR0FBRztBQUNILGdDQUFnQyxzRUFBRTtBQUNsQztBQUNBLGNBQWMsdUVBQUUsQ0FBQyxpRUFBQztBQUNsQixHQUFHO0FBQ0g7QUFDQSxjQUFjLHNFQUFFLENBQUMsaUVBQUM7QUFDbEIsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLDREQUFFO0FBQ2QsZUFBZSxnRUFBRTtBQUNqQjtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixrRUFBRTtBQUN2QixDQUFDLDhCQUE4QiwrREFBQyxFQUFFLHNEQUFFLENBQUMscUVBQUUsRUFBRSwwREFBRSxFQUFFLDBEQUFFO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSw4REFBRTtBQUNqQjtBQUNBO0FBQ0EsbUJBQW1CLG9FQUFFLENBQUMsNkRBQUM7QUFDdkIsQ0FBQztBQUNELHdCQUF3QixxRUFBRSxDQUFDLGlFQUFDLEVBQUUsNkRBQUM7QUFDL0IsNkJBQTZCLGlFQUFFO0FBQy9CLDZCQUE2QixpRUFBRTtBQUMvQiw4QkFBOEIsd0VBQUUsQ0FBQyw2REFBQztBQUNsQyx1QkFBdUIsK0RBQUUsQ0FBQyxpRUFBQyxFQUFFLDZEQUFDO0FBQzlCLDRCQUE0QiwrREFBRSxDQUFDLGlFQUFDLEVBQUUsNkRBQUM7QUFDbkMseUJBQXlCLGlFQUFFLENBQUMsZ0VBQUUsQ0FBQyxpRUFBQyxFQUFFLDZEQUFDO0FBQ25DLHlCQUF5QixpRUFBRSxDQUFDLGdFQUFFLENBQUMsaUVBQUMsRUFBRSw2REFBQztBQUNuQyxzQkFBc0IsZ0VBQUUsQ0FBQyw2REFBQztBQUMxQixzQkFBc0Isb0VBQUUsQ0FBQyw2REFBQztBQUMxQixvQkFBb0IsaUVBQUU7QUFDdEIscUJBQXFCLG9FQUFFO0FBQ3ZCLDJCQUEyQiwwRUFBRSxDQUFDLDZEQUFDO0FBQy9CLHVCQUF1QixzRUFBRSxDQUFDLDZEQUFDO0FBQzNCLHVCQUF1QixzRUFBRSxDQUFDLDZEQUFDO0FBQzNCLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsR0FBRztBQUNILHNCQUFzQixvRUFBRSxDQUFDLDZEQUFDO0FBQzFCLGVBQWUsb0VBQUUsQ0FBQyw2REFBQztBQUNuQjtBQUNBO0FBQ0EsV0FBVyxrQ0FBa0MsU0FBUyxvRUFBRSxTQUFTLGlFQUFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLENBQUM7QUFDRDtBQUNBLHFCQUFxQixtRUFBRTtBQUN2QixDQUFDLGtDQUFrQyx5REFBRSxFQUFFLCtEQUFFO0FBQ3pDLG9CQUFvQix5REFBRTtBQUN0Qix5QkFBeUIseURBQUU7QUFDM0IseUJBQXlCLDBEQUFFO0FBQzNCLHlCQUF5QiwwREFBRTtBQUMzQixzQkFBc0IsMERBQUU7QUFDeEIsb0JBQW9CLDJEQUFFO0FBQ3RCLG1DQUFtQyxvRUFBRTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsc0JBQXNCLDhEQUFFLG9CQUFvQiw2REFBQztBQUM3QyxlQUFlLDhEQUFFLG9CQUFvQiw2REFBQztBQUN0QztBQUNBLENBQUM7QUFDRDtBQUNBLGlDQUFpQyxpRUFBRTtBQUNuQyxnQ0FBZ0MsZ0VBQUU7QUFDbEMscUJBQXFCLDZEQUFFO0FBQ3ZCLENBQUMsZ0RBQWdEO0FBQ2pELEtBQUssd0VBQUM7QUFDTixLQUFLLG1FQUFDO0FBQ04sc0JBQXNCLGtFQUFFO0FBQ3hCLHNCQUFzQixnRUFBRSxDQUFDLGlFQUFFO0FBQzNCLDJCQUEyQixrRUFBRSxVQUFVLHNFQUFFLENBQUMsaUVBQUUsMEJBQTBCLHVEQUFDO0FBQ3ZFLDJCQUEyQixrRUFBRSxVQUFVLHNFQUFFLENBQUMsbUVBQUUsQ0FBQyxpRUFBQyx5QkFBeUIsdURBQUM7QUFDeEUsdUJBQXVCLGtFQUFFLFVBQVUsa0VBQUMsQ0FBQyxtRUFBRSxDQUFDLGlFQUFDLHlCQUF5Qix1REFBQztBQUNuRSx1QkFBdUIsa0VBQUUsVUFBVSxrRUFBRSxDQUFDLG1FQUFFLENBQUMsaUVBQUM7QUFDMUMsR0FBRztBQUNILENBQUMsZ0RBQWdEO0FBQ2pELEtBQUssd0VBQUM7QUFDTixLQUFLLG1FQUFDO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILENBQUMsbUpBQW1KLG1FQUFDO0FBQ3JKO0FBQ0EsQ0FBQzs7QUFFc0YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9uaWtpdGEvRGVza3RvcC9mb2N1c3BoZXJlL25vZGVfbW9kdWxlcy90ZW1wb3JhbC1wb2x5ZmlsbC9jaHVua3MvY2xhc3NBcGkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZnVuY3Rpb24gY3JlYXRlU2xvdENsYXNzKGksIGwsIHMsIGMsIHUpIHtcbiAgZnVuY3Rpb24gQ2xhc3MoLi4udCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBDbGFzcykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYSk7XG4gICAgfVxuICAgIHVuKHRoaXMsIGwoLi4udCkpO1xuICB9XG4gIGZ1bmN0aW9uIGJpbmRNZXRob2QodCwgZSkge1xuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcygoZnVuY3Rpb24oLi4uZSkge1xuICAgICAgcmV0dXJuIHQuY2FsbCh0aGlzLCBnZXRTcGVjaWZpY1Nsb3RzKHRoaXMpLCAuLi5lKTtcbiAgICB9KSwgcihlKSk7XG4gIH1cbiAgZnVuY3Rpb24gZ2V0U3BlY2lmaWNTbG90cyh0KSB7XG4gICAgY29uc3QgZSA9IGNuKHQpO1xuICAgIGlmICghZSB8fCBlLmJyYW5kaW5nICE9PSBpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGEpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgLi4udChlKGJpbmRNZXRob2QsIHMpKSxcbiAgICAuLi5uKGUoYmluZE1ldGhvZCwgYykpLFxuICAgIC4uLm8oXCJUZW1wb3JhbC5cIiArIGkpXG4gIH0pLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhDbGFzcywge1xuICAgIC4uLm4odSksXG4gICAgLi4ucihpKVxuICB9KSwgWyBDbGFzcywgdCA9PiB7XG4gICAgY29uc3QgZSA9IE9iamVjdC5jcmVhdGUoQ2xhc3MucHJvdG90eXBlKTtcbiAgICByZXR1cm4gdW4oZSwgdCksIGU7XG4gIH0sIGdldFNwZWNpZmljU2xvdHMgXTtcbn1cblxuZnVuY3Rpb24gcmVqZWN0SW52YWxpZEJhZyh0KSB7XG4gIGlmIChjbih0KSB8fCB2b2lkIDAgIT09IHQuY2FsZW5kYXIgfHwgdm9pZCAwICE9PSB0LnRpbWVab25lKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihpKTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gZ2V0Q2FsZW5kYXJJZEZyb21CYWcodCkge1xuICByZXR1cm4gZXh0cmFjdENhbGVuZGFySWRGcm9tQmFnKHQpIHx8IGw7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RDYWxlbmRhcklkRnJvbUJhZyh0KSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogZX0gPSB0O1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgcmV0dXJuIHJlZmluZUNhbGVuZGFyQXJnKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNhbGVuZGFyQXJnKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCB7Y2FsZW5kYXI6IGV9ID0gY24odCkgfHwge307XG4gICAgaWYgKCFlKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGModCkpO1xuICAgIH1cbiAgICByZXR1cm4gZTtcbiAgfVxuICByZXR1cm4gKHQgPT4gdShmKG0odCkpKSkodCk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNhbGVuZGFyR2V0dGVycyh0KSB7XG4gIGNvbnN0IGUgPSB7fTtcbiAgZm9yIChjb25zdCBuIGluIHQpIHtcbiAgICBlW25dID0gdCA9PiB7XG4gICAgICBjb25zdCB7Y2FsZW5kYXI6IGV9ID0gdDtcbiAgICAgIHJldHVybiBDKGUpW25dKHQpO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIG5ldmVyVmFsdWVPZigpIHtcbiAgdGhyb3cgbmV3IFR5cGVFcnJvcihiKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lVGltZVpvbmVBcmcodCkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IHt0aW1lWm9uZTogZX0gPSBjbih0KSB8fCB7fTtcbiAgICBpZiAoIWUpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRih0KSk7XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9XG4gIHJldHVybiAodCA9PiBNKFoobSh0KSkpKSh0KTtcbn1cblxuZnVuY3Rpb24gdG9EdXJhdGlvblNsb3RzKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCBlID0gY24odCk7XG4gICAgcmV0dXJuIGUgJiYgZS5icmFuZGluZyA9PT0gTiA/IGUgOiBxKHQpO1xuICB9XG4gIHJldHVybiBSKHQpO1xufVxuXG5mdW5jdGlvbiByZWZpbmVQdWJsaWNSZWxhdGl2ZVRvKHQpIHtcbiAgaWYgKHZvaWQgMCAhPT0gdCkge1xuICAgIGlmIChzKHQpKSB7XG4gICAgICBjb25zdCBlID0gY24odCkgfHwge307XG4gICAgICBzd2l0Y2ggKGUuYnJhbmRpbmcpIHtcbiAgICAgICBjYXNlIHo6XG4gICAgICAgY2FzZSBHOlxuICAgICAgICByZXR1cm4gZTtcblxuICAgICAgIGNhc2UgeDpcbiAgICAgICAgcmV0dXJuIFcoZSk7XG4gICAgICB9XG4gICAgICBjb25zdCBuID0gZ2V0Q2FsZW5kYXJJZEZyb21CYWcodCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICAuLi4kKHJlZmluZVRpbWVab25lQXJnLCBMLCBDKG4pLCB0KSxcbiAgICAgICAgY2FsZW5kYXI6IG5cbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBIKHQpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHRvUGxhaW5UaW1lU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KSB8fCB7fTtcbiAgICBzd2l0Y2ggKG4uYnJhbmRpbmcpIHtcbiAgICAgY2FzZSBmdDpcbiAgICAgIHJldHVybiBtdChlKSwgbjtcblxuICAgICBjYXNlIHg6XG4gICAgICByZXR1cm4gbXQoZSksIFN0KG4pO1xuXG4gICAgIGNhc2UgejpcbiAgICAgIHJldHVybiBtdChlKSwgZHQoTCwgbik7XG4gICAgfVxuICAgIHJldHVybiBUdCh0LCBlKTtcbiAgfVxuICBjb25zdCBuID0gaHQodCk7XG4gIHJldHVybiBtdChlKSwgbjtcbn1cblxuZnVuY3Rpb24gb3B0aW9uYWxUb1BsYWluVGltZUZpZWxkcyh0KSB7XG4gIHJldHVybiB2b2lkIDAgPT09IHQgPyB2b2lkIDAgOiB0b1BsYWluVGltZVNsb3RzKHQpO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluRGF0ZVRpbWVTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpIHx8IHt9O1xuICAgIHN3aXRjaCAobi5icmFuZGluZykge1xuICAgICBjYXNlIHg6XG4gICAgICByZXR1cm4gbXQoZSksIG47XG5cbiAgICAgY2FzZSBHOlxuICAgICAgcmV0dXJuIG10KGUpLCBqdCh7XG4gICAgICAgIC4uLm4sXG4gICAgICAgIC4uLk50XG4gICAgICB9KTtcblxuICAgICBjYXNlIHo6XG4gICAgICByZXR1cm4gbXQoZSksIHl0KEwsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gQXQoQyhnZXRDYWxlbmRhcklkRnJvbUJhZyh0KSksIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSBCdCh0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluTW9udGhEYXlTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpO1xuICAgIGlmIChuICYmIG4uYnJhbmRpbmcgPT09IHF0KSB7XG4gICAgICByZXR1cm4gbXQoZSksIG47XG4gICAgfVxuICAgIGNvbnN0IG8gPSBleHRyYWN0Q2FsZW5kYXJJZEZyb21CYWcodCk7XG4gICAgcmV0dXJuIFJ0KEMobyB8fCBsKSwgIW8sIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSB4dChDLCB0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1BsYWluWWVhck1vbnRoU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KTtcbiAgICByZXR1cm4gbiAmJiBuLmJyYW5kaW5nID09PSBVdCA/IChtdChlKSwgbikgOiBYdChDKGdldENhbGVuZGFySWRGcm9tQmFnKHQpKSwgdCwgZSk7XG4gIH1cbiAgY29uc3QgbiA9IF90KEMsIHQpO1xuICByZXR1cm4gbXQoZSksIG47XG59XG5cbmZ1bmN0aW9uIHRvUGxhaW5EYXRlU2xvdHModCwgZSkge1xuICBpZiAocyh0KSkge1xuICAgIGNvbnN0IG4gPSBjbih0KSB8fCB7fTtcbiAgICBzd2l0Y2ggKG4uYnJhbmRpbmcpIHtcbiAgICAgY2FzZSBHOlxuICAgICAgcmV0dXJuIG10KGUpLCBuO1xuXG4gICAgIGNhc2UgeDpcbiAgICAgIHJldHVybiBtdChlKSwgVyhuKTtcblxuICAgICBjYXNlIHo6XG4gICAgICByZXR1cm4gbXQoZSksIGZlKEwsIG4pO1xuICAgIH1cbiAgICByZXR1cm4gbWUoQyhnZXRDYWxlbmRhcklkRnJvbUJhZyh0KSksIHQsIGUpO1xuICB9XG4gIGNvbnN0IG4gPSBkZSh0KTtcbiAgcmV0dXJuIG10KGUpLCBuO1xufVxuXG5mdW5jdGlvbiB0b1pvbmVkRGF0ZVRpbWVTbG90cyh0LCBlKSB7XG4gIGlmIChzKHQpKSB7XG4gICAgY29uc3QgbiA9IGNuKHQpO1xuICAgIGlmIChuICYmIG4uYnJhbmRpbmcgPT09IHopIHtcbiAgICAgIHJldHVybiBqZShlKSwgbjtcbiAgICB9XG4gICAgY29uc3QgbyA9IGdldENhbGVuZGFySWRGcm9tQmFnKHQpO1xuICAgIHJldHVybiBOZShyZWZpbmVUaW1lWm9uZUFyZywgTCwgQyhvKSwgbywgdCwgZSk7XG4gIH1cbiAgcmV0dXJuIEFlKHQsIGUpO1xufVxuXG5mdW5jdGlvbiBhZGFwdERhdGVNZXRob2RzKHQpIHtcbiAgcmV0dXJuIGUoKHQgPT4gZSA9PiB0KHNsb3RzVG9Jc28oZSkpKSwgdCk7XG59XG5cbmZ1bmN0aW9uIHNsb3RzVG9Jc28odCkge1xuICByZXR1cm4gaGUodCwgTCk7XG59XG5cbmZ1bmN0aW9uIHRvSW5zdGFudFNsb3RzKHQpIHtcbiAgaWYgKHModCkpIHtcbiAgICBjb25zdCBlID0gY24odCk7XG4gICAgaWYgKGUpIHtcbiAgICAgIHN3aXRjaCAoZS5icmFuZGluZykge1xuICAgICAgIGNhc2UgUmU6XG4gICAgICAgIHJldHVybiBlO1xuXG4gICAgICAgY2FzZSB6OlxuICAgICAgICByZXR1cm4geGUoZS5lcG9jaE5hbm9zZWNvbmRzKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFdlKHQpO1xufVxuXG5mdW5jdGlvbiB0b1RlbXBvcmFsSW5zdGFudCgpIHtcbiAgY29uc3QgdCA9IERhdGUucHJvdG90eXBlLnZhbHVlT2YuY2FsbCh0aGlzKTtcbiAgcmV0dXJuIEtuKHhlKEdlKHplKHQpLCBRZSkpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlRGF0ZVRpbWVGb3JtYXRDbGFzcygpIHtcbiAgZnVuY3Rpb24gRGF0ZVRpbWVGb3JtYXRGdW5jKHQsIGUpIHtcbiAgICByZXR1cm4gbmV3IERhdGVUaW1lRm9ybWF0TmV3KHQsIGUpO1xuICB9XG4gIGZ1bmN0aW9uIERhdGVUaW1lRm9ybWF0TmV3KHQsIGUgPSBPYmplY3QuY3JlYXRlKG51bGwpKSB7XG4gICAgdG8uc2V0KHRoaXMsICgodCwgZSkgPT4ge1xuICAgICAgY29uc3QgbiA9IG5ldyBlbih0LCBlKSwgbyA9IG4ucmVzb2x2ZWRPcHRpb25zKCksIHIgPSBvLmxvY2FsZSwgYSA9IG5uKE9iamVjdC5rZXlzKGUpLCBvKSwgaSA9IG9uKGNyZWF0ZUZvcm1hdFByZXBwZXJGb3JCcmFuZGluZyksIHByZXBGb3JtYXQgPSAodCwgLi4uZSkgPT4ge1xuICAgICAgICBpZiAodCkge1xuICAgICAgICAgIGlmICgyICE9PSBlLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGZvciAoY29uc3QgdCBvZiBlKSB7XG4gICAgICAgICAgICBpZiAodm9pZCAwID09PSB0KSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobG4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0IHx8IHZvaWQgMCAhPT0gZVswXSB8fCAoZSA9IFtdKTtcbiAgICAgICAgY29uc3QgbyA9IGUubWFwKCh0ID0+IGNuKHQpIHx8IE51bWJlcih0KSkpO1xuICAgICAgICBsZXQgbCwgcyA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgdCBvZiBvKSB7XG4gICAgICAgICAgY29uc3QgZSA9IFwib2JqZWN0XCIgPT0gdHlwZW9mIHQgPyB0LmJyYW5kaW5nIDogdm9pZCAwO1xuICAgICAgICAgIGlmIChzKysgJiYgZSAhPT0gbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihsbik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGwgPSBlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsID8gaShsKShyLCBhLCAuLi5vKSA6IFsgbiwgLi4ubyBdO1xuICAgICAgfTtcbiAgICAgIHJldHVybiBwcmVwRm9ybWF0LlggPSBuLCBwcmVwRm9ybWF0O1xuICAgIH0pKHQsIGUpKTtcbiAgfVxuICBjb25zdCB0ID0gZW4ucHJvdG90eXBlLCBlID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnModCksIG4gPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyhlbik7XG4gIGZvciAoY29uc3QgdCBpbiBlKSB7XG4gICAgY29uc3QgbiA9IGVbdF0sIG8gPSB0LnN0YXJ0c1dpdGgoXCJmb3JtYXRcIikgJiYgY3JlYXRlRm9ybWF0TWV0aG9kKHQpO1xuICAgIFwiZnVuY3Rpb25cIiA9PSB0eXBlb2Ygbi52YWx1ZSA/IG4udmFsdWUgPSBcImNvbnN0cnVjdG9yXCIgPT09IHQgPyBEYXRlVGltZUZvcm1hdEZ1bmMgOiBvIHx8IGNyZWF0ZVByb3hpZWRNZXRob2QodCkgOiBvICYmIChuLmdldCA9IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0by5oYXModGhpcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihhKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoLi4udCkgPT4gby5hcHBseSh0aGlzLCB0KTtcbiAgICB9LCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhuLmdldCwgcihgZ2V0ICR7dH1gKSkpO1xuICB9XG4gIHJldHVybiBuLnByb3RvdHlwZS52YWx1ZSA9IERhdGVUaW1lRm9ybWF0TmV3LnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoe30sIGUpLCBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhEYXRlVGltZUZvcm1hdEZ1bmMsIG4pLCBcbiAgRGF0ZVRpbWVGb3JtYXRGdW5jO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRNZXRob2QodCkge1xuICByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoKGZ1bmN0aW9uKC4uLmUpIHtcbiAgICBjb25zdCBuID0gdG8uZ2V0KHRoaXMpLCBbbywgLi4ucl0gPSBuKHQuaW5jbHVkZXMoXCJSYW5nZVwiKSwgLi4uZSk7XG4gICAgcmV0dXJuIG9bdF0oLi4ucik7XG4gIH0pLCByKHQpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUHJveGllZE1ldGhvZCh0KSB7XG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydGllcygoZnVuY3Rpb24oLi4uZSkge1xuICAgIHJldHVybiB0by5nZXQodGhpcykuWFt0XSguLi5lKTtcbiAgfSksIHIodCkpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVGb3JtYXRQcmVwcGVyRm9yQnJhbmRpbmcodCkge1xuICBjb25zdCBlID0gQ25bdF07XG4gIGlmICghZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3Iocm4odCkpO1xuICB9XG4gIHJldHVybiBRKGUsIG9uKGFuKSwgMSk7XG59XG5cbmltcG9ydCB7IGNyZWF0ZUdldHRlckRlc2NyaXB0b3JzIGFzIHQsIG1hcFByb3BzIGFzIGUsIGNyZWF0ZVByb3BEZXNjcmlwdG9ycyBhcyBuLCBjcmVhdGVTdHJpbmdUYWdEZXNjcmlwdG9ycyBhcyBvLCBjcmVhdGVOYW1lRGVzY3JpcHRvcnMgYXMgciwgaW52YWxpZENhbGxpbmdDb250ZXh0IGFzIGEsIGludmFsaWRCYWcgYXMgaSwgaXNvQ2FsZW5kYXJJZCBhcyBsLCBpc09iamVjdExpa2UgYXMgcywgaW52YWxpZENhbGVuZGFyIGFzIGMsIHJlc29sdmVDYWxlbmRhcklkIGFzIHUsIHBhcnNlQ2FsZW5kYXJJZCBhcyBmLCByZXF1aXJlU3RyaW5nIGFzIG0sIHJlcXVpcmVTdHJpbmdPclVuZGVmaW5lZCBhcyBkLCByZXF1aXJlSW50ZWdlck9yVW5kZWZpbmVkIGFzIFMsIHJlcXVpcmVJbnRlZ2VyIGFzIFQsIHJlcXVpcmVQb3NpdGl2ZUludGVnZXIgYXMgaCwgcmVxdWlyZUJvb2xlYW4gYXMgRCwgcmVxdWlyZVBvc2l0aXZlSW50ZWdlck9yVW5kZWZpbmVkIGFzIFAsIG1hcFByb3BOYW1lcyBhcyBnLCBkdXJhdGlvbkZpZWxkTmFtZXNBc2MgYXMgcCwgdGltZUZpZWxkTmFtZXNBc2MgYXMgTywgaXNvVGltZUZpZWxkTmFtZXNBc2MgYXMgdywgZ2V0RXBvY2hNaWxsaSBhcyBJLCBnZXRFcG9jaE5hbm8gYXMgdiwgY3JlYXRlTmF0aXZlU3RhbmRhcmRPcHMgYXMgQywgZm9yYmlkZGVuVmFsdWVPZiBhcyBiLCBpbnZhbGlkVGltZVpvbmUgYXMgRiwgcmVzb2x2ZVRpbWVab25lSWQgYXMgTSwgcGFyc2VUaW1lWm9uZUlkIGFzIFosIGdldER1cmF0aW9uQmxhbmsgYXMgeSwgY29uc3RydWN0RHVyYXRpb25TbG90cyBhcyBqLCBEdXJhdGlvbkJyYW5kaW5nIGFzIE4sIGR1cmF0aW9uV2l0aEZpZWxkcyBhcyBBLCBuZWdhdGVEdXJhdGlvbiBhcyBCLCBhYnNEdXJhdGlvbiBhcyBZLCBhZGREdXJhdGlvbnMgYXMgRSwgcXVlcnlOYXRpdmVUaW1lWm9uZSBhcyBMLCByb3VuZER1cmF0aW9uIGFzIFYsIHRvdGFsRHVyYXRpb24gYXMgSiwgZm9ybWF0RHVyYXRpb25Jc28gYXMgaywgcmVmaW5lRHVyYXRpb25CYWcgYXMgcSwgcGFyc2VEdXJhdGlvbiBhcyBSLCBQbGFpbkRhdGVUaW1lQnJhbmRpbmcgYXMgeCwgY3JlYXRlUGxhaW5EYXRlU2xvdHMgYXMgVywgUGxhaW5EYXRlQnJhbmRpbmcgYXMgRywgWm9uZWREYXRlVGltZUJyYW5kaW5nIGFzIHosIHJlZmluZU1heWJlWm9uZWREYXRlVGltZUJhZyBhcyAkLCBwYXJzZVJlbGF0aXZlVG9TbG90cyBhcyBILCBjb21wYXJlRHVyYXRpb25zIGFzIEssIGNyZWF0ZUZvcm1hdFByZXBwZXIgYXMgUSwgaW5zdGFudENvbmZpZyBhcyBVLCBkYXRlVGltZUNvbmZpZyBhcyBYLCBkYXRlQ29uZmlnIGFzIF8sIHRpbWVDb25maWcgYXMgdHQsIHllYXJNb250aENvbmZpZyBhcyBldCwgbW9udGhEYXlDb25maWcgYXMgbnQsIHpvbmVkQ29uZmlnIGFzIG90LCBwbGFpblRpbWVXaXRoRmllbGRzIGFzIHJ0LCBtb3ZlUGxhaW5UaW1lIGFzIGF0LCBkaWZmUGxhaW5UaW1lcyBhcyBpdCwgcm91bmRQbGFpblRpbWUgYXMgbHQsIHBsYWluVGltZXNFcXVhbCBhcyBzdCwgZm9ybWF0UGxhaW5UaW1lSXNvIGFzIGN0LCBjb25zdHJ1Y3RQbGFpblRpbWVTbG90cyBhcyB1dCwgUGxhaW5UaW1lQnJhbmRpbmcgYXMgZnQsIHJlZmluZU92ZXJmbG93T3B0aW9ucyBhcyBtdCwgem9uZWREYXRlVGltZVRvUGxhaW5UaW1lIGFzIGR0LCBjcmVhdGVQbGFpblRpbWVTbG90cyBhcyBTdCwgcmVmaW5lUGxhaW5UaW1lQmFnIGFzIFR0LCBwYXJzZVBsYWluVGltZSBhcyBodCwgY29tcGFyZUlzb1RpbWVGaWVsZHMgYXMgRHQsIGJpbmRBcmdzIGFzIFB0LCBwbGFpbkRhdGVUaW1lV2l0aEZpZWxkcyBhcyBndCwgc2xvdHNXaXRoQ2FsZW5kYXJJZCBhcyBwdCwgcGxhaW5EYXRlVGltZVdpdGhQbGFpblRpbWUgYXMgT3QsIG1vdmVQbGFpbkRhdGVUaW1lIGFzIHd0LCBkaWZmUGxhaW5EYXRlVGltZXMgYXMgSXQsIHJvdW5kUGxhaW5EYXRlVGltZSBhcyB2dCwgcGxhaW5EYXRlVGltZXNFcXVhbCBhcyBDdCwgcGxhaW5EYXRlVGltZVRvWm9uZWREYXRlVGltZSBhcyBidCwgZm9ybWF0UGxhaW5EYXRlVGltZUlzbyBhcyBGdCwgcmVmaW5lQ2FsZW5kYXJJZCBhcyBNdCwgY29uc3RydWN0UGxhaW5EYXRlVGltZVNsb3RzIGFzIFp0LCB6b25lZERhdGVUaW1lVG9QbGFpbkRhdGVUaW1lIGFzIHl0LCBjcmVhdGVQbGFpbkRhdGVUaW1lU2xvdHMgYXMganQsIGlzb1RpbWVGaWVsZERlZmF1bHRzIGFzIE50LCByZWZpbmVQbGFpbkRhdGVUaW1lQmFnIGFzIEF0LCBwYXJzZVBsYWluRGF0ZVRpbWUgYXMgQnQsIGNvbXBhcmVJc29EYXRlVGltZUZpZWxkcyBhcyBZdCwgcGxhaW5Nb250aERheVdpdGhGaWVsZHMgYXMgRXQsIHBsYWluTW9udGhEYXlzRXF1YWwgYXMgTHQsIHBsYWluTW9udGhEYXlUb1BsYWluRGF0ZSBhcyBWdCwgZm9ybWF0UGxhaW5Nb250aERheUlzbyBhcyBKdCwgY29uc3RydWN0UGxhaW5Nb250aERheVNsb3RzIGFzIGt0LCBQbGFpbk1vbnRoRGF5QnJhbmRpbmcgYXMgcXQsIHJlZmluZVBsYWluTW9udGhEYXlCYWcgYXMgUnQsIHBhcnNlUGxhaW5Nb250aERheSBhcyB4dCwgcGxhaW5ZZWFyTW9udGhXaXRoRmllbGRzIGFzIFd0LCBtb3ZlUGxhaW5ZZWFyTW9udGggYXMgR3QsIGRpZmZQbGFpblllYXJNb250aCBhcyB6dCwgcGxhaW5ZZWFyTW9udGhzRXF1YWwgYXMgJHQsIHBsYWluWWVhck1vbnRoVG9QbGFpbkRhdGUgYXMgSHQsIGZvcm1hdFBsYWluWWVhck1vbnRoSXNvIGFzIEt0LCBjb25zdHJ1Y3RQbGFpblllYXJNb250aFNsb3RzIGFzIFF0LCBQbGFpblllYXJNb250aEJyYW5kaW5nIGFzIFV0LCByZWZpbmVQbGFpblllYXJNb250aEJhZyBhcyBYdCwgcGFyc2VQbGFpblllYXJNb250aCBhcyBfdCwgY29tcGFyZUlzb0RhdGVGaWVsZHMgYXMgdGUsIHBsYWluRGF0ZVdpdGhGaWVsZHMgYXMgZWUsIG1vdmVQbGFpbkRhdGUgYXMgbmUsIGRpZmZQbGFpbkRhdGVzIGFzIG9lLCBwbGFpbkRhdGVzRXF1YWwgYXMgcmUsIHBsYWluRGF0ZVRvWm9uZWREYXRlVGltZSBhcyBhZSwgcGxhaW5EYXRlVG9QbGFpbkRhdGVUaW1lIGFzIGllLCBwbGFpbkRhdGVUb1BsYWluWWVhck1vbnRoIGFzIGxlLCBwbGFpbkRhdGVUb1BsYWluTW9udGhEYXkgYXMgc2UsIGZvcm1hdFBsYWluRGF0ZUlzbyBhcyBjZSwgY29uc3RydWN0UGxhaW5EYXRlU2xvdHMgYXMgdWUsIHpvbmVkRGF0ZVRpbWVUb1BsYWluRGF0ZSBhcyBmZSwgcmVmaW5lUGxhaW5EYXRlQmFnIGFzIG1lLCBwYXJzZVBsYWluRGF0ZSBhcyBkZSwgZm9ybWF0T2Zmc2V0TmFubyBhcyBTZSwgY29tcHV0ZVpvbmVkSG91cnNJbkRheSBhcyBUZSwgem9uZWRFcG9jaFNsb3RzVG9Jc28gYXMgaGUsIHpvbmVkRGF0ZVRpbWVXaXRoRmllbGRzIGFzIERlLCBzbG90c1dpdGhUaW1lWm9uZUlkIGFzIFBlLCB6b25lZERhdGVUaW1lV2l0aFBsYWluVGltZSBhcyBnZSwgbW92ZVpvbmVkRGF0ZVRpbWUgYXMgcGUsIGNyZWF0ZUR1cmF0aW9uU2xvdHMgYXMgT2UsIGRpZmZab25lZERhdGVUaW1lcyBhcyB3ZSwgcm91bmRab25lZERhdGVUaW1lIGFzIEllLCBjb21wdXRlWm9uZWRTdGFydE9mRGF5IGFzIHZlLCB6b25lZERhdGVUaW1lc0VxdWFsIGFzIENlLCB6b25lZERhdGVUaW1lVG9JbnN0YW50IGFzIGJlLCBmb3JtYXRab25lZERhdGVUaW1lSXNvIGFzIEZlLCByZWZpbmVEaXJlY3Rpb25PcHRpb25zIGFzIE1lLCByZWZpbmVUaW1lWm9uZUlkIGFzIFplLCBjb25zdHJ1Y3Rab25lZERhdGVUaW1lU2xvdHMgYXMgeWUsIHJlZmluZVpvbmVkRmllbGRPcHRpb25zIGFzIGplLCByZWZpbmVab25lZERhdGVUaW1lQmFnIGFzIE5lLCBwYXJzZVpvbmVkRGF0ZVRpbWUgYXMgQWUsIGNvbXBhcmVab25lZERhdGVUaW1lcyBhcyBCZSwgbW92ZUluc3RhbnQgYXMgWWUsIGRpZmZJbnN0YW50cyBhcyBFZSwgcm91bmRJbnN0YW50IGFzIExlLCBpbnN0YW50c0VxdWFsIGFzIFZlLCBpbnN0YW50VG9ab25lZERhdGVUaW1lIGFzIEplLCBmb3JtYXRJbnN0YW50SXNvIGFzIGtlLCBjb25zdHJ1Y3RJbnN0YW50U2xvdHMgYXMgcWUsIEluc3RhbnRCcmFuZGluZyBhcyBSZSwgY3JlYXRlSW5zdGFudFNsb3RzIGFzIHhlLCBwYXJzZUluc3RhbnQgYXMgV2UsIG51bWJlclRvQmlnTmFubyBhcyBHZSwgcmVxdWlyZU51bWJlcklzSW50ZWdlciBhcyB6ZSwgZXBvY2hNaWxsaVRvSW5zdGFudCBhcyAkZSwgZXBvY2hOYW5vVG9JbnN0YW50IGFzIEhlLCBjb21wYXJlSW5zdGFudHMgYXMgS2UsIG5hbm9Jbk1pbGxpIGFzIFFlLCBnZXRDdXJyZW50VGltZVpvbmVJZCBhcyBVZSwgZ2V0Q3VycmVudEVwb2NoTmFubyBhcyBYZSwgY3JlYXRlWm9uZWREYXRlVGltZVNsb3RzIGFzIF9lLCBnZXRDdXJyZW50SXNvRGF0ZVRpbWUgYXMgdG4sIFJhd0RhdGVUaW1lRm9ybWF0IGFzIGVuLCBwbHVja1Byb3BzIGFzIG5uLCBtZW1vaXplIGFzIG9uLCBpbnZhbGlkRm9ybWF0VHlwZSBhcyBybiwgY3JlYXRlRm9ybWF0Rm9yUHJlcCBhcyBhbiwgbWlzbWF0Y2hpbmdGb3JtYXRUeXBlcyBhcyBsbiB9IGZyb20gXCIuL2ludGVybmFsLmpzXCI7XG5cbmNvbnN0IHNuID0gLypAX19QVVJFX18qLyBuZXcgV2Vha01hcCwgY24gPSAvKkBfX1BVUkVfXyovIHNuLmdldC5iaW5kKHNuKSwgdW4gPSAvKkBfX1BVUkVfXyovIHNuLnNldC5iaW5kKHNuKSwgZm4gPSB7XG4gIGVyYTogZCxcbiAgZXJhWWVhcjogUyxcbiAgeWVhcjogVCxcbiAgbW9udGg6IGgsXG4gIGRheXNJbk1vbnRoOiBoLFxuICBkYXlzSW5ZZWFyOiBoLFxuICBpbkxlYXBZZWFyOiBELFxuICBtb250aHNJblllYXI6IGhcbn0sIG1uID0ge1xuICBtb250aENvZGU6IG1cbn0sIGRuID0ge1xuICBkYXk6IGhcbn0sIFNuID0ge1xuICBkYXlPZldlZWs6IGgsXG4gIGRheU9mWWVhcjogaCxcbiAgd2Vla09mWWVhcjogUCxcbiAgeWVhck9mV2VlazogUyxcbiAgZGF5c0luV2VlazogaFxufSwgVG4gPSAvKkBfX1BVUkVfXyovIGNyZWF0ZUNhbGVuZGFyR2V0dGVycygvKkBfX1BVUkVfXyovIE9iamVjdC5hc3NpZ24oe30sIGZuLCBtbiwgZG4sIFNuKSksIGhuID0gLypAX19QVVJFX18qLyBjcmVhdGVDYWxlbmRhckdldHRlcnMoe1xuICAuLi5mbixcbiAgLi4ubW5cbn0pLCBEbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlQ2FsZW5kYXJHZXR0ZXJzKHtcbiAgLi4ubW4sXG4gIC4uLmRuXG59KSwgUG4gPSB7XG4gIGNhbGVuZGFySWQ6IHQgPT4gdC5jYWxlbmRhclxufSwgZ24gPSAvKkBfX1BVUkVfXyovIGcoKHQgPT4gZSA9PiBlW3RdKSwgcC5jb25jYXQoXCJzaWduXCIpKSwgcG4gPSAvKkBfX1BVUkVfXyovIGcoKCh0LCBlKSA9PiB0ID0+IHRbd1tlXV0pLCBPKSwgT24gPSB7XG4gIGVwb2NoTWlsbGlzZWNvbmRzOiBJLFxuICBlcG9jaE5hbm9zZWNvbmRzOiB2XG59LCBbd24sIEluLCB2bl0gPSBjcmVhdGVTbG90Q2xhc3MoTiwgaiwge1xuICAuLi5nbixcbiAgYmxhbms6IHlcbn0sIHtcbiAgd2l0aDogKHQsIGUpID0+IEluKEEodCwgZSkpLFxuICBuZWdhdGVkOiB0ID0+IEluKEIodCkpLFxuICBhYnM6IHQgPT4gSW4oWSh0KSksXG4gIGFkZDogKHQsIGUsIG4pID0+IEluKEUocmVmaW5lUHVibGljUmVsYXRpdmVUbywgQywgTCwgMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHN1YnRyYWN0OiAodCwgZSwgbikgPT4gSW4oRShyZWZpbmVQdWJsaWNSZWxhdGl2ZVRvLCBDLCBMLCAxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgcm91bmQ6ICh0LCBlKSA9PiBJbihWKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHQsIGUpKSxcbiAgdG90YWw6ICh0LCBlKSA9PiBKKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHQsIGUpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgcmV0dXJuIEludGwuRHVyYXRpb25Gb3JtYXQgPyBuZXcgSW50bC5EdXJhdGlvbkZvcm1hdChlLCBuKS5mb3JtYXQodGhpcykgOiBrKHQpO1xuICB9LFxuICB0b1N0cmluZzogayxcbiAgdG9KU09OOiB0ID0+IGsodCksXG4gIHZhbHVlT2Y6IG5ldmVyVmFsdWVPZlxufSwge1xuICBmcm9tOiB0ID0+IEluKHRvRHVyYXRpb25TbG90cyh0KSksXG4gIGNvbXBhcmU6ICh0LCBlLCBuKSA9PiBLKHJlZmluZVB1YmxpY1JlbGF0aXZlVG8sIEMsIEwsIHRvRHVyYXRpb25TbG90cyh0KSwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKVxufSksIENuID0ge1xuICBJbnN0YW50OiBVLFxuICBQbGFpbkRhdGVUaW1lOiBYLFxuICBQbGFpbkRhdGU6IF8sXG4gIFBsYWluVGltZTogdHQsXG4gIFBsYWluWWVhck1vbnRoOiBldCxcbiAgUGxhaW5Nb250aERheTogbnRcbn0sIGJuID0gLypAX19QVVJFX18qLyBRKFUpLCBGbiA9IC8qQF9fUFVSRV9fKi8gUShvdCksIE1uID0gLypAX19QVVJFX18qLyBRKFgpLCBabiA9IC8qQF9fUFVSRV9fKi8gUShfKSwgeW4gPSAvKkBfX1BVUkVfXyovIFEodHQpLCBqbiA9IC8qQF9fUFVSRV9fKi8gUShldCksIE5uID0gLypAX19QVVJFX18qLyBRKG50KSwgW0FuLCBCbl0gPSBjcmVhdGVTbG90Q2xhc3MoZnQsIHV0LCBwbiwge1xuICB3aXRoKHQsIGUsIG4pIHtcbiAgICByZXR1cm4gQm4ocnQodGhpcywgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpO1xuICB9LFxuICBhZGQ6ICh0LCBlKSA9PiBCbihhdCgwLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSkpKSxcbiAgc3VidHJhY3Q6ICh0LCBlKSA9PiBCbihhdCgxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSkpKSxcbiAgdW50aWw6ICh0LCBlLCBuKSA9PiBJbihpdCgwLCB0LCB0b1BsYWluVGltZVNsb3RzKGUpLCBuKSksXG4gIHNpbmNlOiAodCwgZSwgbikgPT4gSW4oaXQoMSwgdCwgdG9QbGFpblRpbWVTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEJuKGx0KHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gc3QodCwgdG9QbGFpblRpbWVTbG90cyhlKSksXG4gIHRvTG9jYWxlU3RyaW5nKHQsIGUsIG4pIHtcbiAgICBjb25zdCBbbywgcl0gPSB5bihlLCBuLCB0KTtcbiAgICByZXR1cm4gby5mb3JtYXQocik7XG4gIH0sXG4gIHRvU3RyaW5nOiBjdCxcbiAgdG9KU09OOiB0ID0+IGN0KHQpLFxuICB2YWx1ZU9mOiBuZXZlclZhbHVlT2Zcbn0sIHtcbiAgZnJvbTogKHQsIGUpID0+IEJuKHRvUGxhaW5UaW1lU2xvdHModCwgZSkpLFxuICBjb21wYXJlOiAodCwgZSkgPT4gRHQodG9QbGFpblRpbWVTbG90cyh0KSwgdG9QbGFpblRpbWVTbG90cyhlKSlcbn0pLCBbWW4sIEVuXSA9IGNyZWF0ZVNsb3RDbGFzcyh4LCBQdChadCwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5UbixcbiAgLi4ucG5cbn0sIHtcbiAgd2l0aDogKHQsIGUsIG4pID0+IEVuKGd0KEMsIHQsIHJlamVjdEludmFsaWRCYWcoZSksIG4pKSxcbiAgd2l0aENhbGVuZGFyOiAodCwgZSkgPT4gRW4ocHQodCwgcmVmaW5lQ2FsZW5kYXJBcmcoZSkpKSxcbiAgd2l0aFBsYWluVGltZTogKHQsIGUpID0+IEVuKE90KHQsIG9wdGlvbmFsVG9QbGFpblRpbWVGaWVsZHMoZSkpKSxcbiAgYWRkOiAodCwgZSwgbikgPT4gRW4od3QoQywgMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHN1YnRyYWN0OiAodCwgZSwgbikgPT4gRW4od3QoQywgMSwgdCwgdG9EdXJhdGlvblNsb3RzKGUpLCBuKSksXG4gIHVudGlsOiAodCwgZSwgbikgPT4gSW4oSXQoQywgMCwgdCwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSksIG4pKSxcbiAgc2luY2U6ICh0LCBlLCBuKSA9PiBJbihJdChDLCAxLCB0LCB0b1BsYWluRGF0ZVRpbWVTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEVuKHZ0KHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gQ3QodCwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSkpLFxuICB0b1pvbmVkRGF0ZVRpbWU6ICh0LCBlLCBuKSA9PiAkbihidChMLCB0LCByZWZpbmVUaW1lWm9uZUFyZyhlKSwgbikpLFxuICB0b1BsYWluRGF0ZTogdCA9PiBXbihXKHQpKSxcbiAgdG9QbGFpblRpbWU6IHQgPT4gQm4oU3QodCkpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gTW4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogRnQsXG4gIHRvSlNPTjogdCA9PiBGdCh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBFbih0b1BsYWluRGF0ZVRpbWVTbG90cyh0LCBlKSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBZdCh0b1BsYWluRGF0ZVRpbWVTbG90cyh0KSwgdG9QbGFpbkRhdGVUaW1lU2xvdHMoZSkpXG59KSwgW0xuLCBWbiwgSm5dID0gY3JlYXRlU2xvdENsYXNzKHF0LCBQdChrdCwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5EblxufSwge1xuICB3aXRoOiAodCwgZSwgbikgPT4gVm4oRXQoQywgdCwgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiBMdCh0LCB0b1BsYWluTW9udGhEYXlTbG90cyhlKSksXG4gIHRvUGxhaW5EYXRlKHQsIGUpIHtcbiAgICByZXR1cm4gV24oVnQoQywgdCwgdGhpcywgZSkpO1xuICB9LFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gTm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogSnQsXG4gIHRvSlNPTjogdCA9PiBKdCh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBWbih0b1BsYWluTW9udGhEYXlTbG90cyh0LCBlKSlcbn0pLCBba24sIHFuLCBSbl0gPSBjcmVhdGVTbG90Q2xhc3MoVXQsIFB0KFF0LCBNdCksIHtcbiAgLi4uUG4sXG4gIC4uLmhuXG59LCB7XG4gIHdpdGg6ICh0LCBlLCBuKSA9PiBxbihXdChDLCB0LCByZWplY3RJbnZhbGlkQmFnKGUpLCBuKSksXG4gIGFkZDogKHQsIGUsIG4pID0+IHFuKEd0KEMsIDAsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICBzdWJ0cmFjdDogKHQsIGUsIG4pID0+IHFuKEd0KEMsIDEsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICB1bnRpbDogKHQsIGUsIG4pID0+IEluKHp0KEMsIDAsIHQsIHRvUGxhaW5ZZWFyTW9udGhTbG90cyhlKSwgbikpLFxuICBzaW5jZTogKHQsIGUsIG4pID0+IEluKHp0KEMsIDEsIHQsIHRvUGxhaW5ZZWFyTW9udGhTbG90cyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiAkdCh0LCB0b1BsYWluWWVhck1vbnRoU2xvdHMoZSkpLFxuICB0b1BsYWluRGF0ZSh0LCBlKSB7XG4gICAgcmV0dXJuIFduKEh0KEMsIHQsIHRoaXMsIGUpKTtcbiAgfSxcbiAgdG9Mb2NhbGVTdHJpbmcodCwgZSwgbikge1xuICAgIGNvbnN0IFtvLCByXSA9IGpuKGUsIG4sIHQpO1xuICAgIHJldHVybiBvLmZvcm1hdChyKTtcbiAgfSxcbiAgdG9TdHJpbmc6IEt0LFxuICB0b0pTT046IHQgPT4gS3QodCksXG4gIHZhbHVlT2Y6IG5ldmVyVmFsdWVPZlxufSwge1xuICBmcm9tOiAodCwgZSkgPT4gcW4odG9QbGFpblllYXJNb250aFNsb3RzKHQsIGUpKSxcbiAgY29tcGFyZTogKHQsIGUpID0+IHRlKHRvUGxhaW5ZZWFyTW9udGhTbG90cyh0KSwgdG9QbGFpblllYXJNb250aFNsb3RzKGUpKVxufSksIFt4biwgV24sIEduXSA9IGNyZWF0ZVNsb3RDbGFzcyhHLCBQdCh1ZSwgTXQpLCB7XG4gIC4uLlBuLFxuICAuLi5UblxufSwge1xuICB3aXRoOiAodCwgZSwgbikgPT4gV24oZWUoQywgdCwgcmVqZWN0SW52YWxpZEJhZyhlKSwgbikpLFxuICB3aXRoQ2FsZW5kYXI6ICh0LCBlKSA9PiBXbihwdCh0LCByZWZpbmVDYWxlbmRhckFyZyhlKSkpLFxuICBhZGQ6ICh0LCBlLCBuKSA9PiBXbihuZShDLCAwLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgc3VidHJhY3Q6ICh0LCBlLCBuKSA9PiBXbihuZShDLCAxLCB0LCB0b0R1cmF0aW9uU2xvdHMoZSksIG4pKSxcbiAgdW50aWw6ICh0LCBlLCBuKSA9PiBJbihvZShDLCAwLCB0LCB0b1BsYWluRGF0ZVNsb3RzKGUpLCBuKSksXG4gIHNpbmNlOiAodCwgZSwgbikgPT4gSW4ob2UoQywgMSwgdCwgdG9QbGFpbkRhdGVTbG90cyhlKSwgbikpLFxuICBlcXVhbHM6ICh0LCBlKSA9PiByZSh0LCB0b1BsYWluRGF0ZVNsb3RzKGUpKSxcbiAgdG9ab25lZERhdGVUaW1lKHQsIGUpIHtcbiAgICBjb25zdCBuID0gcyhlKSA/IGUgOiB7XG4gICAgICB0aW1lWm9uZTogZVxuICAgIH07XG4gICAgcmV0dXJuICRuKGFlKHJlZmluZVRpbWVab25lQXJnLCB0b1BsYWluVGltZVNsb3RzLCBMLCB0LCBuKSk7XG4gIH0sXG4gIHRvUGxhaW5EYXRlVGltZTogKHQsIGUpID0+IEVuKGllKHQsIG9wdGlvbmFsVG9QbGFpblRpbWVGaWVsZHMoZSkpKSxcbiAgdG9QbGFpblllYXJNb250aCh0KSB7XG4gICAgcmV0dXJuIHFuKGxlKEMsIHQsIHRoaXMpKTtcbiAgfSxcbiAgdG9QbGFpbk1vbnRoRGF5KHQpIHtcbiAgICByZXR1cm4gVm4oc2UoQywgdCwgdGhpcykpO1xuICB9LFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gWm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogY2UsXG4gIHRvSlNPTjogdCA9PiBjZSh0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiBXbih0b1BsYWluRGF0ZVNsb3RzKHQsIGUpKSxcbiAgY29tcGFyZTogKHQsIGUpID0+IHRlKHRvUGxhaW5EYXRlU2xvdHModCksIHRvUGxhaW5EYXRlU2xvdHMoZSkpXG59KSwgW3puLCAkbl0gPSBjcmVhdGVTbG90Q2xhc3MoeiwgUHQoeWUsIE10LCBaZSksIHtcbiAgLi4uT24sXG4gIC4uLlBuLFxuICAuLi5hZGFwdERhdGVNZXRob2RzKFRuKSxcbiAgLi4uYWRhcHREYXRlTWV0aG9kcyhwbiksXG4gIG9mZnNldDogdCA9PiBTZShzbG90c1RvSXNvKHQpLm9mZnNldE5hbm9zZWNvbmRzKSxcbiAgb2Zmc2V0TmFub3NlY29uZHM6IHQgPT4gc2xvdHNUb0lzbyh0KS5vZmZzZXROYW5vc2Vjb25kcyxcbiAgdGltZVpvbmVJZDogdCA9PiB0LnRpbWVab25lLFxuICBob3Vyc0luRGF5OiB0ID0+IFRlKEwsIHQpXG59LCB7XG4gIHdpdGg6ICh0LCBlLCBuKSA9PiAkbihEZShDLCBMLCB0LCByZWplY3RJbnZhbGlkQmFnKGUpLCBuKSksXG4gIHdpdGhDYWxlbmRhcjogKHQsIGUpID0+ICRuKHB0KHQsIHJlZmluZUNhbGVuZGFyQXJnKGUpKSksXG4gIHdpdGhUaW1lWm9uZTogKHQsIGUpID0+ICRuKFBlKHQsIHJlZmluZVRpbWVab25lQXJnKGUpKSksXG4gIHdpdGhQbGFpblRpbWU6ICh0LCBlKSA9PiAkbihnZShMLCB0LCBvcHRpb25hbFRvUGxhaW5UaW1lRmllbGRzKGUpKSksXG4gIGFkZDogKHQsIGUsIG4pID0+ICRuKHBlKEMsIEwsIDAsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICBzdWJ0cmFjdDogKHQsIGUsIG4pID0+ICRuKHBlKEMsIEwsIDEsIHQsIHRvRHVyYXRpb25TbG90cyhlKSwgbikpLFxuICB1bnRpbDogKHQsIGUsIG4pID0+IEluKE9lKHdlKEMsIEwsIDAsIHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpLCBuKSkpLFxuICBzaW5jZTogKHQsIGUsIG4pID0+IEluKE9lKHdlKEMsIEwsIDEsIHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpLCBuKSkpLFxuICByb3VuZDogKHQsIGUpID0+ICRuKEllKEwsIHQsIGUpKSxcbiAgc3RhcnRPZkRheTogdCA9PiAkbih2ZShMLCB0KSksXG4gIGVxdWFsczogKHQsIGUpID0+IENlKHQsIHRvWm9uZWREYXRlVGltZVNsb3RzKGUpKSxcbiAgdG9JbnN0YW50OiB0ID0+IEtuKGJlKHQpKSxcbiAgdG9QbGFpbkRhdGVUaW1lOiB0ID0+IEVuKHl0KEwsIHQpKSxcbiAgdG9QbGFpbkRhdGU6IHQgPT4gV24oZmUoTCwgdCkpLFxuICB0b1BsYWluVGltZTogdCA9PiBCbihkdChMLCB0KSksXG4gIHRvTG9jYWxlU3RyaW5nKHQsIGUsIG4gPSB7fSkge1xuICAgIGNvbnN0IFtvLCByXSA9IEZuKGUsIG4sIHQpO1xuICAgIHJldHVybiBvLmZvcm1hdChyKTtcbiAgfSxcbiAgdG9TdHJpbmc6ICh0LCBlKSA9PiBGZShMLCB0LCBlKSxcbiAgdG9KU09OOiB0ID0+IEZlKEwsIHQpLFxuICB2YWx1ZU9mOiBuZXZlclZhbHVlT2YsXG4gIGdldFRpbWVab25lVHJhbnNpdGlvbih0LCBlKSB7XG4gICAgY29uc3Qge3RpbWVab25lOiBuLCBlcG9jaE5hbm9zZWNvbmRzOiBvfSA9IHQsIHIgPSBNZShlKSwgYSA9IEwobikuTyhvLCByKTtcbiAgICByZXR1cm4gYSA/ICRuKHtcbiAgICAgIC4uLnQsXG4gICAgICBlcG9jaE5hbm9zZWNvbmRzOiBhXG4gICAgfSkgOiBudWxsO1xuICB9XG59LCB7XG4gIGZyb206ICh0LCBlKSA9PiAkbih0b1pvbmVkRGF0ZVRpbWVTbG90cyh0LCBlKSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBCZSh0b1pvbmVkRGF0ZVRpbWVTbG90cyh0KSwgdG9ab25lZERhdGVUaW1lU2xvdHMoZSkpXG59KSwgW0huLCBLbiwgUW5dID0gY3JlYXRlU2xvdENsYXNzKFJlLCBxZSwgT24sIHtcbiAgYWRkOiAodCwgZSkgPT4gS24oWWUoMCwgdCwgdG9EdXJhdGlvblNsb3RzKGUpKSksXG4gIHN1YnRyYWN0OiAodCwgZSkgPT4gS24oWWUoMSwgdCwgdG9EdXJhdGlvblNsb3RzKGUpKSksXG4gIHVudGlsOiAodCwgZSwgbikgPT4gSW4oRWUoMCwgdCwgdG9JbnN0YW50U2xvdHMoZSksIG4pKSxcbiAgc2luY2U6ICh0LCBlLCBuKSA9PiBJbihFZSgxLCB0LCB0b0luc3RhbnRTbG90cyhlKSwgbikpLFxuICByb3VuZDogKHQsIGUpID0+IEtuKExlKHQsIGUpKSxcbiAgZXF1YWxzOiAodCwgZSkgPT4gVmUodCwgdG9JbnN0YW50U2xvdHMoZSkpLFxuICB0b1pvbmVkRGF0ZVRpbWVJU086ICh0LCBlKSA9PiAkbihKZSh0LCByZWZpbmVUaW1lWm9uZUFyZyhlKSkpLFxuICB0b0xvY2FsZVN0cmluZyh0LCBlLCBuKSB7XG4gICAgY29uc3QgW28sIHJdID0gYm4oZSwgbiwgdCk7XG4gICAgcmV0dXJuIG8uZm9ybWF0KHIpO1xuICB9LFxuICB0b1N0cmluZzogKHQsIGUpID0+IGtlKHJlZmluZVRpbWVab25lQXJnLCBMLCB0LCBlKSxcbiAgdG9KU09OOiB0ID0+IGtlKHJlZmluZVRpbWVab25lQXJnLCBMLCB0KSxcbiAgdmFsdWVPZjogbmV2ZXJWYWx1ZU9mXG59LCB7XG4gIGZyb206IHQgPT4gS24odG9JbnN0YW50U2xvdHModCkpLFxuICBmcm9tRXBvY2hNaWxsaXNlY29uZHM6IHQgPT4gS24oJGUodCkpLFxuICBmcm9tRXBvY2hOYW5vc2Vjb25kczogdCA9PiBLbihIZSh0KSksXG4gIGNvbXBhcmU6ICh0LCBlKSA9PiBLZSh0b0luc3RhbnRTbG90cyh0KSwgdG9JbnN0YW50U2xvdHMoZSkpXG59KSwgVW4gPSAvKkBfX1BVUkVfXyovIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gIC4uLm8oXCJUZW1wb3JhbC5Ob3dcIiksXG4gIC4uLm4oe1xuICAgIHRpbWVab25lSWQ6ICgpID0+IFVlKCksXG4gICAgaW5zdGFudDogKCkgPT4gS24oeGUoWGUoKSkpLFxuICAgIHpvbmVkRGF0ZVRpbWVJU086ICh0ID0gVWUoKSkgPT4gJG4oX2UoWGUoKSwgcmVmaW5lVGltZVpvbmVBcmcodCksIGwpKSxcbiAgICBwbGFpbkRhdGVUaW1lSVNPOiAodCA9IFVlKCkpID0+IEVuKGp0KHRuKEwocmVmaW5lVGltZVpvbmVBcmcodCkpKSwgbCkpLFxuICAgIHBsYWluRGF0ZUlTTzogKHQgPSBVZSgpKSA9PiBXbihXKHRuKEwocmVmaW5lVGltZVpvbmVBcmcodCkpKSwgbCkpLFxuICAgIHBsYWluVGltZUlTTzogKHQgPSBVZSgpKSA9PiBCbihTdCh0bihMKHJlZmluZVRpbWVab25lQXJnKHQpKSkpKVxuICB9KVxufSksIFhuID0gLypAX19QVVJFX18qLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSwge1xuICAuLi5vKFwiVGVtcG9yYWxcIiksXG4gIC4uLm4oe1xuICAgIFBsYWluWWVhck1vbnRoOiBrbixcbiAgICBQbGFpbk1vbnRoRGF5OiBMbixcbiAgICBQbGFpbkRhdGU6IHhuLFxuICAgIFBsYWluVGltZTogQW4sXG4gICAgUGxhaW5EYXRlVGltZTogWW4sXG4gICAgWm9uZWREYXRlVGltZTogem4sXG4gICAgSW5zdGFudDogSG4sXG4gICAgRHVyYXRpb246IHduLFxuICAgIE5vdzogVW5cbiAgfSlcbn0pLCBfbiA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlRGF0ZVRpbWVGb3JtYXRDbGFzcygpLCB0byA9IC8qQF9fUFVSRV9fKi8gbmV3IFdlYWtNYXAsIGVvID0gLypAX19QVVJFX18qLyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhPYmplY3QuY3JlYXRlKEludGwpLCBuKHtcbiAgRGF0ZVRpbWVGb3JtYXQ6IF9uXG59KSk7XG5cbmV4cG9ydCB7IF9uIGFzIERhdGVUaW1lRm9ybWF0LCBlbyBhcyBJbnRsRXh0ZW5kZWQsIFhuIGFzIFRlbXBvcmFsLCB0b1RlbXBvcmFsSW5zdGFudCB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/temporal-polyfill/chunks/classApi.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/temporal-polyfill/chunks/internal.js":
/*!***********************************************************!*\
  !*** ./node_modules/temporal-polyfill/chunks/internal.js ***!
  \***********************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   DurationBranding: () => (/* binding */ N),\n/* harmony export */   InstantBranding: () => (/* binding */ Re),\n/* harmony export */   PlainDateBranding: () => (/* binding */ G),\n/* harmony export */   PlainDateTimeBranding: () => (/* binding */ x),\n/* harmony export */   PlainMonthDayBranding: () => (/* binding */ qt),\n/* harmony export */   PlainTimeBranding: () => (/* binding */ ft),\n/* harmony export */   PlainYearMonthBranding: () => (/* binding */ Ut),\n/* harmony export */   RawDateTimeFormat: () => (/* binding */ en),\n/* harmony export */   ZonedDateTimeBranding: () => (/* binding */ z),\n/* harmony export */   absDuration: () => (/* binding */ Y),\n/* harmony export */   addDurations: () => (/* binding */ E),\n/* harmony export */   bindArgs: () => (/* binding */ Pt),\n/* harmony export */   compareDurations: () => (/* binding */ K),\n/* harmony export */   compareInstants: () => (/* binding */ Ke),\n/* harmony export */   compareIsoDateFields: () => (/* binding */ te),\n/* harmony export */   compareIsoDateTimeFields: () => (/* binding */ Yt),\n/* harmony export */   compareIsoTimeFields: () => (/* binding */ Dt),\n/* harmony export */   compareZonedDateTimes: () => (/* binding */ Be),\n/* harmony export */   computeZonedHoursInDay: () => (/* binding */ Te),\n/* harmony export */   computeZonedStartOfDay: () => (/* binding */ ve),\n/* harmony export */   constructDurationSlots: () => (/* binding */ j),\n/* harmony export */   constructInstantSlots: () => (/* binding */ qe),\n/* harmony export */   constructPlainDateSlots: () => (/* binding */ ue),\n/* harmony export */   constructPlainDateTimeSlots: () => (/* binding */ Zt),\n/* harmony export */   constructPlainMonthDaySlots: () => (/* binding */ kt),\n/* harmony export */   constructPlainTimeSlots: () => (/* binding */ ut),\n/* harmony export */   constructPlainYearMonthSlots: () => (/* binding */ Qt),\n/* harmony export */   constructZonedDateTimeSlots: () => (/* binding */ ye),\n/* harmony export */   createDurationSlots: () => (/* binding */ Oe),\n/* harmony export */   createFormatForPrep: () => (/* binding */ an),\n/* harmony export */   createFormatPrepper: () => (/* binding */ Q),\n/* harmony export */   createGetterDescriptors: () => (/* binding */ t),\n/* harmony export */   createInstantSlots: () => (/* binding */ xe),\n/* harmony export */   createNameDescriptors: () => (/* binding */ r),\n/* harmony export */   createNativeStandardOps: () => (/* binding */ C),\n/* harmony export */   createPlainDateSlots: () => (/* binding */ W),\n/* harmony export */   createPlainDateTimeSlots: () => (/* binding */ jt),\n/* harmony export */   createPlainTimeSlots: () => (/* binding */ St),\n/* harmony export */   createPropDescriptors: () => (/* binding */ n),\n/* harmony export */   createStringTagDescriptors: () => (/* binding */ o),\n/* harmony export */   createZonedDateTimeSlots: () => (/* binding */ _e),\n/* harmony export */   dateConfig: () => (/* binding */ _),\n/* harmony export */   dateTimeConfig: () => (/* binding */ X),\n/* harmony export */   diffInstants: () => (/* binding */ Ee),\n/* harmony export */   diffPlainDateTimes: () => (/* binding */ It),\n/* harmony export */   diffPlainDates: () => (/* binding */ oe),\n/* harmony export */   diffPlainTimes: () => (/* binding */ it),\n/* harmony export */   diffPlainYearMonth: () => (/* binding */ zt),\n/* harmony export */   diffZonedDateTimes: () => (/* binding */ we),\n/* harmony export */   durationFieldNamesAsc: () => (/* binding */ p),\n/* harmony export */   durationWithFields: () => (/* binding */ A),\n/* harmony export */   epochMilliToInstant: () => (/* binding */ $e),\n/* harmony export */   epochNanoToInstant: () => (/* binding */ He),\n/* harmony export */   forbiddenValueOf: () => (/* binding */ b),\n/* harmony export */   formatDurationIso: () => (/* binding */ k),\n/* harmony export */   formatInstantIso: () => (/* binding */ ke),\n/* harmony export */   formatOffsetNano: () => (/* binding */ Se),\n/* harmony export */   formatPlainDateIso: () => (/* binding */ ce),\n/* harmony export */   formatPlainDateTimeIso: () => (/* binding */ Ft),\n/* harmony export */   formatPlainMonthDayIso: () => (/* binding */ Jt),\n/* harmony export */   formatPlainTimeIso: () => (/* binding */ ct),\n/* harmony export */   formatPlainYearMonthIso: () => (/* binding */ Kt),\n/* harmony export */   formatZonedDateTimeIso: () => (/* binding */ Fe),\n/* harmony export */   getCurrentEpochNano: () => (/* binding */ Xe),\n/* harmony export */   getCurrentIsoDateTime: () => (/* binding */ tn),\n/* harmony export */   getCurrentTimeZoneId: () => (/* binding */ Ue),\n/* harmony export */   getDurationBlank: () => (/* binding */ y),\n/* harmony export */   getEpochMilli: () => (/* binding */ I),\n/* harmony export */   getEpochNano: () => (/* binding */ v),\n/* harmony export */   instantConfig: () => (/* binding */ U),\n/* harmony export */   instantToZonedDateTime: () => (/* binding */ Je),\n/* harmony export */   instantsEqual: () => (/* binding */ Ve),\n/* harmony export */   invalidBag: () => (/* binding */ i),\n/* harmony export */   invalidCalendar: () => (/* binding */ c),\n/* harmony export */   invalidCallingContext: () => (/* binding */ a),\n/* harmony export */   invalidFormatType: () => (/* binding */ rn),\n/* harmony export */   invalidTimeZone: () => (/* binding */ F),\n/* harmony export */   isObjectLike: () => (/* binding */ s),\n/* harmony export */   isoCalendarId: () => (/* binding */ l),\n/* harmony export */   isoTimeFieldDefaults: () => (/* binding */ Nt),\n/* harmony export */   isoTimeFieldNamesAsc: () => (/* binding */ w),\n/* harmony export */   mapPropNames: () => (/* binding */ g),\n/* harmony export */   mapProps: () => (/* binding */ e),\n/* harmony export */   memoize: () => (/* binding */ on),\n/* harmony export */   mismatchingFormatTypes: () => (/* binding */ ln),\n/* harmony export */   monthDayConfig: () => (/* binding */ nt),\n/* harmony export */   moveInstant: () => (/* binding */ Ye),\n/* harmony export */   movePlainDate: () => (/* binding */ ne),\n/* harmony export */   movePlainDateTime: () => (/* binding */ wt),\n/* harmony export */   movePlainTime: () => (/* binding */ at),\n/* harmony export */   movePlainYearMonth: () => (/* binding */ Gt),\n/* harmony export */   moveZonedDateTime: () => (/* binding */ pe),\n/* harmony export */   nanoInMilli: () => (/* binding */ Qe),\n/* harmony export */   negateDuration: () => (/* binding */ B),\n/* harmony export */   numberToBigNano: () => (/* binding */ Ge),\n/* harmony export */   parseCalendarId: () => (/* binding */ f),\n/* harmony export */   parseDuration: () => (/* binding */ R),\n/* harmony export */   parseInstant: () => (/* binding */ We),\n/* harmony export */   parsePlainDate: () => (/* binding */ de),\n/* harmony export */   parsePlainDateTime: () => (/* binding */ Bt),\n/* harmony export */   parsePlainMonthDay: () => (/* binding */ xt),\n/* harmony export */   parsePlainTime: () => (/* binding */ ht),\n/* harmony export */   parsePlainYearMonth: () => (/* binding */ _t),\n/* harmony export */   parseRelativeToSlots: () => (/* binding */ H),\n/* harmony export */   parseTimeZoneId: () => (/* binding */ Z),\n/* harmony export */   parseZonedDateTime: () => (/* binding */ Ae),\n/* harmony export */   plainDateTimeToZonedDateTime: () => (/* binding */ bt),\n/* harmony export */   plainDateTimeWithFields: () => (/* binding */ gt),\n/* harmony export */   plainDateTimeWithPlainTime: () => (/* binding */ Ot),\n/* harmony export */   plainDateTimesEqual: () => (/* binding */ Ct),\n/* harmony export */   plainDateToPlainDateTime: () => (/* binding */ ie),\n/* harmony export */   plainDateToPlainMonthDay: () => (/* binding */ se),\n/* harmony export */   plainDateToPlainYearMonth: () => (/* binding */ le),\n/* harmony export */   plainDateToZonedDateTime: () => (/* binding */ ae),\n/* harmony export */   plainDateWithFields: () => (/* binding */ ee),\n/* harmony export */   plainDatesEqual: () => (/* binding */ re),\n/* harmony export */   plainMonthDayToPlainDate: () => (/* binding */ Vt),\n/* harmony export */   plainMonthDayWithFields: () => (/* binding */ Et),\n/* harmony export */   plainMonthDaysEqual: () => (/* binding */ Lt),\n/* harmony export */   plainTimeWithFields: () => (/* binding */ rt),\n/* harmony export */   plainTimesEqual: () => (/* binding */ st),\n/* harmony export */   plainYearMonthToPlainDate: () => (/* binding */ Ht),\n/* harmony export */   plainYearMonthWithFields: () => (/* binding */ Wt),\n/* harmony export */   plainYearMonthsEqual: () => (/* binding */ $t),\n/* harmony export */   pluckProps: () => (/* binding */ nn),\n/* harmony export */   queryNativeTimeZone: () => (/* binding */ L),\n/* harmony export */   refineCalendarId: () => (/* binding */ Mt),\n/* harmony export */   refineDirectionOptions: () => (/* binding */ Me),\n/* harmony export */   refineDurationBag: () => (/* binding */ q),\n/* harmony export */   refineMaybeZonedDateTimeBag: () => (/* binding */ $),\n/* harmony export */   refineOverflowOptions: () => (/* binding */ mt),\n/* harmony export */   refinePlainDateBag: () => (/* binding */ me),\n/* harmony export */   refinePlainDateTimeBag: () => (/* binding */ At),\n/* harmony export */   refinePlainMonthDayBag: () => (/* binding */ Rt),\n/* harmony export */   refinePlainTimeBag: () => (/* binding */ Tt),\n/* harmony export */   refinePlainYearMonthBag: () => (/* binding */ Xt),\n/* harmony export */   refineTimeZoneId: () => (/* binding */ Ze),\n/* harmony export */   refineZonedDateTimeBag: () => (/* binding */ Ne),\n/* harmony export */   refineZonedFieldOptions: () => (/* binding */ je),\n/* harmony export */   requireBoolean: () => (/* binding */ D),\n/* harmony export */   requireInteger: () => (/* binding */ T),\n/* harmony export */   requireIntegerOrUndefined: () => (/* binding */ S),\n/* harmony export */   requireNumberIsInteger: () => (/* binding */ ze),\n/* harmony export */   requirePositiveInteger: () => (/* binding */ h),\n/* harmony export */   requirePositiveIntegerOrUndefined: () => (/* binding */ P),\n/* harmony export */   requireString: () => (/* binding */ m),\n/* harmony export */   requireStringOrUndefined: () => (/* binding */ d),\n/* harmony export */   resolveCalendarId: () => (/* binding */ u),\n/* harmony export */   resolveTimeZoneId: () => (/* binding */ M),\n/* harmony export */   roundDuration: () => (/* binding */ V),\n/* harmony export */   roundInstant: () => (/* binding */ Le),\n/* harmony export */   roundPlainDateTime: () => (/* binding */ vt),\n/* harmony export */   roundPlainTime: () => (/* binding */ lt),\n/* harmony export */   roundZonedDateTime: () => (/* binding */ Ie),\n/* harmony export */   slotsWithCalendarId: () => (/* binding */ pt),\n/* harmony export */   slotsWithTimeZoneId: () => (/* binding */ Pe),\n/* harmony export */   timeConfig: () => (/* binding */ tt),\n/* harmony export */   timeFieldNamesAsc: () => (/* binding */ O),\n/* harmony export */   totalDuration: () => (/* binding */ J),\n/* harmony export */   yearMonthConfig: () => (/* binding */ et),\n/* harmony export */   zonedConfig: () => (/* binding */ ot),\n/* harmony export */   zonedDateTimeToInstant: () => (/* binding */ be),\n/* harmony export */   zonedDateTimeToPlainDate: () => (/* binding */ fe),\n/* harmony export */   zonedDateTimeToPlainDateTime: () => (/* binding */ yt),\n/* harmony export */   zonedDateTimeToPlainTime: () => (/* binding */ dt),\n/* harmony export */   zonedDateTimeWithFields: () => (/* binding */ De),\n/* harmony export */   zonedDateTimeWithPlainTime: () => (/* binding */ ge),\n/* harmony export */   zonedDateTimesEqual: () => (/* binding */ Ce),\n/* harmony export */   zonedEpochSlotsToIso: () => (/* binding */ he)\n/* harmony export */ });\nfunction clampProp(e, n, t, o, r) {\n  return clampEntity(n, ((e, n) => {\n    const t = e[n];\n    if (void 0 === t) {\n      throw new TypeError(missingField(n));\n    }\n    return t;\n  })(e, n), t, o, r);\n}\n\nfunction clampEntity(e, n, t, o, r, i) {\n  const a = clampNumber(n, t, o);\n  if (r && n !== a) {\n    throw new RangeError(numberOutOfRange(e, n, t, o, i));\n  }\n  return a;\n}\n\nfunction s(e) {\n  return null !== e && /object|function/.test(typeof e);\n}\n\nfunction on(e, n = Map) {\n  const t = new n;\n  return (n, ...o) => {\n    if (t.has(n)) {\n      return t.get(n);\n    }\n    const r = e(n, ...o);\n    return t.set(n, r), r;\n  };\n}\n\nfunction r(e) {\n  return n({\n    name: e\n  }, 1);\n}\n\nfunction n(n, t) {\n  return e((e => ({\n    value: e,\n    configurable: 1,\n    writable: !t\n  })), n);\n}\n\nfunction t(n) {\n  return e((e => ({\n    get: e,\n    configurable: 1\n  })), n);\n}\n\nfunction o(e) {\n  return {\n    [Symbol.toStringTag]: {\n      value: e,\n      configurable: 1\n    }\n  };\n}\n\nfunction zipProps(e, n) {\n  const t = {};\n  let o = e.length;\n  for (const r of n) {\n    t[e[--o]] = r;\n  }\n  return t;\n}\n\nfunction e(e, n, t) {\n  const o = {};\n  for (const r in n) {\n    o[r] = e(n[r], r, t);\n  }\n  return o;\n}\n\nfunction g(e, n, t) {\n  const o = {};\n  for (let r = 0; r < n.length; r++) {\n    const i = n[r];\n    o[i] = e(i, r, t);\n  }\n  return o;\n}\n\nfunction remapProps(e, n, t) {\n  const o = {};\n  for (let r = 0; r < e.length; r++) {\n    o[n[r]] = t[e[r]];\n  }\n  return o;\n}\n\nfunction nn(e, n) {\n  const t = Object.create(null);\n  for (const o of e) {\n    t[o] = n[o];\n  }\n  return t;\n}\n\nfunction hasAnyPropsByName(e, n) {\n  for (const t of n) {\n    if (t in e) {\n      return 1;\n    }\n  }\n  return 0;\n}\n\nfunction allPropsEqual(e, n, t) {\n  for (const o of e) {\n    if (n[o] !== t[o]) {\n      return 0;\n    }\n  }\n  return 1;\n}\n\nfunction zeroOutProps(e, n, t) {\n  const o = {\n    ...t\n  };\n  for (let t = 0; t < n; t++) {\n    o[e[t]] = 0;\n  }\n  return o;\n}\n\nfunction Pt(e, ...n) {\n  return (...t) => e(...n, ...t);\n}\n\nfunction capitalize(e) {\n  return e[0].toUpperCase() + e.substring(1);\n}\n\nfunction sortStrings(e) {\n  return e.slice().sort();\n}\n\nfunction padNumber(e, n) {\n  return String(n).padStart(e, \"0\");\n}\n\nfunction compareNumbers(e, n) {\n  return Math.sign(e - n);\n}\n\nfunction clampNumber(e, n, t) {\n  return Math.min(Math.max(e, n), t);\n}\n\nfunction divModFloor(e, n) {\n  return [ Math.floor(e / n), modFloor(e, n) ];\n}\n\nfunction modFloor(e, n) {\n  return (e % n + n) % n;\n}\n\nfunction divModTrunc(e, n) {\n  return [ divTrunc(e, n), modTrunc(e, n) ];\n}\n\nfunction divTrunc(e, n) {\n  return Math.trunc(e / n) || 0;\n}\n\nfunction modTrunc(e, n) {\n  return e % n || 0;\n}\n\nfunction hasHalf(e) {\n  return .5 === Math.abs(e % 1);\n}\n\nfunction givenFieldsToBigNano(e, n, t) {\n  let o = 0, r = 0;\n  for (let i = 0; i <= n; i++) {\n    const n = e[t[i]], a = Ao[i], s = Uo / a, [c, u] = divModTrunc(n, s);\n    o += u * a, r += c;\n  }\n  const [i, a] = divModTrunc(o, Uo);\n  return [ r + i, a ];\n}\n\nfunction nanoToGivenFields(e, n, t) {\n  const o = {};\n  for (let r = n; r >= 0; r--) {\n    const n = Ao[r];\n    o[t[r]] = divTrunc(e, n), e = modTrunc(e, n);\n  }\n  return o;\n}\n\nfunction d(e) {\n  if (void 0 !== e) {\n    return m(e);\n  }\n}\n\nfunction P(e) {\n  if (void 0 !== e) {\n    return h(e);\n  }\n}\n\nfunction S(e) {\n  if (void 0 !== e) {\n    return T(e);\n  }\n}\n\nfunction h(e) {\n  return requireNumberIsPositive(T(e));\n}\n\nfunction T(e) {\n  return ze(cr(e));\n}\n\nfunction requirePropDefined(e, n) {\n  if (null == n) {\n    throw new RangeError(missingField(e));\n  }\n  return n;\n}\n\nfunction requireObjectLike(e) {\n  if (!s(e)) {\n    throw new TypeError(oo);\n  }\n  return e;\n}\n\nfunction requireType(e, n, t = e) {\n  if (typeof n !== e) {\n    throw new TypeError(invalidEntity(t, n));\n  }\n  return n;\n}\n\nfunction ze(e, n = \"number\") {\n  if (!Number.isInteger(e)) {\n    throw new RangeError(expectedInteger(n, e));\n  }\n  return e || 0;\n}\n\nfunction requireNumberIsPositive(e, n = \"number\") {\n  if (e <= 0) {\n    throw new RangeError(expectedPositive(n, e));\n  }\n  return e;\n}\n\nfunction toString(e) {\n  if (\"symbol\" == typeof e) {\n    throw new TypeError(no);\n  }\n  return String(e);\n}\n\nfunction toStringViaPrimitive(e, n) {\n  return s(e) ? String(e) : m(e, n);\n}\n\nfunction toBigInt(e) {\n  if (\"string\" == typeof e) {\n    return BigInt(e);\n  }\n  if (\"bigint\" != typeof e) {\n    throw new TypeError(invalidBigInt(e));\n  }\n  return e;\n}\n\nfunction toNumber(e, n = \"number\") {\n  if (\"bigint\" == typeof e) {\n    throw new TypeError(forbiddenBigIntToNumber(n));\n  }\n  if (e = Number(e), !Number.isFinite(e)) {\n    throw new RangeError(expectedFinite(n, e));\n  }\n  return e;\n}\n\nfunction toInteger(e, n) {\n  return Math.trunc(toNumber(e, n)) || 0;\n}\n\nfunction toStrictInteger(e, n) {\n  return ze(toNumber(e, n), n);\n}\n\nfunction toPositiveInteger(e, n) {\n  return requireNumberIsPositive(toInteger(e, n), n);\n}\n\nfunction createBigNano(e, n) {\n  let [t, o] = divModTrunc(n, Uo), r = e + t;\n  const i = Math.sign(r);\n  return i && i === -Math.sign(o) && (r -= i, o += i * Uo), [ r, o ];\n}\n\nfunction addBigNanos(e, n, t = 1) {\n  return createBigNano(e[0] + n[0] * t, e[1] + n[1] * t);\n}\n\nfunction moveBigNano(e, n) {\n  return createBigNano(e[0], e[1] + n);\n}\n\nfunction diffBigNanos(e, n) {\n  return addBigNanos(n, e, -1);\n}\n\nfunction compareBigNanos(e, n) {\n  return compareNumbers(e[0], n[0]) || compareNumbers(e[1], n[1]);\n}\n\nfunction bigNanoOutside(e, n, t) {\n  return -1 === compareBigNanos(e, n) || 1 === compareBigNanos(e, t);\n}\n\nfunction bigIntToBigNano(e, n = 1) {\n  const t = BigInt(Uo / n);\n  return [ Number(e / t), Number(e % t) * n ];\n}\n\nfunction Ge(e, n = 1) {\n  const t = Uo / n, [o, r] = divModTrunc(e, t);\n  return [ o, r * n ];\n}\n\nfunction bigNanoToNumber(e, n = 1, t) {\n  const [o, r] = e, [i, a] = divModTrunc(r, n);\n  return o * (Uo / n) + (i + (t ? a / n : 0));\n}\n\nfunction divModBigNano(e, n, t = divModFloor) {\n  const [o, r] = e, [i, a] = t(r, n);\n  return [ o * (Uo / n) + i, a ];\n}\n\nfunction checkIsoYearMonthInBounds(e) {\n  return clampProp(e, \"isoYear\", wr, Fr, 1), e.isoYear === wr ? clampProp(e, \"isoMonth\", 4, 12, 1) : e.isoYear === Fr && clampProp(e, \"isoMonth\", 1, 9, 1), \n  e;\n}\n\nfunction checkIsoDateInBounds(e) {\n  return checkIsoDateTimeInBounds({\n    ...e,\n    ...Nt,\n    isoHour: 12\n  }), e;\n}\n\nfunction checkIsoDateTimeInBounds(e) {\n  const n = clampProp(e, \"isoYear\", wr, Fr, 1), t = n === wr ? 1 : n === Fr ? -1 : 0;\n  return t && checkEpochNanoInBounds(isoToEpochNano({\n    ...e,\n    isoDay: e.isoDay + t,\n    isoNanosecond: e.isoNanosecond - t\n  })), e;\n}\n\nfunction checkEpochNanoInBounds(e) {\n  if (!e || bigNanoOutside(e, Sr, Er)) {\n    throw new RangeError(Io);\n  }\n  return e;\n}\n\nfunction isoTimeFieldsToNano(e) {\n  return givenFieldsToBigNano(e, 5, w)[1];\n}\n\nfunction nanoToIsoTimeAndDay(e) {\n  const [n, t] = divModFloor(e, Uo);\n  return [ nanoToGivenFields(t, 5, w), n ];\n}\n\nfunction epochNanoToSecMod(e) {\n  return divModBigNano(e, Ro);\n}\n\nfunction isoToEpochMilli(e) {\n  return isoArgsToEpochMilli(e.isoYear, e.isoMonth, e.isoDay, e.isoHour, e.isoMinute, e.isoSecond, e.isoMillisecond);\n}\n\nfunction isoToEpochNano(e) {\n  const n = isoToEpochMilli(e);\n  if (void 0 !== n) {\n    const [t, o] = divModTrunc(n, ko);\n    return [ t, o * Qe + (e.isoMicrosecond || 0) * Yo + (e.isoNanosecond || 0) ];\n  }\n}\n\nfunction isoToEpochNanoWithOffset(e, n) {\n  const [t, o] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e) - n);\n  return checkEpochNanoInBounds(isoToEpochNano({\n    ...e,\n    isoDay: e.isoDay + o,\n    ...t\n  }));\n}\n\nfunction isoArgsToEpochSec(...e) {\n  return isoArgsToEpochMilli(...e) / Co;\n}\n\nfunction isoArgsToEpochMilli(...e) {\n  const [n, t] = isoToLegacyDate(...e), o = n.valueOf();\n  if (!isNaN(o)) {\n    return o - t * ko;\n  }\n}\n\nfunction isoToLegacyDate(e, n = 1, t = 1, o = 0, r = 0, i = 0, a = 0) {\n  const s = e === wr ? 1 : e === Fr ? -1 : 0, c = new Date;\n  return c.setUTCHours(o, r, i, a), c.setUTCFullYear(e, n - 1, t + s), [ c, s ];\n}\n\nfunction epochNanoToIso(e, n) {\n  let [t, o] = moveBigNano(e, n);\n  o < 0 && (o += Uo, t -= 1);\n  const [r, i] = divModFloor(o, Qe), [a, s] = divModFloor(i, Yo);\n  return epochMilliToIso(t * ko + r, a, s);\n}\n\nfunction epochMilliToIso(e, n = 0, t = 0) {\n  const o = Math.ceil(Math.max(0, Math.abs(e) - Pr) / ko) * Math.sign(e), r = new Date(e - o * ko);\n  return zipProps(Tr, [ r.getUTCFullYear(), r.getUTCMonth() + 1, r.getUTCDate() + o, r.getUTCHours(), r.getUTCMinutes(), r.getUTCSeconds(), r.getUTCMilliseconds(), n, t ]);\n}\n\nfunction hashIntlFormatParts(e, n) {\n  if (n < -Pr) {\n    throw new RangeError(Io);\n  }\n  const t = e.formatToParts(n), o = {};\n  for (const e of t) {\n    o[e.type] = e.value;\n  }\n  return o;\n}\n\nfunction computeIsoDateParts(e) {\n  return [ e.isoYear, e.isoMonth, e.isoDay ];\n}\n\nfunction computeIsoMonthCodeParts(e, n) {\n  return [ n, 0 ];\n}\n\nfunction computeIsoMonthsInYear() {\n  return kr;\n}\n\nfunction computeIsoDaysInMonth(e, n) {\n  switch (n) {\n   case 2:\n    return computeIsoInLeapYear(e) ? 29 : 28;\n\n   case 4:\n   case 6:\n   case 9:\n   case 11:\n    return 30;\n  }\n  return 31;\n}\n\nfunction computeIsoDaysInYear(e) {\n  return computeIsoInLeapYear(e) ? 366 : 365;\n}\n\nfunction computeIsoInLeapYear(e) {\n  return e % 4 == 0 && (e % 100 != 0 || e % 400 == 0);\n}\n\nfunction computeIsoDayOfWeek(e) {\n  const [n, t] = isoToLegacyDate(e.isoYear, e.isoMonth, e.isoDay);\n  return modFloor(n.getUTCDay() - t, 7) || 7;\n}\n\nfunction computeIsoEraParts(e) {\n  return this.id === or ? (({isoYear: e}) => e < 1 ? [ \"gregory-inverse\", 1 - e ] : [ \"gregory\", e ])(e) : this.id === rr ? Yr(e) : [];\n}\n\nfunction computeJapaneseEraParts(e) {\n  const n = isoToEpochMilli(e);\n  if (n < Cr) {\n    const {isoYear: n} = e;\n    return n < 1 ? [ \"japanese-inverse\", 1 - n ] : [ \"japanese\", n ];\n  }\n  const t = hashIntlFormatParts(Ci(rr), n), {era: o, eraYear: r} = parseIntlYear(t, rr);\n  return [ o, r ];\n}\n\nfunction checkIsoDateTimeFields(e) {\n  return checkIsoDateFields(e), constrainIsoTimeFields(e, 1), e;\n}\n\nfunction checkIsoDateFields(e) {\n  return constrainIsoDateFields(e, 1), e;\n}\n\nfunction isIsoDateFieldsValid(e) {\n  return allPropsEqual(Dr, e, constrainIsoDateFields(e));\n}\n\nfunction constrainIsoDateFields(e, n) {\n  const {isoYear: t} = e, o = clampProp(e, \"isoMonth\", 1, computeIsoMonthsInYear(), n);\n  return {\n    isoYear: t,\n    isoMonth: o,\n    isoDay: clampProp(e, \"isoDay\", 1, computeIsoDaysInMonth(t, o), n)\n  };\n}\n\nfunction constrainIsoTimeFields(e, n) {\n  return zipProps(w, [ clampProp(e, \"isoHour\", 0, 23, n), clampProp(e, \"isoMinute\", 0, 59, n), clampProp(e, \"isoSecond\", 0, 59, n), clampProp(e, \"isoMillisecond\", 0, 999, n), clampProp(e, \"isoMicrosecond\", 0, 999, n), clampProp(e, \"isoNanosecond\", 0, 999, n) ]);\n}\n\nfunction mt(e) {\n  return void 0 === e ? 0 : Xr(requireObjectLike(e));\n}\n\nfunction je(e, n = 0) {\n  e = normalizeOptions(e);\n  const t = ei(e), o = ni(e, n);\n  return [ Xr(e), o, t ];\n}\n\nfunction refineDiffOptions(e, n, t, o = 9, r = 0, i = 4) {\n  n = normalizeOptions(n);\n  let a = Kr(n, o, r), s = parseRoundingIncInteger(n), c = ii(n, i);\n  const u = Jr(n, o, r, 1);\n  return null == a ? a = Math.max(t, u) : checkLargestSmallestUnit(a, u), s = refineRoundingInc(s, u, 1), \n  e && (c = (e => e < 4 ? (e + 2) % 4 : e)(c)), [ a, u, s, c ];\n}\n\nfunction refineRoundingOptions(e, n = 6, t) {\n  let o = parseRoundingIncInteger(e = normalizeOptionsOrString(e, Rr));\n  const r = ii(e, 7);\n  let i = Jr(e, n);\n  return i = requirePropDefined(Rr, i), o = refineRoundingInc(o, i, void 0, t), [ i, o, r ];\n}\n\nfunction refineDateDisplayOptions(e) {\n  return ti(normalizeOptions(e));\n}\n\nfunction refineTimeDisplayOptions(e, n) {\n  return refineTimeDisplayTuple(normalizeOptions(e), n);\n}\n\nfunction Me(e) {\n  const n = normalizeOptionsOrString(e, qr), t = refineChoiceOption(qr, _r, n, 0);\n  if (!t) {\n    throw new RangeError(invalidEntity(qr, t));\n  }\n  return t;\n}\n\nfunction refineTimeDisplayTuple(e, n = 4) {\n  const t = refineSubsecDigits(e);\n  return [ ii(e, 4), ...refineSmallestUnitAndSubsecDigits(Jr(e, n), t) ];\n}\n\nfunction refineSmallestUnitAndSubsecDigits(e, n) {\n  return null != e ? [ Ao[e], e < 4 ? 9 - 3 * e : -1 ] : [ void 0 === n ? 1 : 10 ** (9 - n), n ];\n}\n\nfunction parseRoundingIncInteger(e) {\n  const n = e[zr];\n  return void 0 === n ? 1 : toInteger(n, zr);\n}\n\nfunction refineRoundingInc(e, n, t, o) {\n  const r = o ? Uo : Ao[n + 1];\n  if (r) {\n    const t = Ao[n];\n    if (r % ((e = clampEntity(zr, e, 1, r / t - (o ? 0 : 1), 1)) * t)) {\n      throw new RangeError(invalidEntity(zr, e));\n    }\n  } else {\n    e = clampEntity(zr, e, 1, t ? 10 ** 9 : 1, 1);\n  }\n  return e;\n}\n\nfunction refineSubsecDigits(e) {\n  let n = e[Ur];\n  if (void 0 !== n) {\n    if (\"number\" != typeof n) {\n      if (\"auto\" === toString(n)) {\n        return;\n      }\n      throw new RangeError(invalidEntity(Ur, n));\n    }\n    n = clampEntity(Ur, Math.floor(n), 0, 9, 1);\n  }\n  return n;\n}\n\nfunction normalizeOptions(e) {\n  return void 0 === e ? {} : requireObjectLike(e);\n}\n\nfunction normalizeOptionsOrString(e, n) {\n  return \"string\" == typeof e ? {\n    [n]: e\n  } : requireObjectLike(e);\n}\n\nfunction fabricateOverflowOptions(e) {\n  return {\n    overflow: jr[e]\n  };\n}\n\nfunction refineUnitOption(e, n, t = 9, o = 0, r) {\n  let i = n[e];\n  if (void 0 === i) {\n    return r ? o : void 0;\n  }\n  if (i = toString(i), \"auto\" === i) {\n    return r ? o : null;\n  }\n  let a = Oo[i];\n  if (void 0 === a && (a = mr[i]), void 0 === a) {\n    throw new RangeError(invalidChoice(e, i, Oo));\n  }\n  return clampEntity(e, a, o, t, 1, Bo), a;\n}\n\nfunction refineChoiceOption(e, n, t, o = 0) {\n  const r = t[e];\n  if (void 0 === r) {\n    return o;\n  }\n  const i = toString(r), a = n[i];\n  if (void 0 === a) {\n    throw new RangeError(invalidChoice(e, i, n));\n  }\n  return a;\n}\n\nfunction checkLargestSmallestUnit(e, n) {\n  if (n > e) {\n    throw new RangeError(Eo);\n  }\n}\n\nfunction xe(e) {\n  return {\n    branding: Re,\n    epochNanoseconds: e\n  };\n}\n\nfunction _e(e, n, t) {\n  return {\n    branding: z,\n    calendar: t,\n    timeZone: n,\n    epochNanoseconds: e\n  };\n}\n\nfunction jt(e, n = e.calendar) {\n  return {\n    branding: x,\n    calendar: n,\n    ...nn(Nr, e)\n  };\n}\n\nfunction W(e, n = e.calendar) {\n  return {\n    branding: G,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction createPlainYearMonthSlots(e, n = e.calendar) {\n  return {\n    branding: Ut,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction createPlainMonthDaySlots(e, n = e.calendar) {\n  return {\n    branding: qt,\n    calendar: n,\n    ...nn(Ir, e)\n  };\n}\n\nfunction St(e) {\n  return {\n    branding: ft,\n    ...nn(Mr, e)\n  };\n}\n\nfunction Oe(e) {\n  return {\n    branding: N,\n    sign: computeDurationSign(e),\n    ...nn(ur, e)\n  };\n}\n\nfunction I(e) {\n  return divModBigNano(e.epochNanoseconds, Qe)[0];\n}\n\nfunction v(e) {\n  return ((e, n = 1) => {\n    const [t, o] = e, r = Math.floor(o / n), i = Uo / n;\n    return BigInt(t) * BigInt(i) + BigInt(r);\n  })(e.epochNanoseconds);\n}\n\nfunction extractEpochNano(e) {\n  return e.epochNanoseconds;\n}\n\nfunction J(e, n, t, o, r) {\n  const i = getMaxDurationUnit(o), [a, s] = ((e, n) => {\n    const t = n((e = normalizeOptionsOrString(e, Zr))[Ar]);\n    let o = Qr(e);\n    return o = requirePropDefined(Zr, o), [ o, t ];\n  })(r, e), c = Math.max(a, i);\n  if (!s && isUniformUnit(c, s)) {\n    return totalDayTimeDuration(o, a);\n  }\n  if (!s) {\n    throw new RangeError(yo);\n  }\n  if (!o.sign) {\n    return 0;\n  }\n  const [u, f, l] = createMarkerSystem(n, t, s), d = createMarkerToEpochNano(l), m = createMoveMarker(l), h = createDiffMarkers(l), g = m(f, u, o);\n  isZonedEpochSlots(s) || (checkIsoDateTimeInBounds(u), checkIsoDateTimeInBounds(g));\n  const D = h(f, u, g, a);\n  return isUniformUnit(a, s) ? totalDayTimeDuration(D, a) : ((e, n, t, o, r, i, a) => {\n    const s = computeDurationSign(e), [c, u] = clampRelativeDuration(o, gr(t, e), t, s, r, i, a), f = computeEpochNanoFrac(n, c, u);\n    return e[p[t]] + f * s;\n  })(D, d(g), a, f, u, d, m);\n}\n\nfunction totalDayTimeDuration(e, n) {\n  return bigNanoToNumber(durationFieldsToBigNano(e), Ao[n], 1);\n}\n\nfunction clampRelativeDuration(e, n, t, o, r, i, a) {\n  const s = p[t], c = {\n    ...n,\n    [s]: n[s] + o\n  }, u = a(e, r, n), f = a(e, r, c);\n  return [ i(u), i(f) ];\n}\n\nfunction computeEpochNanoFrac(e, n, t) {\n  const o = bigNanoToNumber(diffBigNanos(n, t));\n  if (!o) {\n    throw new RangeError(fo);\n  }\n  return bigNanoToNumber(diffBigNanos(n, e)) / o;\n}\n\nfunction Le(e, n) {\n  const [t, o, r] = refineRoundingOptions(n, 5, 1);\n  return xe(roundBigNano(e.epochNanoseconds, t, o, r, 1));\n}\n\nfunction Ie(e, n, t) {\n  let {epochNanoseconds: o, timeZone: r, calendar: i} = n;\n  const [a, s, c] = refineRoundingOptions(t);\n  if (0 === a && 1 === s) {\n    return n;\n  }\n  const u = e(r);\n  if (6 === a) {\n    o = ((e, n, t, o) => {\n      const r = he(t, n), [i, a] = e(r), s = t.epochNanoseconds, c = getStartOfDayInstantFor(n, i), u = getStartOfDayInstantFor(n, a);\n      if (bigNanoOutside(s, c, u)) {\n        throw new RangeError(fo);\n      }\n      return roundWithMode(computeEpochNanoFrac(s, c, u), o) ? u : c;\n    })(computeDayInterval, u, n, c);\n  } else {\n    const e = u.R(o);\n    o = getMatchingInstantFor(u, roundDateTime(epochNanoToIso(o, e), a, s, c), e, 2, 0, 1);\n  }\n  return _e(o, r, i);\n}\n\nfunction vt(e, n) {\n  return jt(roundDateTime(e, ...refineRoundingOptions(n)), e.calendar);\n}\n\nfunction lt(e, n) {\n  const [t, o, r] = refineRoundingOptions(n, 5);\n  var i;\n  return St((i = r, roundTimeToNano(e, computeNanoInc(t, o), i)[0]));\n}\n\nfunction Te(e, n) {\n  const t = e(n.timeZone), o = he(n, t), [r, i] = computeDayInterval(o), a = bigNanoToNumber(diffBigNanos(getStartOfDayInstantFor(t, r), getStartOfDayInstantFor(t, i)), zo, 1);\n  if (a <= 0) {\n    throw new RangeError(fo);\n  }\n  return a;\n}\n\nfunction ve(e, n) {\n  const {timeZone: t, calendar: o} = n, r = ((e, n, t) => getStartOfDayInstantFor(n, e(he(t, n))))(computeDayFloor, e(t), n);\n  return _e(r, t, o);\n}\n\nfunction roundDateTime(e, n, t, o) {\n  return roundDateTimeToNano(e, computeNanoInc(n, t), o);\n}\n\nfunction roundDateTimeToNano(e, n, t) {\n  const [o, r] = roundTimeToNano(e, n, t);\n  return checkIsoDateTimeInBounds({\n    ...moveByDays(e, r),\n    ...o\n  });\n}\n\nfunction roundTimeToNano(e, n, t) {\n  return nanoToIsoTimeAndDay(roundByInc(isoTimeFieldsToNano(e), n, t));\n}\n\nfunction roundToMinute(e) {\n  return roundByInc(e, Zo, 7);\n}\n\nfunction computeNanoInc(e, n) {\n  return Ao[e] * n;\n}\n\nfunction computeDayInterval(e) {\n  const n = computeDayFloor(e);\n  return [ n, moveByDays(n, 1) ];\n}\n\nfunction computeDayFloor(e) {\n  return yr(6, e);\n}\n\nfunction roundDayTimeDurationByInc(e, n, t) {\n  const o = Math.min(getMaxDurationUnit(e), 6);\n  return nanoToDurationDayTimeFields(roundBigNanoByInc(durationFieldsToBigNano(e, o), n, t), o);\n}\n\nfunction roundRelativeDuration(e, n, t, o, r, i, a, s, c, u) {\n  if (0 === o && 1 === r) {\n    return e;\n  }\n  const f = isUniformUnit(o, s) ? isZonedEpochSlots(s) && o < 6 && t >= 6 ? nudgeZonedTimeDuration : nudgeDayTimeDuration : nudgeRelativeDuration;\n  let [l, d, m] = f(e, n, t, o, r, i, a, s, c, u);\n  return m && 7 !== o && (l = ((e, n, t, o, r, i, a, s) => {\n    const c = computeDurationSign(e);\n    for (let u = o + 1; u <= t; u++) {\n      if (7 === u && 7 !== t) {\n        continue;\n      }\n      const o = gr(u, e);\n      o[p[u]] += c;\n      const f = bigNanoToNumber(diffBigNanos(a(s(r, i, o)), n));\n      if (f && Math.sign(f) !== c) {\n        break;\n      }\n      e = o;\n    }\n    return e;\n  })(l, d, t, Math.max(6, o), a, s, c, u)), l;\n}\n\nfunction roundBigNano(e, n, t, o, r) {\n  if (6 === n) {\n    const n = (e => e[0] + e[1] / Uo)(e);\n    return [ roundByInc(n, t, o), 0 ];\n  }\n  return roundBigNanoByInc(e, computeNanoInc(n, t), o, r);\n}\n\nfunction roundBigNanoByInc(e, n, t, o) {\n  let [r, i] = e;\n  o && i < 0 && (i += Uo, r -= 1);\n  const [a, s] = divModFloor(roundByInc(i, n, t), Uo);\n  return createBigNano(r + a, s);\n}\n\nfunction roundByInc(e, n, t) {\n  return roundWithMode(e / n, t) * n;\n}\n\nfunction roundWithMode(e, n) {\n  return ai[n](e);\n}\n\nfunction nudgeDayTimeDuration(e, n, t, o, r, i) {\n  const a = computeDurationSign(e), s = durationFieldsToBigNano(e), c = roundBigNano(s, o, r, i), u = diffBigNanos(s, c), f = Math.sign(c[0] - s[0]) === a, l = nanoToDurationDayTimeFields(c, Math.min(t, 6));\n  return [ {\n    ...e,\n    ...l\n  }, addBigNanos(n, u), f ];\n}\n\nfunction nudgeZonedTimeDuration(e, n, t, o, r, i, a, s, c, u) {\n  const f = computeDurationSign(e) || 1, l = bigNanoToNumber(durationFieldsToBigNano(e, 5)), d = computeNanoInc(o, r);\n  let m = roundByInc(l, d, i);\n  const [p, h] = clampRelativeDuration(a, {\n    ...e,\n    ...hr\n  }, 6, f, s, c, u), g = m - bigNanoToNumber(diffBigNanos(p, h));\n  let D = 0;\n  g && Math.sign(g) !== f ? n = moveBigNano(p, m) : (D += f, m = roundByInc(g, d, i), \n  n = moveBigNano(h, m));\n  const T = nanoToDurationTimeFields(m);\n  return [ {\n    ...e,\n    ...T,\n    days: e.days + D\n  }, n, Boolean(D) ];\n}\n\nfunction nudgeRelativeDuration(e, n, t, o, r, i, a, s, c, u) {\n  const f = computeDurationSign(e), l = p[o], d = gr(o, e);\n  7 === o && (e = {\n    ...e,\n    weeks: e.weeks + Math.trunc(e.days / 7)\n  });\n  const m = divTrunc(e[l], r) * r;\n  d[l] = m;\n  const [h, g] = clampRelativeDuration(a, d, o, r * f, s, c, u), D = m + computeEpochNanoFrac(n, h, g) * f * r, T = roundByInc(D, r, i), I = Math.sign(T - D) === f;\n  return d[l] = T, [ d, I ? g : h, I ];\n}\n\nfunction ke(e, n, t, o) {\n  const [r, i, a, s] = (e => {\n    const n = refineTimeDisplayTuple(e = normalizeOptions(e));\n    return [ e.timeZone, ...n ];\n  })(o), c = void 0 !== r;\n  return ((e, n, t, o, r, i) => {\n    t = roundBigNanoByInc(t, r, o, 1);\n    const a = n.R(t);\n    return formatIsoDateTimeFields(epochNanoToIso(t, a), i) + (e ? Se(roundToMinute(a)) : \"Z\");\n  })(c, n(c ? e(r) : si), t.epochNanoseconds, i, a, s);\n}\n\nfunction Fe(e, n, t) {\n  const [o, r, i, a, s, c] = (e => {\n    e = normalizeOptions(e);\n    const n = ti(e), t = refineSubsecDigits(e), o = ri(e), r = ii(e, 4), i = Jr(e, 4);\n    return [ n, oi(e), o, r, ...refineSmallestUnitAndSubsecDigits(i, t) ];\n  })(t);\n  return ((e, n, t, o, r, i, a, s, c, u) => {\n    o = roundBigNanoByInc(o, c, s, 1);\n    const f = e(t).R(o);\n    return formatIsoDateTimeFields(epochNanoToIso(o, f), u) + Se(roundToMinute(f), a) + ((e, n) => 1 !== n ? \"[\" + (2 === n ? \"!\" : \"\") + e + \"]\" : \"\")(t, i) + formatCalendar(n, r);\n  })(e, n.calendar, n.timeZone, n.epochNanoseconds, o, r, i, a, s, c);\n}\n\nfunction Ft(e, n) {\n  const [t, o, r, i] = (e => (e = normalizeOptions(e), [ ti(e), ...refineTimeDisplayTuple(e) ]))(n);\n  return a = e.calendar, s = t, c = i, formatIsoDateTimeFields(roundDateTimeToNano(e, r, o), c) + formatCalendar(a, s);\n  var a, s, c;\n}\n\nfunction ce(e, n) {\n  return t = e.calendar, o = e, r = refineDateDisplayOptions(n), formatIsoDateFields(o) + formatCalendar(t, r);\n  var t, o, r;\n}\n\nfunction Kt(e, n) {\n  return formatDateLikeIso(e.calendar, formatIsoYearMonthFields, e, refineDateDisplayOptions(n));\n}\n\nfunction Jt(e, n) {\n  return formatDateLikeIso(e.calendar, formatIsoMonthDayFields, e, refineDateDisplayOptions(n));\n}\n\nfunction ct(e, n) {\n  const [t, o, r] = refineTimeDisplayOptions(n);\n  return i = r, formatIsoTimeFields(roundTimeToNano(e, o, t)[0], i);\n  var i;\n}\n\nfunction k(e, n) {\n  const [t, o, r] = refineTimeDisplayOptions(n, 3);\n  return o > 1 && checkDurationUnits(e = {\n    ...e,\n    ...roundDayTimeDurationByInc(e, o, t)\n  }), ((e, n) => {\n    const {sign: t} = e, o = -1 === t ? negateDurationFields(e) : e, {hours: r, minutes: i} = o, [a, s] = divModBigNano(durationFieldsToBigNano(o, 3), Ro, divModTrunc);\n    checkDurationTimeUnit(a);\n    const c = formatSubsecNano(s, n), u = n >= 0 || !t || c;\n    return (t < 0 ? \"-\" : \"\") + \"P\" + formatDurationFragments({\n      Y: formatDurationNumber(o.years),\n      M: formatDurationNumber(o.months),\n      W: formatDurationNumber(o.weeks),\n      D: formatDurationNumber(o.days)\n    }) + (r || i || a || u ? \"T\" + formatDurationFragments({\n      H: formatDurationNumber(r),\n      M: formatDurationNumber(i),\n      S: formatDurationNumber(a, u) + c\n    }) : \"\");\n  })(e, r);\n}\n\nfunction formatDateLikeIso(e, n, t, o) {\n  const r = o > 1 || 0 === o && e !== l;\n  return 1 === o ? e === l ? n(t) : formatIsoDateFields(t) : r ? formatIsoDateFields(t) + formatCalendarId(e, 2 === o) : n(t);\n}\n\nfunction formatDurationFragments(e) {\n  const n = [];\n  for (const t in e) {\n    const o = e[t];\n    o && n.push(o, t);\n  }\n  return n.join(\"\");\n}\n\nfunction formatIsoDateTimeFields(e, n) {\n  return formatIsoDateFields(e) + \"T\" + formatIsoTimeFields(e, n);\n}\n\nfunction formatIsoDateFields(e) {\n  return formatIsoYearMonthFields(e) + \"-\" + bo(e.isoDay);\n}\n\nfunction formatIsoYearMonthFields(e) {\n  const {isoYear: n} = e;\n  return (n < 0 || n > 9999 ? getSignStr(n) + padNumber(6, Math.abs(n)) : padNumber(4, n)) + \"-\" + bo(e.isoMonth);\n}\n\nfunction formatIsoMonthDayFields(e) {\n  return bo(e.isoMonth) + \"-\" + bo(e.isoDay);\n}\n\nfunction formatIsoTimeFields(e, n) {\n  const t = [ bo(e.isoHour), bo(e.isoMinute) ];\n  return -1 !== n && t.push(bo(e.isoSecond) + ((e, n, t, o) => formatSubsecNano(e * Qe + n * Yo + t, o))(e.isoMillisecond, e.isoMicrosecond, e.isoNanosecond, n)), \n  t.join(\":\");\n}\n\nfunction Se(e, n = 0) {\n  if (1 === n) {\n    return \"\";\n  }\n  const [t, o] = divModFloor(Math.abs(e), zo), [r, i] = divModFloor(o, Zo), [a, s] = divModFloor(i, Ro);\n  return getSignStr(e) + bo(t) + \":\" + bo(r) + (a || s ? \":\" + bo(a) + formatSubsecNano(s) : \"\");\n}\n\nfunction formatCalendar(e, n) {\n  return 1 !== n && (n > 1 || 0 === n && e !== l) ? formatCalendarId(e, 2 === n) : \"\";\n}\n\nfunction formatCalendarId(e, n) {\n  return \"[\" + (n ? \"!\" : \"\") + \"u-ca=\" + e + \"]\";\n}\n\nfunction formatSubsecNano(e, n) {\n  let t = padNumber(9, e);\n  return t = void 0 === n ? t.replace(li, \"\") : t.slice(0, n), t ? \".\" + t : \"\";\n}\n\nfunction getSignStr(e) {\n  return e < 0 ? \"-\" : \"+\";\n}\n\nfunction formatDurationNumber(e, n) {\n  return e || n ? e.toLocaleString(\"fullwide\", {\n    useGrouping: 0\n  }) : \"\";\n}\n\nfunction _zonedEpochSlotsToIso(e, n) {\n  const {epochNanoseconds: t} = e, o = (n.R ? n : n(e.timeZone)).R(t), r = epochNanoToIso(t, o);\n  return {\n    calendar: e.calendar,\n    ...r,\n    offsetNanoseconds: o\n  };\n}\n\nfunction getMatchingInstantFor(e, n, t, o = 0, r = 0, i, a) {\n  if (void 0 !== t && 1 === o && (1 === o || a)) {\n    return isoToEpochNanoWithOffset(n, t);\n  }\n  const s = e.I(n);\n  if (void 0 !== t && 3 !== o) {\n    const e = ((e, n, t, o) => {\n      const r = isoToEpochNano(n);\n      o && (t = roundToMinute(t));\n      for (const n of e) {\n        let e = bigNanoToNumber(diffBigNanos(n, r));\n        if (o && (e = roundToMinute(e)), e === t) {\n          return n;\n        }\n      }\n    })(s, n, t, i);\n    if (void 0 !== e) {\n      return e;\n    }\n    if (0 === o) {\n      throw new RangeError(Do);\n    }\n  }\n  return a ? isoToEpochNano(n) : getSingleInstantFor(e, n, r, s);\n}\n\nfunction getSingleInstantFor(e, n, t = 0, o = e.I(n)) {\n  if (1 === o.length) {\n    return o[0];\n  }\n  if (1 === t) {\n    throw new RangeError(To);\n  }\n  if (o.length) {\n    return o[3 === t ? 1 : 0];\n  }\n  const r = isoToEpochNano(n), i = ((e, n) => {\n    const t = e.R(moveBigNano(n, -Uo));\n    return (e => {\n      if (e > Uo) {\n        throw new RangeError(go);\n      }\n      return e;\n    })(e.R(moveBigNano(n, Uo)) - t);\n  })(e, r), a = i * (2 === t ? -1 : 1);\n  return (o = e.I(epochNanoToIso(r, a)))[2 === t ? 0 : o.length - 1];\n}\n\nfunction getStartOfDayInstantFor(e, n) {\n  const t = e.I(n);\n  if (t.length) {\n    return t[0];\n  }\n  const o = moveBigNano(isoToEpochNano(n), -Uo);\n  return e.O(o, 1);\n}\n\nfunction Ye(e, n, t) {\n  return xe(checkEpochNanoInBounds(addBigNanos(n.epochNanoseconds, (e => {\n    if (durationHasDateParts(e)) {\n      throw new RangeError(vo);\n    }\n    return durationFieldsToBigNano(e, 5);\n  })(e ? negateDurationFields(t) : t))));\n}\n\nfunction pe(e, n, t, o, r, i = Object.create(null)) {\n  const a = n(o.timeZone), s = e(o.calendar);\n  return {\n    ...o,\n    ...moveZonedEpochs(a, s, o, t ? negateDurationFields(r) : r, i)\n  };\n}\n\nfunction wt(e, n, t, o, r = Object.create(null)) {\n  const {calendar: i} = t;\n  return jt(moveDateTime(e(i), t, n ? negateDurationFields(o) : o, r), i);\n}\n\nfunction ne(e, n, t, o, r) {\n  const {calendar: i} = t;\n  return W(moveDate(e(i), t, n ? negateDurationFields(o) : o, r), i);\n}\n\nfunction Gt(e, n, t, o, r) {\n  const i = t.calendar, a = e(i);\n  let s = checkIsoDateInBounds(moveToDayOfMonthUnsafe(a, t));\n  n && (o = B(o)), o.sign < 0 && (s = a.P(s, {\n    ...pr,\n    months: 1\n  }), s = moveByDays(s, -1));\n  const c = a.P(s, o, r);\n  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(a, c), i);\n}\n\nfunction at(e, n, t) {\n  return St(moveTime(n, e ? negateDurationFields(t) : t)[0]);\n}\n\nfunction moveZonedEpochs(e, n, t, o, r) {\n  const i = durationFieldsToBigNano(o, 5);\n  let a = t.epochNanoseconds;\n  if (durationHasDateParts(o)) {\n    const s = he(t, e);\n    a = addBigNanos(getSingleInstantFor(e, {\n      ...moveDate(n, s, {\n        ...o,\n        ...hr\n      }, r),\n      ...nn(w, s)\n    }), i);\n  } else {\n    a = addBigNanos(a, i), mt(r);\n  }\n  return {\n    epochNanoseconds: checkEpochNanoInBounds(a)\n  };\n}\n\nfunction moveDateTime(e, n, t, o) {\n  const [r, i] = moveTime(n, t);\n  return checkIsoDateTimeInBounds({\n    ...moveDate(e, n, {\n      ...t,\n      ...hr,\n      days: t.days + i\n    }, o),\n    ...r\n  });\n}\n\nfunction moveDate(e, n, t, o) {\n  if (t.years || t.months || t.weeks) {\n    return e.P(n, t, o);\n  }\n  mt(o);\n  const r = t.days + durationFieldsToBigNano(t, 5)[0];\n  return r ? checkIsoDateInBounds(moveByDays(n, r)) : n;\n}\n\nfunction moveToDayOfMonthUnsafe(e, n, t = 1) {\n  return moveByDays(n, t - e.day(n));\n}\n\nfunction moveTime(e, n) {\n  const [t, o] = durationFieldsToBigNano(n, 5), [r, i] = nanoToIsoTimeAndDay(isoTimeFieldsToNano(e) + o);\n  return [ r, t + i ];\n}\n\nfunction moveByDays(e, n) {\n  return n ? {\n    ...e,\n    ...epochMilliToIso(isoToEpochMilli(e) + n * ko)\n  } : e;\n}\n\nfunction createMarkerSystem(e, n, t) {\n  const o = e(t.calendar);\n  return isZonedEpochSlots(t) ? [ t, o, n(t.timeZone) ] : [ {\n    ...t,\n    ...Nt\n  }, o ];\n}\n\nfunction createMarkerToEpochNano(e) {\n  return e ? extractEpochNano : isoToEpochNano;\n}\n\nfunction createMoveMarker(e) {\n  return e ? Pt(moveZonedEpochs, e) : moveDateTime;\n}\n\nfunction createDiffMarkers(e) {\n  return e ? Pt(diffZonedEpochsExact, e) : diffDateTimesExact;\n}\n\nfunction isZonedEpochSlots(e) {\n  return e && e.epochNanoseconds;\n}\n\nfunction isUniformUnit(e, n) {\n  return e <= 6 - (isZonedEpochSlots(n) ? 1 : 0);\n}\n\nfunction E(e, n, t, o, r, i, a) {\n  const s = e(normalizeOptions(a).relativeTo), c = Math.max(getMaxDurationUnit(r), getMaxDurationUnit(i));\n  if (isUniformUnit(c, s)) {\n    return Oe(checkDurationUnits(((e, n, t, o) => {\n      const r = addBigNanos(durationFieldsToBigNano(e), durationFieldsToBigNano(n), o ? -1 : 1);\n      if (!Number.isFinite(r[0])) {\n        throw new RangeError(Io);\n      }\n      return {\n        ...pr,\n        ...nanoToDurationDayTimeFields(r, t)\n      };\n    })(r, i, c, o)));\n  }\n  if (!s) {\n    throw new RangeError(yo);\n  }\n  o && (i = negateDurationFields(i));\n  const [u, f, l] = createMarkerSystem(n, t, s), d = createMoveMarker(l), m = createDiffMarkers(l), p = d(f, u, r);\n  return Oe(m(f, u, d(f, p, i), c));\n}\n\nfunction V(e, n, t, o, r) {\n  const i = getMaxDurationUnit(o), [a, s, c, u, f] = ((e, n, t) => {\n    e = normalizeOptionsOrString(e, Rr);\n    let o = Kr(e);\n    const r = t(e[Ar]);\n    let i = parseRoundingIncInteger(e);\n    const a = ii(e, 7);\n    let s = Jr(e);\n    if (void 0 === o && void 0 === s) {\n      throw new RangeError(Po);\n    }\n    if (null == s && (s = 0), null == o && (o = Math.max(s, n)), checkLargestSmallestUnit(o, s), \n    i = refineRoundingInc(i, s, 1), i > 1 && s > 5 && o !== s) {\n      throw new RangeError(\"For calendar units with roundingIncrement > 1, use largestUnit = smallestUnit\");\n    }\n    return [ o, s, i, a, r ];\n  })(r, i, e), l = Math.max(i, a);\n  if (!f && l <= 6) {\n    return Oe(checkDurationUnits(((e, n, t, o, r) => {\n      const i = roundBigNano(durationFieldsToBigNano(e), t, o, r);\n      return {\n        ...pr,\n        ...nanoToDurationDayTimeFields(i, n)\n      };\n    })(o, a, s, c, u)));\n  }\n  if (!isZonedEpochSlots(f) && !o.sign) {\n    return o;\n  }\n  if (!f) {\n    throw new RangeError(yo);\n  }\n  const [d, m, p] = createMarkerSystem(n, t, f), h = createMarkerToEpochNano(p), g = createMoveMarker(p), D = createDiffMarkers(p), T = g(m, d, o);\n  isZonedEpochSlots(f) || (checkIsoDateTimeInBounds(d), checkIsoDateTimeInBounds(T));\n  let I = D(m, d, T, a);\n  const M = o.sign, N = computeDurationSign(I);\n  if (M && N && M !== N) {\n    throw new RangeError(fo);\n  }\n  return I = roundRelativeDuration(I, h(T), a, s, c, u, m, d, h, g), Oe(I);\n}\n\nfunction Y(e) {\n  return -1 === e.sign ? B(e) : e;\n}\n\nfunction B(e) {\n  return Oe(negateDurationFields(e));\n}\n\nfunction negateDurationFields(e) {\n  const n = {};\n  for (const t of p) {\n    n[t] = -1 * e[t] || 0;\n  }\n  return n;\n}\n\nfunction y(e) {\n  return !e.sign;\n}\n\nfunction computeDurationSign(e, n = p) {\n  let t = 0;\n  for (const o of n) {\n    const n = Math.sign(e[o]);\n    if (n) {\n      if (t && t !== n) {\n        throw new RangeError(No);\n      }\n      t = n;\n    }\n  }\n  return t;\n}\n\nfunction checkDurationUnits(e) {\n  for (const n of dr) {\n    clampEntity(n, e[n], -di, di, 1);\n  }\n  return checkDurationTimeUnit(bigNanoToNumber(durationFieldsToBigNano(e), Ro)), e;\n}\n\nfunction checkDurationTimeUnit(e) {\n  if (!Number.isSafeInteger(e)) {\n    throw new RangeError(Mo);\n  }\n}\n\nfunction durationFieldsToBigNano(e, n = 6) {\n  return givenFieldsToBigNano(e, n, p);\n}\n\nfunction nanoToDurationDayTimeFields(e, n = 6) {\n  const [t, o] = e, r = nanoToGivenFields(o, n, p);\n  if (r[p[n]] += t * (Uo / Ao[n]), !Number.isFinite(r[p[n]])) {\n    throw new RangeError(Io);\n  }\n  return r;\n}\n\nfunction nanoToDurationTimeFields(e, n = 5) {\n  return nanoToGivenFields(e, n, p);\n}\n\nfunction durationHasDateParts(e) {\n  return Boolean(computeDurationSign(e, lr));\n}\n\nfunction getMaxDurationUnit(e) {\n  let n = 9;\n  for (;n > 0 && !e[p[n]]; n--) {}\n  return n;\n}\n\nfunction createSplitTuple(e, n) {\n  return [ e, n ];\n}\n\nfunction computePeriod(e) {\n  const n = Math.floor(e / ci) * ci;\n  return [ n, n + ci ];\n}\n\nfunction We(e) {\n  const n = parseDateTimeLike(e = toStringViaPrimitive(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  let t;\n  if (n.j) {\n    t = 0;\n  } else {\n    if (!n.offset) {\n      throw new RangeError(failedParse(e));\n    }\n    t = parseOffsetNano(n.offset);\n  }\n  return n.timeZone && parseOffsetNanoMaybe(n.timeZone, 1), xe(isoToEpochNanoWithOffset(checkIsoDateTimeFields(n), t));\n}\n\nfunction H(e) {\n  const n = parseDateTimeLike(m(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  if (n.timeZone) {\n    return finalizeZonedDateTime(n, n.offset ? parseOffsetNano(n.offset) : void 0);\n  }\n  if (n.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return finalizeDate(n);\n}\n\nfunction Ae(e, n) {\n  const t = parseDateTimeLike(m(e));\n  if (!t || !t.timeZone) {\n    throw new RangeError(failedParse(e));\n  }\n  const {offset: o} = t, r = o ? parseOffsetNano(o) : void 0, [, i, a] = je(n);\n  return finalizeZonedDateTime(t, r, i, a);\n}\n\nfunction parseOffsetNano(e) {\n  const n = parseOffsetNanoMaybe(e);\n  if (void 0 === n) {\n    throw new RangeError(failedParse(e));\n  }\n  return n;\n}\n\nfunction Bt(e) {\n  const n = parseDateTimeLike(m(e));\n  if (!n || n.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return jt(finalizeDateTime(n));\n}\n\nfunction de(e, n, t) {\n  let o = parseDateTimeLike(m(e));\n  if (!o || o.j) {\n    throw new RangeError(failedParse(e));\n  }\n  return n ? o.calendar === l && (o = -271821 === o.isoYear && 4 === o.isoMonth ? {\n    ...o,\n    isoDay: 20,\n    ...Nt\n  } : {\n    ...o,\n    isoDay: 1,\n    ...Nt\n  }) : t && o.calendar === l && (o = {\n    ...o,\n    isoYear: Br\n  }), W(o.C ? finalizeDateTime(o) : finalizeDate(o));\n}\n\nfunction _t(e, n) {\n  const t = parseYearMonthOnly(m(n));\n  if (t) {\n    return requireIsoCalendar(t), createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields(t)));\n  }\n  const o = de(n, 1);\n  return createPlainYearMonthSlots(moveToDayOfMonthUnsafe(e(o.calendar), o));\n}\n\nfunction requireIsoCalendar(e) {\n  if (e.calendar !== l) {\n    throw new RangeError(invalidSubstring(e.calendar));\n  }\n}\n\nfunction xt(e, n) {\n  const t = parseMonthDayOnly(m(n));\n  if (t) {\n    return requireIsoCalendar(t), createPlainMonthDaySlots(checkIsoDateFields(t));\n  }\n  const o = de(n, 0, 1), {calendar: r} = o, i = e(r), [a, s, c] = i.v(o), [u, f] = i.q(a, s), [l, d] = i.G(u, f, c);\n  return createPlainMonthDaySlots(checkIsoDateInBounds(i.V(l, d, c)), r);\n}\n\nfunction ht(e) {\n  let n, t = (e => {\n    const n = Pi.exec(e);\n    return n ? (organizeAnnotationParts(n[10]), organizeTimeParts(n)) : void 0;\n  })(m(e));\n  if (!t) {\n    if (t = parseDateTimeLike(e), !t) {\n      throw new RangeError(failedParse(e));\n    }\n    if (!t.C) {\n      throw new RangeError(failedParse(e));\n    }\n    if (t.j) {\n      throw new RangeError(invalidSubstring(\"Z\"));\n    }\n    requireIsoCalendar(t);\n  }\n  if ((n = parseYearMonthOnly(e)) && isIsoDateFieldsValid(n)) {\n    throw new RangeError(failedParse(e));\n  }\n  if ((n = parseMonthDayOnly(e)) && isIsoDateFieldsValid(n)) {\n    throw new RangeError(failedParse(e));\n  }\n  return St(constrainIsoTimeFields(t, 1));\n}\n\nfunction R(e) {\n  const n = (e => {\n    const n = Fi.exec(e);\n    return n ? (e => {\n      function parseUnit(e, r, i) {\n        let a = 0, s = 0;\n        if (i && ([a, o] = divModFloor(o, Ao[i])), void 0 !== e) {\n          if (t) {\n            throw new RangeError(invalidSubstring(e));\n          }\n          s = (e => {\n            const n = parseInt(e);\n            if (!Number.isFinite(n)) {\n              throw new RangeError(invalidSubstring(e));\n            }\n            return n;\n          })(e), n = 1, r && (o = parseSubsecNano(r) * (Ao[i] / Ro), t = 1);\n        }\n        return a + s;\n      }\n      let n = 0, t = 0, o = 0, r = {\n        ...zipProps(p, [ parseUnit(e[2]), parseUnit(e[3]), parseUnit(e[4]), parseUnit(e[5]), parseUnit(e[6], e[7], 5), parseUnit(e[8], e[9], 4), parseUnit(e[10], e[11], 3) ]),\n        ...nanoToGivenFields(o, 2, p)\n      };\n      if (!n) {\n        throw new RangeError(noValidFields(p));\n      }\n      return parseSign(e[1]) < 0 && (r = negateDurationFields(r)), r;\n    })(n) : void 0;\n  })(m(e));\n  if (!n) {\n    throw new RangeError(failedParse(e));\n  }\n  return Oe(checkDurationUnits(n));\n}\n\nfunction f(e) {\n  const n = parseDateTimeLike(e) || parseYearMonthOnly(e) || parseMonthDayOnly(e);\n  return n ? n.calendar : e;\n}\n\nfunction Z(e) {\n  const n = parseDateTimeLike(e);\n  return n && (n.timeZone || n.j && si || n.offset) || e;\n}\n\nfunction finalizeZonedDateTime(e, n, t = 0, o = 0) {\n  const r = M(e.timeZone), i = L(r);\n  let a;\n  return checkIsoDateTimeFields(e), a = e.C ? getMatchingInstantFor(i, e, n, t, o, !i.$, e.j) : getStartOfDayInstantFor(i, e), \n  _e(a, r, u(e.calendar));\n}\n\nfunction finalizeDateTime(e) {\n  return resolveSlotsCalendar(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e)));\n}\n\nfunction finalizeDate(e) {\n  return resolveSlotsCalendar(checkIsoDateInBounds(checkIsoDateFields(e)));\n}\n\nfunction resolveSlotsCalendar(e) {\n  return {\n    ...e,\n    calendar: u(e.calendar)\n  };\n}\n\nfunction parseDateTimeLike(e) {\n  const n = vi.exec(e);\n  return n ? (e => {\n    const n = e[10], t = \"Z\" === (n || \"\").toUpperCase();\n    return {\n      isoYear: organizeIsoYearParts(e),\n      isoMonth: parseInt(e[4]),\n      isoDay: parseInt(e[5]),\n      ...organizeTimeParts(e.slice(5)),\n      ...organizeAnnotationParts(e[16]),\n      C: Boolean(e[6]),\n      j: t,\n      offset: t ? void 0 : n\n    };\n  })(n) : void 0;\n}\n\nfunction parseYearMonthOnly(e) {\n  const n = Ni.exec(e);\n  return n ? (e => ({\n    isoYear: organizeIsoYearParts(e),\n    isoMonth: parseInt(e[4]),\n    isoDay: 1,\n    ...organizeAnnotationParts(e[5])\n  }))(n) : void 0;\n}\n\nfunction parseMonthDayOnly(e) {\n  const n = yi.exec(e);\n  return n ? (e => ({\n    isoYear: Br,\n    isoMonth: parseInt(e[1]),\n    isoDay: parseInt(e[2]),\n    ...organizeAnnotationParts(e[3])\n  }))(n) : void 0;\n}\n\nfunction parseOffsetNanoMaybe(e, n) {\n  const t = Ei.exec(e);\n  return t ? ((e, n) => {\n    const t = e[4] || e[5];\n    if (n && t) {\n      throw new RangeError(invalidSubstring(t));\n    }\n    return (e => {\n      if (Math.abs(e) >= Uo) {\n        throw new RangeError(ho);\n      }\n      return e;\n    })((parseInt0(e[2]) * zo + parseInt0(e[3]) * Zo + parseInt0(e[4]) * Ro + parseSubsecNano(e[5] || \"\")) * parseSign(e[1]));\n  })(t, n) : void 0;\n}\n\nfunction organizeIsoYearParts(e) {\n  const n = parseSign(e[1]), t = parseInt(e[2] || e[3]);\n  if (n < 0 && !t) {\n    throw new RangeError(invalidSubstring(-0));\n  }\n  return n * t;\n}\n\nfunction organizeTimeParts(e) {\n  const n = parseInt0(e[3]);\n  return {\n    ...nanoToIsoTimeAndDay(parseSubsecNano(e[4] || \"\"))[0],\n    isoHour: parseInt0(e[1]),\n    isoMinute: parseInt0(e[2]),\n    isoSecond: 60 === n ? 59 : n\n  };\n}\n\nfunction organizeAnnotationParts(e) {\n  let n, t;\n  const o = [];\n  if (e.replace(Si, ((e, r, i) => {\n    const a = Boolean(r), [s, c] = i.split(\"=\").reverse();\n    if (c) {\n      if (\"u-ca\" === c) {\n        o.push(s), n || (n = a);\n      } else if (a || /[A-Z]/.test(c)) {\n        throw new RangeError(invalidSubstring(e));\n      }\n    } else {\n      if (t) {\n        throw new RangeError(invalidSubstring(e));\n      }\n      t = s;\n    }\n    return \"\";\n  })), o.length > 1 && n) {\n    throw new RangeError(invalidSubstring(e));\n  }\n  return {\n    timeZone: t,\n    calendar: o[0] || l\n  };\n}\n\nfunction parseSubsecNano(e) {\n  return parseInt(e.padEnd(9, \"0\"));\n}\n\nfunction createRegExp(e) {\n  return new RegExp(`^${e}$`, \"i\");\n}\n\nfunction parseSign(e) {\n  return e && \"+\" !== e ? -1 : 1;\n}\n\nfunction parseInt0(e) {\n  return void 0 === e ? 0 : parseInt(e);\n}\n\nfunction Ze(e) {\n  return M(m(e));\n}\n\nfunction M(e) {\n  const n = getTimeZoneEssence(e);\n  return \"number\" == typeof n ? Se(n) : n ? (e => {\n    if (Oi.test(e)) {\n      throw new RangeError(F(e));\n    }\n    if (bi.test(e)) {\n      throw new RangeError(po);\n    }\n    return e.toLowerCase().split(\"/\").map(((e, n) => (e.length <= 3 || /\\d/.test(e)) && !/etc|yap/.test(e) ? e.toUpperCase() : e.replace(/baja|dumont|[a-z]+/g, ((e, t) => e.length <= 2 && !n || \"in\" === e || \"chat\" === e ? e.toUpperCase() : e.length > 2 || !t ? capitalize(e).replace(/island|noronha|murdo|rivadavia|urville/, capitalize) : e)))).join(\"/\");\n  })(e) : si;\n}\n\nfunction getTimeZoneAtomic(e) {\n  const n = getTimeZoneEssence(e);\n  return \"number\" == typeof n ? n : n ? n.resolvedOptions().timeZone : si;\n}\n\nfunction getTimeZoneEssence(e) {\n  const n = parseOffsetNanoMaybe(e = e.toUpperCase(), 1);\n  return void 0 !== n ? n : e !== si ? wi(e) : void 0;\n}\n\nfunction Ke(e, n) {\n  return compareBigNanos(e.epochNanoseconds, n.epochNanoseconds);\n}\n\nfunction Be(e, n) {\n  return compareBigNanos(e.epochNanoseconds, n.epochNanoseconds);\n}\n\nfunction K(e, n, t, o, r, i) {\n  const a = e(normalizeOptions(i).relativeTo), s = Math.max(getMaxDurationUnit(o), getMaxDurationUnit(r));\n  if (allPropsEqual(p, o, r)) {\n    return 0;\n  }\n  if (isUniformUnit(s, a)) {\n    return compareBigNanos(durationFieldsToBigNano(o), durationFieldsToBigNano(r));\n  }\n  if (!a) {\n    throw new RangeError(yo);\n  }\n  const [c, u, f] = createMarkerSystem(n, t, a), l = createMarkerToEpochNano(f), d = createMoveMarker(f);\n  return compareBigNanos(l(d(u, c, o)), l(d(u, c, r)));\n}\n\nfunction Yt(e, n) {\n  return te(e, n) || Dt(e, n);\n}\n\nfunction te(e, n) {\n  return compareNumbers(isoToEpochMilli(e), isoToEpochMilli(n));\n}\n\nfunction Dt(e, n) {\n  return compareNumbers(isoTimeFieldsToNano(e), isoTimeFieldsToNano(n));\n}\n\nfunction Ve(e, n) {\n  return !Ke(e, n);\n}\n\nfunction Ce(e, n) {\n  return !Be(e, n) && !!isTimeZoneIdsEqual(e.timeZone, n.timeZone) && e.calendar === n.calendar;\n}\n\nfunction Ct(e, n) {\n  return !Yt(e, n) && e.calendar === n.calendar;\n}\n\nfunction re(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction $t(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction Lt(e, n) {\n  return !te(e, n) && e.calendar === n.calendar;\n}\n\nfunction st(e, n) {\n  return !Dt(e, n);\n}\n\nfunction isTimeZoneIdsEqual(e, n) {\n  if (e === n) {\n    return 1;\n  }\n  try {\n    return getTimeZoneAtomic(e) === getTimeZoneAtomic(n);\n  } catch (e) {}\n}\n\nfunction Ee(e, n, t, o) {\n  const r = refineDiffOptions(e, o, 3, 5), i = diffEpochNanos(n.epochNanoseconds, t.epochNanoseconds, ...r);\n  return Oe(e ? negateDurationFields(i) : i);\n}\n\nfunction we(e, n, t, o, r, i) {\n  const a = getCommonCalendarId(o.calendar, r.calendar), [s, c, u, f] = refineDiffOptions(t, i, 5), l = o.epochNanoseconds, d = r.epochNanoseconds, m = compareBigNanos(d, l);\n  let p;\n  if (m) {\n    if (s < 6) {\n      p = diffEpochNanos(l, d, s, c, u, f);\n    } else {\n      const t = n(((e, n) => {\n        if (!isTimeZoneIdsEqual(e, n)) {\n          throw new RangeError(mo);\n        }\n        return e;\n      })(o.timeZone, r.timeZone)), l = e(a);\n      p = diffZonedEpochsBig(l, t, o, r, m, s, i), p = roundRelativeDuration(p, d, s, c, u, f, l, o, extractEpochNano, Pt(moveZonedEpochs, t));\n    }\n  } else {\n    p = pr;\n  }\n  return Oe(t ? negateDurationFields(p) : p);\n}\n\nfunction It(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar), [a, s, c, u] = refineDiffOptions(n, r, 6), f = isoToEpochNano(t), l = isoToEpochNano(o), d = compareBigNanos(l, f);\n  let m;\n  if (d) {\n    if (a <= 6) {\n      m = diffEpochNanos(f, l, a, s, c, u);\n    } else {\n      const n = e(i);\n      m = diffDateTimesBig(n, t, o, d, a, r), m = roundRelativeDuration(m, l, a, s, c, u, n, t, isoToEpochNano, moveDateTime);\n    }\n  } else {\n    m = pr;\n  }\n  return Oe(n ? negateDurationFields(m) : m);\n}\n\nfunction oe(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar);\n  return diffDateLike(n, (() => e(i)), t, o, ...refineDiffOptions(n, r, 6, 9, 6));\n}\n\nfunction zt(e, n, t, o, r) {\n  const i = getCommonCalendarId(t.calendar, o.calendar), a = refineDiffOptions(n, r, 9, 9, 8), s = e(i), c = moveToDayOfMonthUnsafe(s, t), u = moveToDayOfMonthUnsafe(s, o);\n  return c.isoYear === u.isoYear && c.isoMonth === u.isoMonth && c.isoDay === u.isoDay ? Oe(pr) : diffDateLike(n, (() => s), checkIsoDateInBounds(c), checkIsoDateInBounds(u), ...a, 8);\n}\n\nfunction diffDateLike(e, n, t, o, r, i, a, s, c = 6) {\n  const u = isoToEpochNano(t), f = isoToEpochNano(o);\n  if (void 0 === u || void 0 === f) {\n    throw new RangeError(Io);\n  }\n  let l;\n  if (compareBigNanos(f, u)) {\n    if (6 === r) {\n      l = diffEpochNanos(u, f, r, i, a, s);\n    } else {\n      const e = n();\n      l = e.N(t, o, r), i === c && 1 === a || (l = roundRelativeDuration(l, f, r, i, a, s, e, t, isoToEpochNano, moveDate));\n    }\n  } else {\n    l = pr;\n  }\n  return Oe(e ? negateDurationFields(l) : l);\n}\n\nfunction it(e, n, t, o) {\n  const [r, i, a, s] = refineDiffOptions(e, o, 5, 5), c = roundByInc(diffTimes(n, t), computeNanoInc(i, a), s), u = {\n    ...pr,\n    ...nanoToDurationTimeFields(c, r)\n  };\n  return Oe(e ? negateDurationFields(u) : u);\n}\n\nfunction diffZonedEpochsExact(e, n, t, o, r, i) {\n  const a = compareBigNanos(o.epochNanoseconds, t.epochNanoseconds);\n  return a ? r < 6 ? diffEpochNanosExact(t.epochNanoseconds, o.epochNanoseconds, r) : diffZonedEpochsBig(n, e, t, o, a, r, i) : pr;\n}\n\nfunction diffDateTimesExact(e, n, t, o, r) {\n  const i = isoToEpochNano(n), a = isoToEpochNano(t), s = compareBigNanos(a, i);\n  return s ? o <= 6 ? diffEpochNanosExact(i, a, o) : diffDateTimesBig(e, n, t, s, o, r) : pr;\n}\n\nfunction diffZonedEpochsBig(e, n, t, o, r, i, a) {\n  const [s, c, u] = ((e, n, t, o) => {\n    function updateMid() {\n      return f = {\n        ...moveByDays(a, c++ * -o),\n        ...i\n      }, l = getSingleInstantFor(e, f), compareBigNanos(s, l) === -o;\n    }\n    const r = he(n, e), i = nn(w, r), a = he(t, e), s = t.epochNanoseconds;\n    let c = 0;\n    const u = diffTimes(r, a);\n    let f, l;\n    if (Math.sign(u) === -o && c++, updateMid() && (-1 === o || updateMid())) {\n      throw new RangeError(fo);\n    }\n    const d = bigNanoToNumber(diffBigNanos(l, s));\n    return [ r, f, d ];\n  })(n, t, o, r);\n  var f, l;\n  return {\n    ...6 === i ? (f = s, l = c, {\n      ...pr,\n      days: diffDays(f, l)\n    }) : e.N(s, c, i, a),\n    ...nanoToDurationTimeFields(u)\n  };\n}\n\nfunction diffDateTimesBig(e, n, t, o, r, i) {\n  const [a, s, c] = ((e, n, t) => {\n    let o = n, r = diffTimes(e, n);\n    return Math.sign(r) === -t && (o = moveByDays(n, -t), r += Uo * t), [ e, o, r ];\n  })(n, t, o);\n  return {\n    ...e.N(a, s, r, i),\n    ...nanoToDurationTimeFields(c)\n  };\n}\n\nfunction diffEpochNanos(e, n, t, o, r, i) {\n  return {\n    ...pr,\n    ...nanoToDurationDayTimeFields(roundBigNano(diffBigNanos(e, n), o, r, i), t)\n  };\n}\n\nfunction diffEpochNanosExact(e, n, t) {\n  return {\n    ...pr,\n    ...nanoToDurationDayTimeFields(diffBigNanos(e, n), t)\n  };\n}\n\nfunction diffDays(e, n) {\n  return diffEpochMilliByDay(isoToEpochMilli(e), isoToEpochMilli(n));\n}\n\nfunction diffEpochMilliByDay(e, n) {\n  return Math.trunc((n - e) / ko);\n}\n\nfunction diffTimes(e, n) {\n  return isoTimeFieldsToNano(n) - isoTimeFieldsToNano(e);\n}\n\nfunction getCommonCalendarId(e, n) {\n  if (e !== n) {\n    throw new RangeError(lo);\n  }\n  return e;\n}\n\nfunction computeNativeWeekOfYear(e) {\n  return this.m(e)[0];\n}\n\nfunction computeNativeYearOfWeek(e) {\n  return this.m(e)[1];\n}\n\nfunction computeNativeDayOfYear(e) {\n  const [n] = this.v(e);\n  return diffEpochMilliByDay(this.p(n), isoToEpochMilli(e)) + 1;\n}\n\nfunction parseMonthCode(e) {\n  const n = Bi.exec(e);\n  if (!n) {\n    throw new RangeError(invalidMonthCode(e));\n  }\n  return [ parseInt(n[1]), Boolean(n[2]) ];\n}\n\nfunction formatMonthCode(e, n) {\n  return \"M\" + bo(e) + (n ? \"L\" : \"\");\n}\n\nfunction monthCodeNumberToMonth(e, n, t) {\n  return e + (n || t && e >= t ? 1 : 0);\n}\n\nfunction monthToMonthCodeNumber(e, n) {\n  return e - (n && e >= n ? 1 : 0);\n}\n\nfunction eraYearToYear(e, n) {\n  return (n + e) * (Math.sign(n) || 1) || 0;\n}\n\nfunction getCalendarEraOrigins(e) {\n  return ir[getCalendarIdBase(e)];\n}\n\nfunction getCalendarLeapMonthMeta(e) {\n  return sr[getCalendarIdBase(e)];\n}\n\nfunction getCalendarIdBase(e) {\n  return computeCalendarIdBase(e.id || l);\n}\n\nfunction createIntlCalendar(e) {\n  function epochMilliToIntlFields(e) {\n    return ((e, n) => ({\n      ...parseIntlYear(e, n),\n      o: e.month,\n      day: parseInt(e.day)\n    }))(hashIntlFormatParts(n, e), t);\n  }\n  const n = Ci(e), t = computeCalendarIdBase(e);\n  return {\n    id: e,\n    h: createIntlFieldCache(epochMilliToIntlFields),\n    l: createIntlYearDataCache(epochMilliToIntlFields)\n  };\n}\n\nfunction createIntlFieldCache(e) {\n  return on((n => {\n    const t = isoToEpochMilli(n);\n    return e(t);\n  }), WeakMap);\n}\n\nfunction createIntlYearDataCache(e) {\n  const n = e(0).year - Or;\n  return on((t => {\n    let o, r = isoArgsToEpochMilli(t - n), i = 0;\n    const a = [], s = [];\n    do {\n      r += 400 * ko;\n    } while ((o = e(r)).year <= t);\n    do {\n      if (r += (1 - o.day) * ko, o.year === t && (a.push(r), s.push(o.o)), r -= ko, ++i > 100 || r < -Pr) {\n        throw new RangeError(fo);\n      }\n    } while ((o = e(r)).year >= t);\n    return {\n      i: a.reverse(),\n      u: Fo(s.reverse())\n    };\n  }));\n}\n\nfunction parseIntlYear(e, n) {\n  let t, o, r = parseIntlPartsYear(e);\n  if (e.era) {\n    const i = ir[n], a = ar[n] || {};\n    void 0 !== i && (t = \"islamic\" === n ? \"ah\" : e.era.normalize(\"NFD\").toLowerCase().replace(/[^a-z0-9]/g, \"\"), \n    \"bc\" === t || \"b\" === t ? t = \"bce\" : \"ad\" === t || \"a\" === t ? t = \"ce\" : \"beforeroc\" === t && (t = \"broc\"), \n    t = a[t] || t, o = r, r = eraYearToYear(o, i[t] || 0));\n  }\n  return {\n    era: t,\n    eraYear: o,\n    year: r\n  };\n}\n\nfunction parseIntlPartsYear(e) {\n  return parseInt(e.relatedYear || e.year);\n}\n\nfunction computeIntlDateParts(e) {\n  const {year: n, o: t, day: o} = this.h(e), {u: r} = this.l(n);\n  return [ n, r[t] + 1, o ];\n}\n\nfunction computeIntlEpochMilli(e, n = 1, t = 1) {\n  return this.l(e).i[n - 1] + (t - 1) * ko;\n}\n\nfunction computeIntlMonthCodeParts(e, n) {\n  const t = computeIntlLeapMonth.call(this, e);\n  return [ monthToMonthCodeNumber(n, t), t === n ];\n}\n\nfunction computeIntlLeapMonth(e) {\n  const n = queryMonthStrings(this, e), t = queryMonthStrings(this, e - 1), o = n.length;\n  if (o > t.length) {\n    const e = getCalendarLeapMonthMeta(this);\n    if (e < 0) {\n      return -e;\n    }\n    for (let e = 0; e < o; e++) {\n      if (n[e] !== t[e]) {\n        return e + 1;\n      }\n    }\n  }\n}\n\nfunction computeIntlDaysInYear(e) {\n  return diffEpochMilliByDay(computeIntlEpochMilli.call(this, e), computeIntlEpochMilli.call(this, e + 1));\n}\n\nfunction computeIntlDaysInMonth(e, n) {\n  const {i: t} = this.l(e);\n  let o = n + 1, r = t;\n  return o > t.length && (o = 1, r = this.l(e + 1).i), diffEpochMilliByDay(t[n - 1], r[o - 1]);\n}\n\nfunction computeIntlMonthsInYear(e) {\n  return this.l(e).i.length;\n}\n\nfunction computeIntlEraParts(e) {\n  const n = this.h(e);\n  return [ n.era, n.eraYear ];\n}\n\nfunction queryMonthStrings(e, n) {\n  return Object.keys(e.l(n).u);\n}\n\nfunction Mt(e) {\n  return u(m(e));\n}\n\nfunction u(e) {\n  if ((e = e.toLowerCase()) !== l && e !== or) {\n    const n = Ci(e).resolvedOptions().calendar;\n    if (computeCalendarIdBase(e) !== computeCalendarIdBase(n)) {\n      throw new RangeError(c(e));\n    }\n    return n;\n  }\n  return e;\n}\n\nfunction computeCalendarIdBase(e) {\n  return \"islamicc\" === e && (e = \"islamic\"), e.split(\"-\")[0];\n}\n\nfunction createNativeOpsCreator(e, n) {\n  return t => t === l ? e : t === or || t === rr ? Object.assign(Object.create(e), {\n    id: t\n  }) : Object.assign(Object.create(n), ki(t));\n}\n\nfunction $(e, n, t, o) {\n  const r = refineCalendarFields(t, o, Xo, [], xo);\n  if (void 0 !== r.timeZone) {\n    const o = t.F(r), i = refineTimeBag(r), a = e(r.timeZone);\n    return {\n      epochNanoseconds: getMatchingInstantFor(n(a), {\n        ...o,\n        ...i\n      }, void 0 !== r.offset ? parseOffsetNano(r.offset) : void 0),\n      timeZone: a\n    };\n  }\n  return {\n    ...t.F(r),\n    ...Nt\n  };\n}\n\nfunction Ne(e, n, t, o, r, i) {\n  const a = refineCalendarFields(t, r, Xo, jo, xo), s = e(a.timeZone), [c, u, f] = je(i), l = t.F(a, fabricateOverflowOptions(c)), d = refineTimeBag(a, c);\n  return _e(getMatchingInstantFor(n(s), {\n    ...l,\n    ...d\n  }, void 0 !== a.offset ? parseOffsetNano(a.offset) : void 0, u, f), s, o);\n}\n\nfunction At(e, n, t) {\n  const o = refineCalendarFields(e, n, Xo, [], O), r = mt(t);\n  return jt(checkIsoDateTimeInBounds({\n    ...e.F(o, fabricateOverflowOptions(r)),\n    ...refineTimeBag(o, r)\n  }));\n}\n\nfunction me(e, n, t, o = []) {\n  const r = refineCalendarFields(e, n, Xo, o);\n  return e.F(r, t);\n}\n\nfunction Xt(e, n, t, o) {\n  const r = refineCalendarFields(e, n, Ko, o);\n  return e.K(r, t);\n}\n\nfunction Rt(e, n, t, o) {\n  const r = refineCalendarFields(e, t, Xo, Jo);\n  return n && void 0 !== r.month && void 0 === r.monthCode && void 0 === r.year && (r.year = Br), \n  e._(r, o);\n}\n\nfunction Tt(e, n) {\n  return St(refineTimeBag(refineFields(e, qo, [], 1), mt(n)));\n}\n\nfunction q(e) {\n  const n = refineFields(e, ur);\n  return Oe(checkDurationUnits({\n    ...pr,\n    ...n\n  }));\n}\n\nfunction refineCalendarFields(e, n, t, o = [], r = []) {\n  return refineFields(n, [ ...e.fields(t), ...r ].sort(), o);\n}\n\nfunction refineFields(e, n, t, o = !t) {\n  const r = {};\n  let i, a = 0;\n  for (const o of n) {\n    if (o === i) {\n      throw new RangeError(duplicateFields(o));\n    }\n    if (\"constructor\" === o || \"__proto__\" === o) {\n      throw new RangeError(forbiddenField(o));\n    }\n    let n = e[o];\n    if (void 0 !== n) {\n      a = 1, Li[o] && (n = Li[o](n, o)), r[o] = n;\n    } else if (t) {\n      if (t.includes(o)) {\n        throw new TypeError(missingField(o));\n      }\n      r[o] = tr[o];\n    }\n    i = o;\n  }\n  if (o && !a) {\n    throw new TypeError(noValidFields(n));\n  }\n  return r;\n}\n\nfunction refineTimeBag(e, n) {\n  return constrainIsoTimeFields(xi({\n    ...tr,\n    ...e\n  }), n);\n}\n\nfunction De(e, n, t, o, r) {\n  const {calendar: i, timeZone: a} = t, s = e(i), c = n(a), u = [ ...s.fields(Xo), ...Lo ].sort(), f = (e => {\n    const n = he(e, L), t = Se(n.offsetNanoseconds), o = ji(e.calendar), [r, i, a] = o.v(n), [s, c] = o.q(r, i), u = formatMonthCode(s, c);\n    return {\n      ...$i(n),\n      year: r,\n      monthCode: u,\n      day: a,\n      offset: t\n    };\n  })(t), l = refineFields(o, u), d = s.k(f, l), m = {\n    ...f,\n    ...l\n  }, [p, h, g] = je(r, 2);\n  return _e(getMatchingInstantFor(c, {\n    ...s.F(d, fabricateOverflowOptions(p)),\n    ...constrainIsoTimeFields(xi(m), p)\n  }, parseOffsetNano(m.offset), h, g), a, i);\n}\n\nfunction gt(e, n, t, o) {\n  const r = e(n.calendar), i = [ ...r.fields(Xo), ...O ].sort(), a = {\n    ...computeDateEssentials(s = n),\n    hour: s.isoHour,\n    minute: s.isoMinute,\n    second: s.isoSecond,\n    millisecond: s.isoMillisecond,\n    microsecond: s.isoMicrosecond,\n    nanosecond: s.isoNanosecond\n  };\n  var s;\n  const c = refineFields(t, i), u = mt(o), f = r.k(a, c), l = {\n    ...a,\n    ...c\n  };\n  return jt(checkIsoDateTimeInBounds({\n    ...r.F(f, fabricateOverflowOptions(u)),\n    ...constrainIsoTimeFields(xi(l), u)\n  }));\n}\n\nfunction ee(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Xo).sort(), a = computeDateEssentials(n), s = refineFields(t, i), c = r.k(a, s);\n  return r.F(c, o);\n}\n\nfunction Wt(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Ko).sort(), a = (e => {\n    const n = ji(e.calendar), [t, o] = n.v(e), [r, i] = n.q(t, o);\n    return {\n      year: t,\n      monthCode: formatMonthCode(r, i)\n    };\n  })(n), s = refineFields(t, i), c = r.k(a, s);\n  return r.K(c, o);\n}\n\nfunction Et(e, n, t, o) {\n  const r = e(n.calendar), i = r.fields(Xo).sort(), a = (e => {\n    const n = ji(e.calendar), [t, o, r] = n.v(e), [i, a] = n.q(t, o);\n    return {\n      monthCode: formatMonthCode(i, a),\n      day: r\n    };\n  })(n), s = refineFields(t, i), c = r.k(a, s);\n  return r._(c, o);\n}\n\nfunction rt(e, n, t) {\n  return St(((e, n, t) => refineTimeBag({\n    ...nn(qo, e),\n    ...refineFields(n, qo)\n  }, mt(t)))(e, n, t));\n}\n\nfunction A(e, n) {\n  return Oe((t = e, o = n, checkDurationUnits({\n    ...t,\n    ...refineFields(o, ur)\n  })));\n  var t, o;\n}\n\nfunction convertToIso(e, n, t, o, r) {\n  n = nn(t = e.fields(t), n), o = refineFields(o, r = e.fields(r), []);\n  let i = e.k(n, o);\n  return i = refineFields(i, [ ...t, ...r ].sort(), []), e.F(i);\n}\n\nfunction refineYear(e, n) {\n  const t = getCalendarEraOrigins(e), o = ar[e.id || \"\"] || {};\n  let {era: r, eraYear: i, year: a} = n;\n  if (void 0 !== r || void 0 !== i) {\n    if (void 0 === r || void 0 === i) {\n      throw new TypeError(io);\n    }\n    if (!t) {\n      throw new RangeError(ro);\n    }\n    const e = t[o[r] || r];\n    if (void 0 === e) {\n      throw new RangeError(invalidEra(r));\n    }\n    const n = eraYearToYear(i, e);\n    if (void 0 !== a && a !== n) {\n      throw new RangeError(ao);\n    }\n    a = n;\n  } else if (void 0 === a) {\n    throw new TypeError(missingYear(t));\n  }\n  return a;\n}\n\nfunction refineMonth(e, n, t, o) {\n  let {month: r, monthCode: i} = n;\n  if (void 0 !== i) {\n    const n = ((e, n, t, o) => {\n      const r = e.L(t), [i, a] = parseMonthCode(n);\n      let s = monthCodeNumberToMonth(i, a, r);\n      if (a) {\n        const n = getCalendarLeapMonthMeta(e);\n        if (void 0 === n) {\n          throw new RangeError(uo);\n        }\n        if (n > 0) {\n          if (s > n) {\n            throw new RangeError(uo);\n          }\n          if (void 0 === r) {\n            if (1 === o) {\n              throw new RangeError(uo);\n            }\n            s--;\n          }\n        } else {\n          if (s !== -n) {\n            throw new RangeError(uo);\n          }\n          if (void 0 === r && 1 === o) {\n            throw new RangeError(uo);\n          }\n        }\n      }\n      return s;\n    })(e, i, t, o);\n    if (void 0 !== r && r !== n) {\n      throw new RangeError(so);\n    }\n    r = n, o = 1;\n  } else if (void 0 === r) {\n    throw new TypeError(co);\n  }\n  return clampEntity(\"month\", r, 1, e.B(t), o);\n}\n\nfunction refineDay(e, n, t, o, r) {\n  return clampProp(n, \"day\", 1, e.U(o, t), r);\n}\n\nfunction spliceFields(e, n, t, o) {\n  let r = 0;\n  const i = [];\n  for (const e of t) {\n    void 0 !== n[e] ? r = 1 : i.push(e);\n  }\n  if (Object.assign(e, n), r) {\n    for (const n of o || i) {\n      delete e[n];\n    }\n  }\n}\n\nfunction computeDateEssentials(e) {\n  const n = ji(e.calendar), [t, o, r] = n.v(e), [i, a] = n.q(t, o);\n  return {\n    year: t,\n    monthCode: formatMonthCode(i, a),\n    day: r\n  };\n}\n\nfunction qe(e) {\n  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e))));\n}\n\nfunction ye(e, n, t, o, r = l) {\n  return _e(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(t))), n(o), e(r));\n}\n\nfunction Zt(n, t, o, r, i = 0, a = 0, s = 0, c = 0, u = 0, f = 0, d = l) {\n  return jt(checkIsoDateTimeInBounds(checkIsoDateTimeFields(e(toInteger, zipProps(Tr, [ t, o, r, i, a, s, c, u, f ])))), n(d));\n}\n\nfunction ue(n, t, o, r, i = l) {\n  return W(checkIsoDateInBounds(checkIsoDateFields(e(toInteger, {\n    isoYear: t,\n    isoMonth: o,\n    isoDay: r\n  }))), n(i));\n}\n\nfunction Qt(e, n, t, o = l, r = 1) {\n  const i = toInteger(n), a = toInteger(t), s = e(o);\n  return createPlainYearMonthSlots(checkIsoYearMonthInBounds(checkIsoDateFields({\n    isoYear: i,\n    isoMonth: a,\n    isoDay: toInteger(r)\n  })), s);\n}\n\nfunction kt(e, n, t, o = l, r = Br) {\n  const i = toInteger(n), a = toInteger(t), s = e(o);\n  return createPlainMonthDaySlots(checkIsoDateInBounds(checkIsoDateFields({\n    isoYear: toInteger(r),\n    isoMonth: i,\n    isoDay: a\n  })), s);\n}\n\nfunction ut(n = 0, t = 0, o = 0, r = 0, i = 0, a = 0) {\n  return St(constrainIsoTimeFields(e(toInteger, zipProps(w, [ n, t, o, r, i, a ])), 1));\n}\n\nfunction j(n = 0, t = 0, o = 0, r = 0, i = 0, a = 0, s = 0, c = 0, u = 0, f = 0) {\n  return Oe(checkDurationUnits(e(toStrictInteger, zipProps(p, [ n, t, o, r, i, a, s, c, u, f ]))));\n}\n\nfunction Je(e, n, t = l) {\n  return _e(e.epochNanoseconds, n, t);\n}\n\nfunction be(e) {\n  return xe(e.epochNanoseconds);\n}\n\nfunction yt(e, n) {\n  return jt(he(n, e));\n}\n\nfunction fe(e, n) {\n  return W(he(n, e));\n}\n\nfunction dt(e, n) {\n  return St(he(n, e));\n}\n\nfunction bt(e, n, t, o) {\n  const r = ((e, n, t, o) => {\n    const r = (e => ei(normalizeOptions(e)))(o);\n    return getSingleInstantFor(e(n), t, r);\n  })(e, t, n, o);\n  return _e(checkEpochNanoInBounds(r), t, n.calendar);\n}\n\nfunction ae(e, n, t, o, r) {\n  const i = e(r.timeZone), a = r.plainTime, s = void 0 !== a ? n(a) : void 0, c = t(i);\n  let u;\n  return u = s ? getSingleInstantFor(c, {\n    ...o,\n    ...s\n  }) : getStartOfDayInstantFor(c, {\n    ...o,\n    ...Nt\n  }), _e(u, i, o.calendar);\n}\n\nfunction ie(e, n = Nt) {\n  return jt(checkIsoDateTimeInBounds({\n    ...e,\n    ...n\n  }));\n}\n\nfunction le(e, n, t) {\n  return ((e, n) => {\n    const t = refineCalendarFields(e, n, Qo);\n    return e.K(t, void 0);\n  })(e(n.calendar), t);\n}\n\nfunction se(e, n, t) {\n  return ((e, n) => {\n    const t = refineCalendarFields(e, n, nr);\n    return e._(t);\n  })(e(n.calendar), t);\n}\n\nfunction Ht(e, n, t, o) {\n  return ((e, n, t) => convertToIso(e, n, Qo, requireObjectLike(t), Jo))(e(n.calendar), t, o);\n}\n\nfunction Vt(e, n, t, o) {\n  return ((e, n, t) => convertToIso(e, n, nr, requireObjectLike(t), Go))(e(n.calendar), t, o);\n}\n\nfunction $e(e) {\n  return xe(checkEpochNanoInBounds(Ge(toStrictInteger(e), Qe)));\n}\n\nfunction He(e) {\n  return xe(checkEpochNanoInBounds(bigIntToBigNano(toBigInt(e))));\n}\n\nfunction createOptionsTransformer(e, n, t) {\n  const o = new Set(t);\n  return (r, i) => {\n    const a = t && hasAnyPropsByName(r, t);\n    if (!hasAnyPropsByName(r = ((e, n) => {\n      const t = {};\n      for (const o in n) {\n        e.has(o) || (t[o] = n[o]);\n      }\n      return t;\n    })(o, r), e)) {\n      if (i && a) {\n        throw new TypeError(\"Invalid formatting options\");\n      }\n      r = {\n        ...n,\n        ...r\n      };\n    }\n    return t && (r.timeZone = si, [ \"full\", \"long\" ].includes(r.J) && (r.J = \"medium\")), \n    r;\n  };\n}\n\nfunction Q(e, n = an, t = 0) {\n  const [o, , , r] = e;\n  return (i, a = Na, ...s) => {\n    const c = n(r && r(...s), i, a, o, t), u = c.resolvedOptions();\n    return [ c, ...toEpochMillis(e, u, s) ];\n  };\n}\n\nfunction an(e, n, t, o, r) {\n  if (t = o(t, r), e) {\n    if (void 0 !== t.timeZone) {\n      throw new TypeError(So);\n    }\n    t.timeZone = e;\n  }\n  return new en(n, t);\n}\n\nfunction toEpochMillis(e, n, t) {\n  const [, o, r] = e;\n  return t.map((e => (e.calendar && ((e, n, t) => {\n    if ((t || e !== l) && e !== n) {\n      throw new RangeError(lo);\n    }\n  })(e.calendar, n.calendar, r), o(e, n))));\n}\n\nfunction ge(e, n, t) {\n  const o = n.timeZone, r = e(o), i = {\n    ...he(n, r),\n    ...t || Nt\n  };\n  let a;\n  return a = t ? getMatchingInstantFor(r, i, i.offsetNanoseconds, 2) : getStartOfDayInstantFor(r, i), \n  _e(a, o, n.calendar);\n}\n\nfunction Ot(e, n = Nt) {\n  return jt(checkIsoDateTimeInBounds({\n    ...e,\n    ...n\n  }));\n}\n\nfunction pt(e, n) {\n  return {\n    ...e,\n    calendar: n\n  };\n}\n\nfunction Pe(e, n) {\n  return {\n    ...e,\n    timeZone: n\n  };\n}\n\nfunction tn(e) {\n  const n = Xe();\n  return epochNanoToIso(n, e.R(n));\n}\n\nfunction Xe() {\n  return Ge(Date.now(), Qe);\n}\n\nfunction Ue() {\n  return va || (va = (new en).resolvedOptions().timeZone);\n}\n\nconst expectedInteger = (e, n) => `Non-integer ${e}: ${n}`, expectedPositive = (e, n) => `Non-positive ${e}: ${n}`, expectedFinite = (e, n) => `Non-finite ${e}: ${n}`, forbiddenBigIntToNumber = e => `Cannot convert bigint to ${e}`, invalidBigInt = e => `Invalid bigint: ${e}`, no = \"Cannot convert Symbol to string\", oo = \"Invalid object\", numberOutOfRange = (e, n, t, o, r) => r ? numberOutOfRange(e, r[n], r[t], r[o]) : invalidEntity(e, n) + `; must be between ${t}-${o}`, invalidEntity = (e, n) => `Invalid ${e}: ${n}`, missingField = e => `Missing ${e}`, forbiddenField = e => `Invalid field ${e}`, duplicateFields = e => `Duplicate field ${e}`, noValidFields = e => \"No valid fields: \" + e.join(), i = \"Invalid bag\", invalidChoice = (e, n, t) => invalidEntity(e, n) + \"; must be \" + Object.keys(t).join(), b = \"Cannot use valueOf\", a = \"Invalid calling context\", ro = \"Forbidden era/eraYear\", io = \"Mismatching era/eraYear\", ao = \"Mismatching year/eraYear\", invalidEra = e => `Invalid era: ${e}`, missingYear = e => \"Missing year\" + (e ? \"/era/eraYear\" : \"\"), invalidMonthCode = e => `Invalid monthCode: ${e}`, so = \"Mismatching month/monthCode\", co = \"Missing month/monthCode\", uo = \"Invalid leap month\", fo = \"Invalid protocol results\", c = e => invalidEntity(\"Calendar\", e), lo = \"Mismatching Calendars\", F = e => invalidEntity(\"TimeZone\", e), mo = \"Mismatching TimeZones\", po = \"Forbidden ICU TimeZone\", ho = \"Out-of-bounds offset\", go = \"Out-of-bounds TimeZone gap\", Do = \"Invalid TimeZone offset\", To = \"Ambiguous offset\", Io = \"Out-of-bounds date\", Mo = \"Out-of-bounds duration\", No = \"Cannot mix duration signs\", yo = \"Missing relativeTo\", vo = \"Cannot use large units\", Po = \"Required smallestUnit or largestUnit\", Eo = \"smallestUnit > largestUnit\", failedParse = e => `Cannot parse: ${e}`, invalidSubstring = e => `Invalid substring: ${e}`, rn = e => `Cannot format ${e}`, ln = \"Mismatching types for formatting\", So = \"Cannot specify TimeZone\", Fo = /*@__PURE__*/ Pt(g, ((e, n) => n)), wo = /*@__PURE__*/ Pt(g, ((e, n, t) => t)), bo = /*@__PURE__*/ Pt(padNumber, 2), Oo = {\n  nanosecond: 0,\n  microsecond: 1,\n  millisecond: 2,\n  second: 3,\n  minute: 4,\n  hour: 5,\n  day: 6,\n  week: 7,\n  month: 8,\n  year: 9\n}, Bo = /*@__PURE__*/ Object.keys(Oo), ko = 864e5, Co = 1e3, Yo = 1e3, Qe = 1e6, Ro = 1e9, Zo = 6e10, zo = 36e11, Uo = 864e11, Ao = [ 1, Yo, Qe, Ro, Zo, zo, Uo ], O = /*@__PURE__*/ Bo.slice(0, 6), qo = /*@__PURE__*/ sortStrings(O), Wo = [ \"offset\" ], jo = [ \"timeZone\" ], Lo = /*@__PURE__*/ O.concat(Wo), xo = /*@__PURE__*/ Lo.concat(jo), $o = [ \"era\", \"eraYear\" ], Ho = /*@__PURE__*/ $o.concat([ \"year\" ]), Go = [ \"year\" ], Vo = [ \"monthCode\" ], _o = /*@__PURE__*/ [ \"month\" ].concat(Vo), Jo = [ \"day\" ], Ko = /*@__PURE__*/ _o.concat(Go), Qo = /*@__PURE__*/ Vo.concat(Go), Xo = /*@__PURE__*/ Jo.concat(Ko), er = /*@__PURE__*/ Jo.concat(_o), nr = /*@__PURE__*/ Jo.concat(Vo), tr = /*@__PURE__*/ wo(O, 0), l = \"iso8601\", or = \"gregory\", rr = \"japanese\", ir = {\n  [or]: {\n    \"gregory-inverse\": -1,\n    gregory: 0\n  },\n  [rr]: {\n    \"japanese-inverse\": -1,\n    japanese: 0,\n    meiji: 1867,\n    taisho: 1911,\n    showa: 1925,\n    heisei: 1988,\n    reiwa: 2018\n  },\n  ethiopic: {\n    ethioaa: 0,\n    ethiopic: 5500\n  },\n  coptic: {\n    \"coptic-inverse\": -1,\n    coptic: 0\n  },\n  roc: {\n    \"roc-inverse\": -1,\n    roc: 0\n  },\n  buddhist: {\n    be: 0\n  },\n  islamic: {\n    ah: 0\n  },\n  indian: {\n    saka: 0\n  },\n  persian: {\n    ap: 0\n  }\n}, ar = {\n  [or]: {\n    bce: \"gregory-inverse\",\n    ce: \"gregory\"\n  },\n  [rr]: {\n    bce: \"japanese-inverse\",\n    ce: \"japanese\"\n  },\n  ethiopic: {\n    era0: \"ethioaa\",\n    era1: \"ethiopic\"\n  },\n  coptic: {\n    era0: \"coptic-inverse\",\n    era1: \"coptic\"\n  },\n  roc: {\n    broc: \"roc-inverse\",\n    minguo: \"roc\"\n  }\n}, sr = {\n  chinese: 13,\n  dangi: 13,\n  hebrew: -6\n}, m = /*@__PURE__*/ Pt(requireType, \"string\"), D = /*@__PURE__*/ Pt(requireType, \"boolean\"), cr = /*@__PURE__*/ Pt(requireType, \"number\"), p = /*@__PURE__*/ Bo.map((e => e + \"s\")), ur = /*@__PURE__*/ sortStrings(p), fr = /*@__PURE__*/ p.slice(0, 6), lr = /*@__PURE__*/ p.slice(6), dr = /*@__PURE__*/ lr.slice(1), mr = /*@__PURE__*/ Fo(p), pr = /*@__PURE__*/ wo(p, 0), hr = /*@__PURE__*/ wo(fr, 0), gr = /*@__PURE__*/ Pt(zeroOutProps, p), w = [ \"isoNanosecond\", \"isoMicrosecond\", \"isoMillisecond\", \"isoSecond\", \"isoMinute\", \"isoHour\" ], Dr = [ \"isoDay\", \"isoMonth\", \"isoYear\" ], Tr = /*@__PURE__*/ w.concat(Dr), Ir = /*@__PURE__*/ sortStrings(Dr), Mr = /*@__PURE__*/ sortStrings(w), Nr = /*@__PURE__*/ sortStrings(Tr), Nt = /*@__PURE__*/ wo(Mr, 0), yr = /*@__PURE__*/ Pt(zeroOutProps, Tr), vr = 1e8, Pr = vr * ko, Er = [ vr, 0 ], Sr = [ -vr, 0 ], Fr = 275760, wr = -271821, en = Intl.DateTimeFormat, br = \"en-GB\", Or = 1970, Br = 1972, kr = 12, Cr = /*@__PURE__*/ isoArgsToEpochMilli(1868, 9, 8), Yr = /*@__PURE__*/ on(computeJapaneseEraParts, WeakMap), Rr = \"smallestUnit\", Zr = \"unit\", zr = \"roundingIncrement\", Ur = \"fractionalSecondDigits\", Ar = \"relativeTo\", qr = \"direction\", Wr = {\n  constrain: 0,\n  reject: 1\n}, jr = /*@__PURE__*/ Object.keys(Wr), Lr = {\n  compatible: 0,\n  reject: 1,\n  earlier: 2,\n  later: 3\n}, xr = {\n  reject: 0,\n  use: 1,\n  prefer: 2,\n  ignore: 3\n}, $r = {\n  auto: 0,\n  never: 1,\n  critical: 2,\n  always: 3\n}, Hr = {\n  auto: 0,\n  never: 1,\n  critical: 2\n}, Gr = {\n  auto: 0,\n  never: 1\n}, Vr = {\n  floor: 0,\n  halfFloor: 1,\n  ceil: 2,\n  halfCeil: 3,\n  trunc: 4,\n  halfTrunc: 5,\n  expand: 6,\n  halfExpand: 7,\n  halfEven: 8\n}, _r = {\n  previous: -1,\n  next: 1\n}, Jr = /*@__PURE__*/ Pt(refineUnitOption, Rr), Kr = /*@__PURE__*/ Pt(refineUnitOption, \"largestUnit\"), Qr = /*@__PURE__*/ Pt(refineUnitOption, Zr), Xr = /*@__PURE__*/ Pt(refineChoiceOption, \"overflow\", Wr), ei = /*@__PURE__*/ Pt(refineChoiceOption, \"disambiguation\", Lr), ni = /*@__PURE__*/ Pt(refineChoiceOption, \"offset\", xr), ti = /*@__PURE__*/ Pt(refineChoiceOption, \"calendarName\", $r), oi = /*@__PURE__*/ Pt(refineChoiceOption, \"timeZoneName\", Hr), ri = /*@__PURE__*/ Pt(refineChoiceOption, \"offset\", Gr), ii = /*@__PURE__*/ Pt(refineChoiceOption, \"roundingMode\", Vr), Ut = \"PlainYearMonth\", qt = \"PlainMonthDay\", G = \"PlainDate\", x = \"PlainDateTime\", ft = \"PlainTime\", z = \"ZonedDateTime\", Re = \"Instant\", N = \"Duration\", ai = [ Math.floor, e => hasHalf(e) ? Math.floor(e) : Math.round(e), Math.ceil, e => hasHalf(e) ? Math.ceil(e) : Math.round(e), Math.trunc, e => hasHalf(e) ? Math.trunc(e) || 0 : Math.round(e), e => e < 0 ? Math.floor(e) : Math.ceil(e), e => Math.sign(e) * Math.round(Math.abs(e)) || 0, e => hasHalf(e) ? (e = Math.trunc(e) || 0) + e % 2 : Math.round(e) ], si = \"UTC\", ci = 5184e3, ui = /*@__PURE__*/ isoArgsToEpochSec(1847), fi = /*@__PURE__*/ isoArgsToEpochSec(/*@__PURE__*/ (/*@__PURE__*/ new Date).getUTCFullYear() + 10), li = /0+$/, he = /*@__PURE__*/ on(_zonedEpochSlotsToIso, WeakMap), di = 2 ** 32 - 1, L = /*@__PURE__*/ on((e => {\n  const n = getTimeZoneEssence(e);\n  return \"object\" == typeof n ? new IntlTimeZone(n) : new FixedTimeZone(n || 0);\n}));\n\nclass FixedTimeZone {\n  constructor(e) {\n    this.$ = e;\n  }\n  R() {\n    return this.$;\n  }\n  I(e) {\n    return (e => {\n      const n = isoToEpochNano({\n        ...e,\n        ...Nt\n      });\n      if (!n || Math.abs(n[0]) > 1e8) {\n        throw new RangeError(Io);\n      }\n    })(e), [ isoToEpochNanoWithOffset(e, this.$) ];\n  }\n  O() {}\n}\n\nclass IntlTimeZone {\n  constructor(e) {\n    this.nn = (e => {\n      function getOffsetSec(e) {\n        const i = clampNumber(e, o, r), [a, s] = computePeriod(i), c = n(a), u = n(s);\n        return c === u ? c : pinch(t(a, s), c, u, e);\n      }\n      function pinch(n, t, o, r) {\n        let i, a;\n        for (;(void 0 === r || void 0 === (i = r < n[0] ? t : r >= n[1] ? o : void 0)) && (a = n[1] - n[0]); ) {\n          const t = n[0] + Math.floor(a / 2);\n          e(t) === o ? n[1] = t : n[0] = t + 1;\n        }\n        return i;\n      }\n      const n = on(e), t = on(createSplitTuple);\n      let o = ui, r = fi;\n      return {\n        tn(e) {\n          const n = getOffsetSec(e - 86400), t = getOffsetSec(e + 86400), o = e - n, r = e - t;\n          if (n === t) {\n            return [ o ];\n          }\n          const i = getOffsetSec(o);\n          return i === getOffsetSec(r) ? [ e - i ] : n > t ? [ o, r ] : [];\n        },\n        rn: getOffsetSec,\n        O(e, i) {\n          const a = clampNumber(e, o, r);\n          let [s, c] = computePeriod(a);\n          const u = ci * i, f = i < 0 ? () => c > o || (o = a, 0) : () => s < r || (r = a, \n          0);\n          for (;f(); ) {\n            const o = n(s), r = n(c);\n            if (o !== r) {\n              const n = t(s, c);\n              pinch(n, o, r);\n              const a = n[0];\n              if ((compareNumbers(a, e) || 1) === i) {\n                return a;\n              }\n            }\n            s += u, c += u;\n          }\n        }\n      };\n    })((e => n => {\n      const t = hashIntlFormatParts(e, n * Co);\n      return isoArgsToEpochSec(parseIntlPartsYear(t), parseInt(t.month), parseInt(t.day), parseInt(t.hour), parseInt(t.minute), parseInt(t.second)) - n;\n    })(e));\n  }\n  R(e) {\n    return this.nn.rn((e => epochNanoToSecMod(e)[0])(e)) * Ro;\n  }\n  I(e) {\n    const [n, t] = [ isoArgsToEpochSec((o = e).isoYear, o.isoMonth, o.isoDay, o.isoHour, o.isoMinute, o.isoSecond), o.isoMillisecond * Qe + o.isoMicrosecond * Yo + o.isoNanosecond ];\n    var o;\n    return this.nn.tn(n).map((e => checkEpochNanoInBounds(moveBigNano(Ge(e, Ro), t))));\n  }\n  O(e, n) {\n    const [t, o] = epochNanoToSecMod(e), r = this.nn.O(t + (n > 0 || o ? 1 : 0), n);\n    if (void 0 !== r) {\n      return Ge(r, Ro);\n    }\n  }\n}\n\nconst mi = \"([+-])\", pi = \"(?:[.,](\\\\d{1,9}))?\", hi = `(?:(?:${mi}(\\\\d{6}))|(\\\\d{4}))-?(\\\\d{2})`, gi = \"(\\\\d{2})(?::?(\\\\d{2})(?::?(\\\\d{2})\" + pi + \")?)?\", Di = mi + gi, Ti = hi + \"-?(\\\\d{2})(?:[T ]\" + gi + \"(Z|\" + Di + \")?)?\", Ii = \"\\\\[(!?)([^\\\\]]*)\\\\]\", Mi = `((?:${Ii}){0,9})`, Ni = /*@__PURE__*/ createRegExp(hi + Mi), yi = /*@__PURE__*/ createRegExp(\"(?:--)?(\\\\d{2})-?(\\\\d{2})\" + Mi), vi = /*@__PURE__*/ createRegExp(Ti + Mi), Pi = /*@__PURE__*/ createRegExp(\"T?\" + gi + \"(?:\" + Di + \")?\" + Mi), Ei = /*@__PURE__*/ createRegExp(Di), Si = /*@__PURE__*/ new RegExp(Ii, \"g\"), Fi = /*@__PURE__*/ createRegExp(`${mi}?P(\\\\d+Y)?(\\\\d+M)?(\\\\d+W)?(\\\\d+D)?(?:T(?:(\\\\d+)${pi}H)?(?:(\\\\d+)${pi}M)?(?:(\\\\d+)${pi}S)?)?`), wi = /*@__PURE__*/ on((e => new en(br, {\n  timeZone: e,\n  era: \"short\",\n  year: \"numeric\",\n  month: \"numeric\",\n  day: \"numeric\",\n  hour: \"numeric\",\n  minute: \"numeric\",\n  second: \"numeric\"\n}))), bi = /^(AC|AE|AG|AR|AS|BE|BS|CA|CN|CS|CT|EA|EC|IE|IS|JS|MI|NE|NS|PL|PN|PR|PS|SS|VS)T$/, Oi = /[^\\w\\/:+-]+/, Bi = /^M(\\d{2})(L?)$/, ki = /*@__PURE__*/ on(createIntlCalendar), Ci = /*@__PURE__*/ on((e => new en(br, {\n  calendar: e,\n  timeZone: si,\n  era: \"short\",\n  year: \"numeric\",\n  month: \"short\",\n  day: \"numeric\"\n}))), Yi = {\n  P(e, n, t) {\n    const o = mt(t);\n    let r, {years: i, months: a, weeks: s, days: c} = n;\n    if (c += durationFieldsToBigNano(n, 5)[0], i || a) {\n      r = ((e, n, t, o, r) => {\n        let [i, a, s] = e.v(n);\n        if (t) {\n          const [n, o] = e.q(i, a);\n          i += t, a = monthCodeNumberToMonth(n, o, e.L(i)), a = clampEntity(\"month\", a, 1, e.B(i), r);\n        }\n        return o && ([i, a] = e.un(i, a, o)), s = clampEntity(\"day\", s, 1, e.U(i, a), r), \n        e.p(i, a, s);\n      })(this, e, i, a, o);\n    } else {\n      if (!s && !c) {\n        return e;\n      }\n      r = isoToEpochMilli(e);\n    }\n    if (void 0 === r) {\n      throw new RangeError(Io);\n    }\n    return r += (7 * s + c) * ko, checkIsoDateInBounds(epochMilliToIso(r));\n  },\n  N(e, n, t) {\n    if (t <= 7) {\n      let o = 0, r = diffDays({\n        ...e,\n        ...Nt\n      }, {\n        ...n,\n        ...Nt\n      });\n      return 7 === t && ([o, r] = divModTrunc(r, 7)), {\n        ...pr,\n        weeks: o,\n        days: r\n      };\n    }\n    const o = this.v(e), r = this.v(n);\n    let [i, a, s] = ((e, n, t, o, r, i, a) => {\n      let s = r - n, c = i - t, u = a - o;\n      if (s || c) {\n        const f = Math.sign(s || c);\n        let l = e.U(r, i), d = 0;\n        if (Math.sign(u) === -f) {\n          const o = l;\n          [r, i] = e.un(r, i, -f), s = r - n, c = i - t, l = e.U(r, i), d = f < 0 ? -o : l;\n        }\n        if (u = a - Math.min(o, l) + d, s) {\n          const [o, a] = e.q(n, t), [u, l] = e.q(r, i);\n          if (c = u - o || Number(l) - Number(a), Math.sign(c) === -f) {\n            const t = f < 0 && -e.B(r);\n            s = (r -= f) - n, c = i - monthCodeNumberToMonth(o, a, e.L(r)) + (t || e.B(r));\n          }\n        }\n      }\n      return [ s, c, u ];\n    })(this, ...o, ...r);\n    return 8 === t && (a += this.cn(i, o[0]), i = 0), {\n      ...pr,\n      years: i,\n      months: a,\n      days: s\n    };\n  },\n  F(e, n) {\n    const t = mt(n), o = refineYear(this, e), r = refineMonth(this, e, o, t), i = refineDay(this, e, r, o, t);\n    return W(checkIsoDateInBounds(this.V(o, r, i)), this.id || l);\n  },\n  K(e, n) {\n    const t = mt(n), o = refineYear(this, e), r = refineMonth(this, e, o, t);\n    return createPlainYearMonthSlots(checkIsoYearMonthInBounds(this.V(o, r, 1)), this.id || l);\n  },\n  _(e, n) {\n    const t = mt(n);\n    let o, r, i, a = void 0 !== e.eraYear || void 0 !== e.year ? refineYear(this, e) : void 0;\n    const s = !this.id;\n    if (void 0 === a && s && (a = Br), void 0 !== a) {\n      const n = refineMonth(this, e, a, t);\n      o = refineDay(this, e, n, a, t);\n      const s = this.L(a);\n      r = monthToMonthCodeNumber(n, s), i = n === s;\n    } else {\n      if (void 0 === e.monthCode) {\n        throw new TypeError(co);\n      }\n      if ([r, i] = parseMonthCode(e.monthCode), this.id && this.id !== or && this.id !== rr) {\n        if (this.id && \"coptic\" === computeCalendarIdBase(this.id) && 0 === t) {\n          const n = i || 13 !== r ? 30 : 6;\n          o = e.day, o = clampNumber(o, 1, n);\n        } else if (this.id && \"chinese\" === computeCalendarIdBase(this.id) && 0 === t) {\n          const n = !i || 1 !== r && 9 !== r && 10 !== r && 11 !== r && 12 !== r ? 30 : 29;\n          o = e.day, o = clampNumber(o, 1, n);\n        } else {\n          o = e.day;\n        }\n      } else {\n        o = refineDay(this, e, refineMonth(this, e, Br, t), Br, t);\n      }\n    }\n    const c = this.G(r, i, o);\n    if (!c) {\n      throw new RangeError(\"Cannot guess year\");\n    }\n    const [u, f] = c;\n    return createPlainMonthDaySlots(checkIsoDateInBounds(this.V(u, f, o)), this.id || l);\n  },\n  fields(e) {\n    return getCalendarEraOrigins(this) && e.includes(\"year\") ? [ ...e, ...$o ] : e;\n  },\n  k(e, n) {\n    const t = Object.assign(Object.create(null), e);\n    return spliceFields(t, n, _o), getCalendarEraOrigins(this) && (spliceFields(t, n, Ho), \n    this.id === rr && spliceFields(t, n, er, $o)), t;\n  },\n  inLeapYear(e) {\n    const [n] = this.v(e);\n    return this.sn(n);\n  },\n  monthsInYear(e) {\n    const [n] = this.v(e);\n    return this.B(n);\n  },\n  daysInMonth(e) {\n    const [n, t] = this.v(e);\n    return this.U(n, t);\n  },\n  daysInYear(e) {\n    const [n] = this.v(e);\n    return this.fn(n);\n  },\n  dayOfYear: computeNativeDayOfYear,\n  era(e) {\n    return this.hn(e)[0];\n  },\n  eraYear(e) {\n    return this.hn(e)[1];\n  },\n  monthCode(e) {\n    const [n, t] = this.v(e), [o, r] = this.q(n, t);\n    return formatMonthCode(o, r);\n  },\n  dayOfWeek: computeIsoDayOfWeek,\n  daysInWeek() {\n    return 7;\n  }\n}, Ri = {\n  v: computeIsoDateParts,\n  hn: computeIsoEraParts,\n  q: computeIsoMonthCodeParts\n}, Zi = {\n  dayOfYear: computeNativeDayOfYear,\n  v: computeIsoDateParts,\n  p: isoArgsToEpochMilli\n}, zi = /*@__PURE__*/ Object.assign({}, Zi, {\n  weekOfYear: computeNativeWeekOfYear,\n  yearOfWeek: computeNativeYearOfWeek,\n  m(e) {\n    function computeWeekShift(e) {\n      return (7 - e < n ? 7 : 0) - e;\n    }\n    function computeWeeksInYear(e) {\n      const n = computeIsoDaysInYear(f + e), t = e || 1, o = computeWeekShift(modFloor(a + n * t, 7));\n      return c = (n + (o - s) * t) / 7;\n    }\n    const n = this.id ? 1 : 4, t = computeIsoDayOfWeek(e), o = this.dayOfYear(e), r = modFloor(t - 1, 7), i = o - 1, a = modFloor(r - i, 7), s = computeWeekShift(a);\n    let c, u = Math.floor((i - s) / 7) + 1, f = e.isoYear;\n    return u ? u > computeWeeksInYear(0) && (u = 1, f++) : (u = computeWeeksInYear(-1), \n    f--), [ u, f, c ];\n  }\n}), Ui = /*@__PURE__*/ Object.assign({}, Yi, zi, {\n  v: computeIsoDateParts,\n  hn: computeIsoEraParts,\n  q: computeIsoMonthCodeParts,\n  G(e, n) {\n    if (!n) {\n      return [ Br, e ];\n    }\n  },\n  sn: computeIsoInLeapYear,\n  L() {},\n  B: computeIsoMonthsInYear,\n  cn: e => e * kr,\n  U: computeIsoDaysInMonth,\n  fn: computeIsoDaysInYear,\n  V: (e, n, t) => ({\n    isoYear: e,\n    isoMonth: n,\n    isoDay: t\n  }),\n  p: isoArgsToEpochMilli,\n  un: (e, n, t) => (e += divTrunc(t, kr), (n += modTrunc(t, kr)) < 1 ? (e--, n += kr) : n > kr && (e++, \n  n -= kr), [ e, n ]),\n  year(e) {\n    return e.isoYear;\n  },\n  month(e) {\n    return e.isoMonth;\n  },\n  day: e => e.isoDay\n}), Ai = {\n  v: computeIntlDateParts,\n  hn: computeIntlEraParts,\n  q: computeIntlMonthCodeParts\n}, qi = {\n  dayOfYear: computeNativeDayOfYear,\n  v: computeIntlDateParts,\n  p: computeIntlEpochMilli,\n  weekOfYear: computeNativeWeekOfYear,\n  yearOfWeek: computeNativeYearOfWeek,\n  m() {\n    return [];\n  }\n}, Wi = /*@__PURE__*/ Object.assign({}, Yi, qi, {\n  v: computeIntlDateParts,\n  hn: computeIntlEraParts,\n  q: computeIntlMonthCodeParts,\n  G(e, n, t) {\n    const o = this.id && \"chinese\" === computeCalendarIdBase(this.id) ? ((e, n, t) => {\n      if (n) {\n        switch (e) {\n         case 1:\n          return 1651;\n\n         case 2:\n          return t < 30 ? 1947 : 1765;\n\n         case 3:\n          return t < 30 ? 1966 : 1955;\n\n         case 4:\n          return t < 30 ? 1963 : 1944;\n\n         case 5:\n          return t < 30 ? 1971 : 1952;\n\n         case 6:\n          return t < 30 ? 1960 : 1941;\n\n         case 7:\n          return t < 30 ? 1968 : 1938;\n\n         case 8:\n          return t < 30 ? 1957 : 1718;\n\n         case 9:\n          return 1832;\n\n         case 10:\n          return 1870;\n\n         case 11:\n          return 1814;\n\n         case 12:\n          return 1890;\n        }\n      }\n      return 1972;\n    })(e, n, t) : Br;\n    let [r, i, a] = computeIntlDateParts.call(this, {\n      isoYear: o,\n      isoMonth: kr,\n      isoDay: 31\n    });\n    const s = computeIntlLeapMonth.call(this, r), c = i === s;\n    1 === (compareNumbers(e, monthToMonthCodeNumber(i, s)) || compareNumbers(Number(n), Number(c)) || compareNumbers(t, a)) && r--;\n    for (let o = 0; o < 100; o++) {\n      const i = r - o, a = computeIntlLeapMonth.call(this, i), s = monthCodeNumberToMonth(e, n, a);\n      if (n === (s === a) && t <= computeIntlDaysInMonth.call(this, i, s)) {\n        return [ i, s ];\n      }\n    }\n  },\n  sn(e) {\n    const n = computeIntlDaysInYear.call(this, e);\n    return n > computeIntlDaysInYear.call(this, e - 1) && n > computeIntlDaysInYear.call(this, e + 1);\n  },\n  L: computeIntlLeapMonth,\n  B: computeIntlMonthsInYear,\n  cn(e, n) {\n    const t = n + e, o = Math.sign(e), r = o < 0 ? -1 : 0;\n    let i = 0;\n    for (let e = n; e !== t; e += o) {\n      i += computeIntlMonthsInYear.call(this, e + r);\n    }\n    return i;\n  },\n  U: computeIntlDaysInMonth,\n  fn: computeIntlDaysInYear,\n  V(e, n, t) {\n    return epochMilliToIso(computeIntlEpochMilli.call(this, e, n, t));\n  },\n  p: computeIntlEpochMilli,\n  un(e, n, t) {\n    if (t) {\n      if (n += t, !Number.isSafeInteger(n)) {\n        throw new RangeError(Io);\n      }\n      if (t < 0) {\n        for (;n < 1; ) {\n          n += computeIntlMonthsInYear.call(this, --e);\n        }\n      } else {\n        let t;\n        for (;n > (t = computeIntlMonthsInYear.call(this, e)); ) {\n          n -= t, e++;\n        }\n      }\n    }\n    return [ e, n ];\n  },\n  year(e) {\n    return this.h(e).year;\n  },\n  month(e) {\n    const {year: n, o: t} = this.h(e), {u: o} = this.l(n);\n    return o[t] + 1;\n  },\n  day(e) {\n    return this.h(e).day;\n  }\n}), ji = /*@__PURE__*/ createNativeOpsCreator(Ri, Ai), C = /*@__PURE__*/ createNativeOpsCreator(Ui, Wi), Li = {\n  ...{\n    era: toStringViaPrimitive,\n    eraYear: toInteger,\n    year: toInteger,\n    month: toPositiveInteger,\n    monthCode(e) {\n      const n = toStringViaPrimitive(e);\n      return parseMonthCode(n), n;\n    },\n    day: toPositiveInteger\n  },\n  .../*@__PURE__*/ wo(O, toInteger),\n  .../*@__PURE__*/ wo(p, toStrictInteger),\n  offset(e) {\n    const n = toStringViaPrimitive(e);\n    return parseOffsetNano(n), n;\n  }\n}, xi = /*@__PURE__*/ Pt(remapProps, O, w), $i = /*@__PURE__*/ Pt(remapProps, w, O), Hi = \"numeric\", Gi = [ \"timeZoneName\" ], Vi = {\n  month: Hi,\n  day: Hi\n}, _i = {\n  year: Hi,\n  month: Hi\n}, Ji = /*@__PURE__*/ Object.assign({}, _i, {\n  day: Hi\n}), Ki = {\n  hour: Hi,\n  minute: Hi,\n  second: Hi\n}, Qi = /*@__PURE__*/ Object.assign({}, Ji, Ki), Xi = /*@__PURE__*/ Object.assign({}, Qi, {\n  timeZoneName: \"short\"\n}), ea = /*@__PURE__*/ Object.keys(_i), na = /*@__PURE__*/ Object.keys(Vi), ta = /*@__PURE__*/ Object.keys(Ji), oa = /*@__PURE__*/ Object.keys(Ki), ra = [ \"dateStyle\" ], ia = /*@__PURE__*/ ea.concat(ra), aa = /*@__PURE__*/ na.concat(ra), sa = /*@__PURE__*/ ta.concat(ra, [ \"weekday\" ]), ca = /*@__PURE__*/ oa.concat([ \"dayPeriod\", \"timeStyle\", \"fractionalSecondDigits\" ]), ua = /*@__PURE__*/ sa.concat(ca), fa = /*@__PURE__*/ Gi.concat(ca), la = /*@__PURE__*/ Gi.concat(sa), da = /*@__PURE__*/ Gi.concat([ \"day\", \"weekday\" ], ca), ma = /*@__PURE__*/ Gi.concat([ \"year\", \"weekday\" ], ca), pa = /*@__PURE__*/ createOptionsTransformer(ua, Qi), ha = /*@__PURE__*/ createOptionsTransformer(ua, Xi), ga = /*@__PURE__*/ createOptionsTransformer(ua, Qi, Gi), Da = /*@__PURE__*/ createOptionsTransformer(sa, Ji, fa), Ta = /*@__PURE__*/ createOptionsTransformer(ca, Ki, la), Ia = /*@__PURE__*/ createOptionsTransformer(ia, _i, da), Ma = /*@__PURE__*/ createOptionsTransformer(aa, Vi, ma), Na = {}, ya = /*@__PURE__*/ new en(void 0, {\n  calendar: l\n}).resolvedOptions().calendar === l, U = [ pa, I ], ot = [ ha, I, 0, (e, n) => {\n  const t = e.timeZone;\n  if (n && n.timeZone !== t) {\n    throw new RangeError(mo);\n  }\n  return t;\n} ], X = [ ga, isoToEpochMilli ], _ = [ Da, isoToEpochMilli ], tt = [ Ta, e => isoTimeFieldsToNano(e) / Qe ], et = [ Ia, isoToEpochMilli, ya ], nt = [ Ma, isoToEpochMilli, ya ];\n\nlet va;\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvY2h1bmtzL2ludGVybmFsLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsY0FBYztBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsT0FBTztBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLFdBQVc7QUFDeEM7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxZQUFZO0FBQ3ZCO0FBQ0E7QUFDQSw2Q0FBNkMsb0JBQW9CO0FBQ2pFO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLFlBQVk7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSwyQkFBMkI7QUFDM0I7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxPQUFPLCtDQUErQztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLDBCQUEwQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVE7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxXQUFXLFNBQVMsa0RBQWtELHNCQUFzQjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMscUJBQXFCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLGFBQWE7QUFDdEI7QUFDQTs7QUFFQTtBQUNBLFNBQVMsYUFBYTtBQUN0QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUSxtQkFBbUI7QUFDM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUyxXQUFXO0FBQ3BCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLGFBQWE7QUFDdkM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0IsRUFBRTtBQUMxQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVMsdUJBQXVCLGNBQWMsTUFBTTtBQUNwRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixPQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTLE1BQU07QUFDZjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBLFNBQVMsMEJBQTBCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU8sNkJBQTZCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsT0FBTyx3QkFBd0I7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsaURBQWlELEVBQUUsSUFBSSxFQUFFLGdEQUFnRCxFQUFFLElBQUksRUFBRSw0Q0FBNEMsRUFBRSxJQUFJLEVBQUUsOERBQThELEVBQUUsMkNBQTJDLEVBQUUsNktBQTZLLGtCQUFrQixFQUFFLEdBQUcsRUFBRSx3Q0FBd0MsRUFBRSxJQUFJLEVBQUUsa0NBQWtDLEVBQUUsMENBQTBDLEVBQUUsNkNBQTZDLEVBQUUsaUlBQWlJLDZOQUE2TixFQUFFLGdIQUFnSCxFQUFFLCtxQkFBK3FCLEVBQUUsaURBQWlELEVBQUUsOEJBQThCLEVBQUU7QUFDNzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywrRkFBK0Y7QUFDN0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUNBQXVDLElBQUksb0JBQW9CLEdBQUcsS0FBSyxFQUFFLFFBQVEsRUFBRSxTQUFTLEVBQUUsZUFBZSxFQUFFLFdBQVcsRUFBRSxXQUFXLEVBQUUsa0RBQWtELEVBQUUsOEVBQThFLEdBQUcsRUFBRSxJQUFJLDJGQUEyRixFQUFFLFFBQVEsRUFBRSx5T0FBeU8sR0FBRyxpREFBaUQsR0FBRyxjQUFjLEdBQUcsY0FBYyxHQUFHO0FBQzdyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw2SEFBNkgsRUFBRTtBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLFlBQVksd0NBQXdDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUMscUNBQXFDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsc0NBQXNDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0Esb0JBQW9CLFNBQVM7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixTQUFTO0FBQzdCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsY0FBYyxpREFBaUQ7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsV0FBVyxlQUFlLGNBQWMsTUFBTTtBQUM5QztBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUM7QUFDdEM7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxxQ0FBcUMsOENBQThDO0FBQ3BGO0FBQ0EsQ0FBQyx5OUJBQXk5QjtBQUMxOUI7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRTIxSSIsInNvdXJjZXMiOlsiL1VzZXJzL25pa2l0YS9EZXNrdG9wL2ZvY3VzcGhlcmUvbm9kZV9tb2R1bGVzL3RlbXBvcmFsLXBvbHlmaWxsL2NodW5rcy9pbnRlcm5hbC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJmdW5jdGlvbiBjbGFtcFByb3AoZSwgbiwgdCwgbywgcikge1xuICByZXR1cm4gY2xhbXBFbnRpdHkobiwgKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IGVbbl07XG4gICAgaWYgKHZvaWQgMCA9PT0gdCkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihtaXNzaW5nRmllbGQobikpO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbiAgfSkoZSwgbiksIHQsIG8sIHIpO1xufVxuXG5mdW5jdGlvbiBjbGFtcEVudGl0eShlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBjbGFtcE51bWJlcihuLCB0LCBvKTtcbiAgaWYgKHIgJiYgbiAhPT0gYSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG51bWJlck91dE9mUmFuZ2UoZSwgbiwgdCwgbywgaSkpO1xuICB9XG4gIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBzKGUpIHtcbiAgcmV0dXJuIG51bGwgIT09IGUgJiYgL29iamVjdHxmdW5jdGlvbi8udGVzdCh0eXBlb2YgZSk7XG59XG5cbmZ1bmN0aW9uIG9uKGUsIG4gPSBNYXApIHtcbiAgY29uc3QgdCA9IG5ldyBuO1xuICByZXR1cm4gKG4sIC4uLm8pID0+IHtcbiAgICBpZiAodC5oYXMobikpIHtcbiAgICAgIHJldHVybiB0LmdldChuKTtcbiAgICB9XG4gICAgY29uc3QgciA9IGUobiwgLi4ubyk7XG4gICAgcmV0dXJuIHQuc2V0KG4sIHIpLCByO1xuICB9O1xufVxuXG5mdW5jdGlvbiByKGUpIHtcbiAgcmV0dXJuIG4oe1xuICAgIG5hbWU6IGVcbiAgfSwgMSk7XG59XG5cbmZ1bmN0aW9uIG4obiwgdCkge1xuICByZXR1cm4gZSgoZSA9PiAoe1xuICAgIHZhbHVlOiBlLFxuICAgIGNvbmZpZ3VyYWJsZTogMSxcbiAgICB3cml0YWJsZTogIXRcbiAgfSkpLCBuKTtcbn1cblxuZnVuY3Rpb24gdChuKSB7XG4gIHJldHVybiBlKChlID0+ICh7XG4gICAgZ2V0OiBlLFxuICAgIGNvbmZpZ3VyYWJsZTogMVxuICB9KSksIG4pO1xufVxuXG5mdW5jdGlvbiBvKGUpIHtcbiAgcmV0dXJuIHtcbiAgICBbU3ltYm9sLnRvU3RyaW5nVGFnXToge1xuICAgICAgdmFsdWU6IGUsXG4gICAgICBjb25maWd1cmFibGU6IDFcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHppcFByb3BzKGUsIG4pIHtcbiAgY29uc3QgdCA9IHt9O1xuICBsZXQgbyA9IGUubGVuZ3RoO1xuICBmb3IgKGNvbnN0IHIgb2Ygbikge1xuICAgIHRbZVstLW9dXSA9IHI7XG4gIH1cbiAgcmV0dXJuIHQ7XG59XG5cbmZ1bmN0aW9uIGUoZSwgbiwgdCkge1xuICBjb25zdCBvID0ge307XG4gIGZvciAoY29uc3QgciBpbiBuKSB7XG4gICAgb1tyXSA9IGUobltyXSwgciwgdCk7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIGcoZSwgbiwgdCkge1xuICBjb25zdCBvID0ge307XG4gIGZvciAobGV0IHIgPSAwOyByIDwgbi5sZW5ndGg7IHIrKykge1xuICAgIGNvbnN0IGkgPSBuW3JdO1xuICAgIG9baV0gPSBlKGksIHIsIHQpO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiByZW1hcFByb3BzKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHt9O1xuICBmb3IgKGxldCByID0gMDsgciA8IGUubGVuZ3RoOyByKyspIHtcbiAgICBvW25bcl1dID0gdFtlW3JdXTtcbiAgfVxuICByZXR1cm4gbztcbn1cblxuZnVuY3Rpb24gbm4oZSwgbikge1xuICBjb25zdCB0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBvIG9mIGUpIHtcbiAgICB0W29dID0gbltvXTtcbiAgfVxuICByZXR1cm4gdDtcbn1cblxuZnVuY3Rpb24gaGFzQW55UHJvcHNCeU5hbWUoZSwgbikge1xuICBmb3IgKGNvbnN0IHQgb2Ygbikge1xuICAgIGlmICh0IGluIGUpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMDtcbn1cblxuZnVuY3Rpb24gYWxsUHJvcHNFcXVhbChlLCBuLCB0KSB7XG4gIGZvciAoY29uc3QgbyBvZiBlKSB7XG4gICAgaWYgKG5bb10gIT09IHRbb10pIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgfVxuICByZXR1cm4gMTtcbn1cblxuZnVuY3Rpb24gemVyb091dFByb3BzKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHtcbiAgICAuLi50XG4gIH07XG4gIGZvciAobGV0IHQgPSAwOyB0IDwgbjsgdCsrKSB7XG4gICAgb1tlW3RdXSA9IDA7XG4gIH1cbiAgcmV0dXJuIG87XG59XG5cbmZ1bmN0aW9uIFB0KGUsIC4uLm4pIHtcbiAgcmV0dXJuICguLi50KSA9PiBlKC4uLm4sIC4uLnQpO1xufVxuXG5mdW5jdGlvbiBjYXBpdGFsaXplKGUpIHtcbiAgcmV0dXJuIGVbMF0udG9VcHBlckNhc2UoKSArIGUuc3Vic3RyaW5nKDEpO1xufVxuXG5mdW5jdGlvbiBzb3J0U3RyaW5ncyhlKSB7XG4gIHJldHVybiBlLnNsaWNlKCkuc29ydCgpO1xufVxuXG5mdW5jdGlvbiBwYWROdW1iZXIoZSwgbikge1xuICByZXR1cm4gU3RyaW5nKG4pLnBhZFN0YXJ0KGUsIFwiMFwiKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU51bWJlcnMoZSwgbikge1xuICByZXR1cm4gTWF0aC5zaWduKGUgLSBuKTtcbn1cblxuZnVuY3Rpb24gY2xhbXBOdW1iZXIoZSwgbiwgdCkge1xuICByZXR1cm4gTWF0aC5taW4oTWF0aC5tYXgoZSwgbiksIHQpO1xufVxuXG5mdW5jdGlvbiBkaXZNb2RGbG9vcihlLCBuKSB7XG4gIHJldHVybiBbIE1hdGguZmxvb3IoZSAvIG4pLCBtb2RGbG9vcihlLCBuKSBdO1xufVxuXG5mdW5jdGlvbiBtb2RGbG9vcihlLCBuKSB7XG4gIHJldHVybiAoZSAlIG4gKyBuKSAlIG47XG59XG5cbmZ1bmN0aW9uIGRpdk1vZFRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIFsgZGl2VHJ1bmMoZSwgbiksIG1vZFRydW5jKGUsIG4pIF07XG59XG5cbmZ1bmN0aW9uIGRpdlRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmMoZSAvIG4pIHx8IDA7XG59XG5cbmZ1bmN0aW9uIG1vZFRydW5jKGUsIG4pIHtcbiAgcmV0dXJuIGUgJSBuIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGhhc0hhbGYoZSkge1xuICByZXR1cm4gLjUgPT09IE1hdGguYWJzKGUgJSAxKTtcbn1cblxuZnVuY3Rpb24gZ2l2ZW5GaWVsZHNUb0JpZ05hbm8oZSwgbiwgdCkge1xuICBsZXQgbyA9IDAsIHIgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8PSBuOyBpKyspIHtcbiAgICBjb25zdCBuID0gZVt0W2ldXSwgYSA9IEFvW2ldLCBzID0gVW8gLyBhLCBbYywgdV0gPSBkaXZNb2RUcnVuYyhuLCBzKTtcbiAgICBvICs9IHUgKiBhLCByICs9IGM7XG4gIH1cbiAgY29uc3QgW2ksIGFdID0gZGl2TW9kVHJ1bmMobywgVW8pO1xuICByZXR1cm4gWyByICsgaSwgYSBdO1xufVxuXG5mdW5jdGlvbiBuYW5vVG9HaXZlbkZpZWxkcyhlLCBuLCB0KSB7XG4gIGNvbnN0IG8gPSB7fTtcbiAgZm9yIChsZXQgciA9IG47IHIgPj0gMDsgci0tKSB7XG4gICAgY29uc3QgbiA9IEFvW3JdO1xuICAgIG9bdFtyXV0gPSBkaXZUcnVuYyhlLCBuKSwgZSA9IG1vZFRydW5jKGUsIG4pO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBkKGUpIHtcbiAgaWYgKHZvaWQgMCAhPT0gZSkge1xuICAgIHJldHVybiBtKGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIFAoZSkge1xuICBpZiAodm9pZCAwICE9PSBlKSB7XG4gICAgcmV0dXJuIGgoZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gUyhlKSB7XG4gIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICByZXR1cm4gVChlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoKGUpIHtcbiAgcmV0dXJuIHJlcXVpcmVOdW1iZXJJc1Bvc2l0aXZlKFQoZSkpO1xufVxuXG5mdW5jdGlvbiBUKGUpIHtcbiAgcmV0dXJuIHplKGNyKGUpKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZVByb3BEZWZpbmVkKGUsIG4pIHtcbiAgaWYgKG51bGwgPT0gbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1pc3NpbmdGaWVsZChlKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVPYmplY3RMaWtlKGUpIHtcbiAgaWYgKCFzKGUpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihvbyk7XG4gIH1cbiAgcmV0dXJuIGU7XG59XG5cbmZ1bmN0aW9uIHJlcXVpcmVUeXBlKGUsIG4sIHQgPSBlKSB7XG4gIGlmICh0eXBlb2YgbiAhPT0gZSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoaW52YWxpZEVudGl0eSh0LCBuKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIHplKGUsIG4gPSBcIm51bWJlclwiKSB7XG4gIGlmICghTnVtYmVyLmlzSW50ZWdlcihlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkSW50ZWdlcihuLCBlKSk7XG4gIH1cbiAgcmV0dXJuIGUgfHwgMDtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZU51bWJlcklzUG9zaXRpdmUoZSwgbiA9IFwibnVtYmVyXCIpIHtcbiAgaWYgKGUgPD0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkUG9zaXRpdmUobiwgZSkpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiB0b1N0cmluZyhlKSB7XG4gIGlmIChcInN5bWJvbFwiID09IHR5cGVvZiBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihubyk7XG4gIH1cbiAgcmV0dXJuIFN0cmluZyhlKTtcbn1cblxuZnVuY3Rpb24gdG9TdHJpbmdWaWFQcmltaXRpdmUoZSwgbikge1xuICByZXR1cm4gcyhlKSA/IFN0cmluZyhlKSA6IG0oZSwgbik7XG59XG5cbmZ1bmN0aW9uIHRvQmlnSW50KGUpIHtcbiAgaWYgKFwic3RyaW5nXCIgPT0gdHlwZW9mIGUpIHtcbiAgICByZXR1cm4gQmlnSW50KGUpO1xuICB9XG4gIGlmIChcImJpZ2ludFwiICE9IHR5cGVvZiBlKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihpbnZhbGlkQmlnSW50KGUpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gdG9OdW1iZXIoZSwgbiA9IFwibnVtYmVyXCIpIHtcbiAgaWYgKFwiYmlnaW50XCIgPT0gdHlwZW9mIGUpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZvcmJpZGRlbkJpZ0ludFRvTnVtYmVyKG4pKTtcbiAgfVxuICBpZiAoZSA9IE51bWJlcihlKSwgIU51bWJlci5pc0Zpbml0ZShlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGV4cGVjdGVkRmluaXRlKG4sIGUpKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gdG9JbnRlZ2VyKGUsIG4pIHtcbiAgcmV0dXJuIE1hdGgudHJ1bmModG9OdW1iZXIoZSwgbikpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHRvU3RyaWN0SW50ZWdlcihlLCBuKSB7XG4gIHJldHVybiB6ZSh0b051bWJlcihlLCBuKSwgbik7XG59XG5cbmZ1bmN0aW9uIHRvUG9zaXRpdmVJbnRlZ2VyKGUsIG4pIHtcbiAgcmV0dXJuIHJlcXVpcmVOdW1iZXJJc1Bvc2l0aXZlKHRvSW50ZWdlcihlLCBuKSwgbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJpZ05hbm8oZSwgbikge1xuICBsZXQgW3QsIG9dID0gZGl2TW9kVHJ1bmMobiwgVW8pLCByID0gZSArIHQ7XG4gIGNvbnN0IGkgPSBNYXRoLnNpZ24ocik7XG4gIHJldHVybiBpICYmIGkgPT09IC1NYXRoLnNpZ24obykgJiYgKHIgLT0gaSwgbyArPSBpICogVW8pLCBbIHIsIG8gXTtcbn1cblxuZnVuY3Rpb24gYWRkQmlnTmFub3MoZSwgbiwgdCA9IDEpIHtcbiAgcmV0dXJuIGNyZWF0ZUJpZ05hbm8oZVswXSArIG5bMF0gKiB0LCBlWzFdICsgblsxXSAqIHQpO1xufVxuXG5mdW5jdGlvbiBtb3ZlQmlnTmFubyhlLCBuKSB7XG4gIHJldHVybiBjcmVhdGVCaWdOYW5vKGVbMF0sIGVbMV0gKyBuKTtcbn1cblxuZnVuY3Rpb24gZGlmZkJpZ05hbm9zKGUsIG4pIHtcbiAgcmV0dXJuIGFkZEJpZ05hbm9zKG4sIGUsIC0xKTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZUJpZ05hbm9zKGUsIG4pIHtcbiAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGVbMF0sIG5bMF0pIHx8IGNvbXBhcmVOdW1iZXJzKGVbMV0sIG5bMV0pO1xufVxuXG5mdW5jdGlvbiBiaWdOYW5vT3V0c2lkZShlLCBuLCB0KSB7XG4gIHJldHVybiAtMSA9PT0gY29tcGFyZUJpZ05hbm9zKGUsIG4pIHx8IDEgPT09IGNvbXBhcmVCaWdOYW5vcyhlLCB0KTtcbn1cblxuZnVuY3Rpb24gYmlnSW50VG9CaWdOYW5vKGUsIG4gPSAxKSB7XG4gIGNvbnN0IHQgPSBCaWdJbnQoVW8gLyBuKTtcbiAgcmV0dXJuIFsgTnVtYmVyKGUgLyB0KSwgTnVtYmVyKGUgJSB0KSAqIG4gXTtcbn1cblxuZnVuY3Rpb24gR2UoZSwgbiA9IDEpIHtcbiAgY29uc3QgdCA9IFVvIC8gbiwgW28sIHJdID0gZGl2TW9kVHJ1bmMoZSwgdCk7XG4gIHJldHVybiBbIG8sIHIgKiBuIF07XG59XG5cbmZ1bmN0aW9uIGJpZ05hbm9Ub051bWJlcihlLCBuID0gMSwgdCkge1xuICBjb25zdCBbbywgcl0gPSBlLCBbaSwgYV0gPSBkaXZNb2RUcnVuYyhyLCBuKTtcbiAgcmV0dXJuIG8gKiAoVW8gLyBuKSArIChpICsgKHQgPyBhIC8gbiA6IDApKTtcbn1cblxuZnVuY3Rpb24gZGl2TW9kQmlnTmFubyhlLCBuLCB0ID0gZGl2TW9kRmxvb3IpIHtcbiAgY29uc3QgW28sIHJdID0gZSwgW2ksIGFdID0gdChyLCBuKTtcbiAgcmV0dXJuIFsgbyAqIChVbyAvIG4pICsgaSwgYSBdO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb1llYXJNb250aEluQm91bmRzKGUpIHtcbiAgcmV0dXJuIGNsYW1wUHJvcChlLCBcImlzb1llYXJcIiwgd3IsIEZyLCAxKSwgZS5pc29ZZWFyID09PSB3ciA/IGNsYW1wUHJvcChlLCBcImlzb01vbnRoXCIsIDQsIDEyLCAxKSA6IGUuaXNvWWVhciA9PT0gRnIgJiYgY2xhbXBQcm9wKGUsIFwiaXNvTW9udGhcIiwgMSwgOSwgMSksIFxuICBlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb0RhdGVJbkJvdW5kcyhlKSB7XG4gIHJldHVybiBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLmUsXG4gICAgLi4uTnQsXG4gICAgaXNvSG91cjogMTJcbiAgfSksIGU7XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyhlKSB7XG4gIGNvbnN0IG4gPSBjbGFtcFByb3AoZSwgXCJpc29ZZWFyXCIsIHdyLCBGciwgMSksIHQgPSBuID09PSB3ciA/IDEgOiBuID09PSBGciA/IC0xIDogMDtcbiAgcmV0dXJuIHQgJiYgY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhpc29Ub0Vwb2NoTmFubyh7XG4gICAgLi4uZSxcbiAgICBpc29EYXk6IGUuaXNvRGF5ICsgdCxcbiAgICBpc29OYW5vc2Vjb25kOiBlLmlzb05hbm9zZWNvbmQgLSB0XG4gIH0pKSwgZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhlKSB7XG4gIGlmICghZSB8fCBiaWdOYW5vT3V0c2lkZShlLCBTciwgRXIpKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBpc29UaW1lRmllbGRzVG9OYW5vKGUpIHtcbiAgcmV0dXJuIGdpdmVuRmllbGRzVG9CaWdOYW5vKGUsIDUsIHcpWzFdO1xufVxuXG5mdW5jdGlvbiBuYW5vVG9Jc29UaW1lQW5kRGF5KGUpIHtcbiAgY29uc3QgW24sIHRdID0gZGl2TW9kRmxvb3IoZSwgVW8pO1xuICByZXR1cm4gWyBuYW5vVG9HaXZlbkZpZWxkcyh0LCA1LCB3KSwgbiBdO1xufVxuXG5mdW5jdGlvbiBlcG9jaE5hbm9Ub1NlY01vZChlKSB7XG4gIHJldHVybiBkaXZNb2RCaWdOYW5vKGUsIFJvKTtcbn1cblxuZnVuY3Rpb24gaXNvVG9FcG9jaE1pbGxpKGUpIHtcbiAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSwgZS5pc29Ib3VyLCBlLmlzb01pbnV0ZSwgZS5pc29TZWNvbmQsIGUuaXNvTWlsbGlzZWNvbmQpO1xufVxuXG5mdW5jdGlvbiBpc29Ub0Vwb2NoTmFubyhlKSB7XG4gIGNvbnN0IG4gPSBpc29Ub0Vwb2NoTWlsbGkoZSk7XG4gIGlmICh2b2lkIDAgIT09IG4pIHtcbiAgICBjb25zdCBbdCwgb10gPSBkaXZNb2RUcnVuYyhuLCBrbyk7XG4gICAgcmV0dXJuIFsgdCwgbyAqIFFlICsgKGUuaXNvTWljcm9zZWNvbmQgfHwgMCkgKiBZbyArIChlLmlzb05hbm9zZWNvbmQgfHwgMCkgXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc29Ub0Vwb2NoTmFub1dpdGhPZmZzZXQoZSwgbikge1xuICBjb25zdCBbdCwgb10gPSBuYW5vVG9Jc29UaW1lQW5kRGF5KGlzb1RpbWVGaWVsZHNUb05hbm8oZSkgLSBuKTtcbiAgcmV0dXJuIGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoaXNvVG9FcG9jaE5hbm8oe1xuICAgIC4uLmUsXG4gICAgaXNvRGF5OiBlLmlzb0RheSArIG8sXG4gICAgLi4udFxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGlzb0FyZ3NUb0Vwb2NoU2VjKC4uLmUpIHtcbiAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoLi4uZSkgLyBDbztcbn1cblxuZnVuY3Rpb24gaXNvQXJnc1RvRXBvY2hNaWxsaSguLi5lKSB7XG4gIGNvbnN0IFtuLCB0XSA9IGlzb1RvTGVnYWN5RGF0ZSguLi5lKSwgbyA9IG4udmFsdWVPZigpO1xuICBpZiAoIWlzTmFOKG8pKSB7XG4gICAgcmV0dXJuIG8gLSB0ICoga287XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNvVG9MZWdhY3lEYXRlKGUsIG4gPSAxLCB0ID0gMSwgbyA9IDAsIHIgPSAwLCBpID0gMCwgYSA9IDApIHtcbiAgY29uc3QgcyA9IGUgPT09IHdyID8gMSA6IGUgPT09IEZyID8gLTEgOiAwLCBjID0gbmV3IERhdGU7XG4gIHJldHVybiBjLnNldFVUQ0hvdXJzKG8sIHIsIGksIGEpLCBjLnNldFVUQ0Z1bGxZZWFyKGUsIG4gLSAxLCB0ICsgcyksIFsgYywgcyBdO1xufVxuXG5mdW5jdGlvbiBlcG9jaE5hbm9Ub0lzbyhlLCBuKSB7XG4gIGxldCBbdCwgb10gPSBtb3ZlQmlnTmFubyhlLCBuKTtcbiAgbyA8IDAgJiYgKG8gKz0gVW8sIHQgLT0gMSk7XG4gIGNvbnN0IFtyLCBpXSA9IGRpdk1vZEZsb29yKG8sIFFlKSwgW2EsIHNdID0gZGl2TW9kRmxvb3IoaSwgWW8pO1xuICByZXR1cm4gZXBvY2hNaWxsaVRvSXNvKHQgKiBrbyArIHIsIGEsIHMpO1xufVxuXG5mdW5jdGlvbiBlcG9jaE1pbGxpVG9Jc28oZSwgbiA9IDAsIHQgPSAwKSB7XG4gIGNvbnN0IG8gPSBNYXRoLmNlaWwoTWF0aC5tYXgoMCwgTWF0aC5hYnMoZSkgLSBQcikgLyBrbykgKiBNYXRoLnNpZ24oZSksIHIgPSBuZXcgRGF0ZShlIC0gbyAqIGtvKTtcbiAgcmV0dXJuIHppcFByb3BzKFRyLCBbIHIuZ2V0VVRDRnVsbFllYXIoKSwgci5nZXRVVENNb250aCgpICsgMSwgci5nZXRVVENEYXRlKCkgKyBvLCByLmdldFVUQ0hvdXJzKCksIHIuZ2V0VVRDTWludXRlcygpLCByLmdldFVUQ1NlY29uZHMoKSwgci5nZXRVVENNaWxsaXNlY29uZHMoKSwgbiwgdCBdKTtcbn1cblxuZnVuY3Rpb24gaGFzaEludGxGb3JtYXRQYXJ0cyhlLCBuKSB7XG4gIGlmIChuIDwgLVByKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIGNvbnN0IHQgPSBlLmZvcm1hdFRvUGFydHMobiksIG8gPSB7fTtcbiAgZm9yIChjb25zdCBlIG9mIHQpIHtcbiAgICBvW2UudHlwZV0gPSBlLnZhbHVlO1xuICB9XG4gIHJldHVybiBvO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvRGF0ZVBhcnRzKGUpIHtcbiAgcmV0dXJuIFsgZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvTW9udGhDb2RlUGFydHMoZSwgbikge1xuICByZXR1cm4gWyBuLCAwIF07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc29Nb250aHNJblllYXIoKSB7XG4gIHJldHVybiBrcjtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0RheXNJbk1vbnRoKGUsIG4pIHtcbiAgc3dpdGNoIChuKSB7XG4gICBjYXNlIDI6XG4gICAgcmV0dXJuIGNvbXB1dGVJc29JbkxlYXBZZWFyKGUpID8gMjkgOiAyODtcblxuICAgY2FzZSA0OlxuICAgY2FzZSA2OlxuICAgY2FzZSA5OlxuICAgY2FzZSAxMTpcbiAgICByZXR1cm4gMzA7XG4gIH1cbiAgcmV0dXJuIDMxO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSXNvRGF5c0luWWVhcihlKSB7XG4gIHJldHVybiBjb21wdXRlSXNvSW5MZWFwWWVhcihlKSA/IDM2NiA6IDM2NTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0luTGVhcFllYXIoZSkge1xuICByZXR1cm4gZSAlIDQgPT0gMCAmJiAoZSAlIDEwMCAhPSAwIHx8IGUgJSA0MDAgPT0gMCk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJc29EYXlPZldlZWsoZSkge1xuICBjb25zdCBbbiwgdF0gPSBpc29Ub0xlZ2FjeURhdGUoZS5pc29ZZWFyLCBlLmlzb01vbnRoLCBlLmlzb0RheSk7XG4gIHJldHVybiBtb2RGbG9vcihuLmdldFVUQ0RheSgpIC0gdCwgNykgfHwgNztcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUlzb0VyYVBhcnRzKGUpIHtcbiAgcmV0dXJuIHRoaXMuaWQgPT09IG9yID8gKCh7aXNvWWVhcjogZX0pID0+IGUgPCAxID8gWyBcImdyZWdvcnktaW52ZXJzZVwiLCAxIC0gZSBdIDogWyBcImdyZWdvcnlcIiwgZSBdKShlKSA6IHRoaXMuaWQgPT09IHJyID8gWXIoZSkgOiBbXTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUphcGFuZXNlRXJhUGFydHMoZSkge1xuICBjb25zdCBuID0gaXNvVG9FcG9jaE1pbGxpKGUpO1xuICBpZiAobiA8IENyKSB7XG4gICAgY29uc3Qge2lzb1llYXI6IG59ID0gZTtcbiAgICByZXR1cm4gbiA8IDEgPyBbIFwiamFwYW5lc2UtaW52ZXJzZVwiLCAxIC0gbiBdIDogWyBcImphcGFuZXNlXCIsIG4gXTtcbiAgfVxuICBjb25zdCB0ID0gaGFzaEludGxGb3JtYXRQYXJ0cyhDaShyciksIG4pLCB7ZXJhOiBvLCBlcmFZZWFyOiByfSA9IHBhcnNlSW50bFllYXIodCwgcnIpO1xuICByZXR1cm4gWyBvLCByIF07XG59XG5cbmZ1bmN0aW9uIGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMoZSkge1xuICByZXR1cm4gY2hlY2tJc29EYXRlRmllbGRzKGUpLCBjb25zdHJhaW5Jc29UaW1lRmllbGRzKGUsIDEpLCBlO1xufVxuXG5mdW5jdGlvbiBjaGVja0lzb0RhdGVGaWVsZHMoZSkge1xuICByZXR1cm4gY29uc3RyYWluSXNvRGF0ZUZpZWxkcyhlLCAxKSwgZTtcbn1cblxuZnVuY3Rpb24gaXNJc29EYXRlRmllbGRzVmFsaWQoZSkge1xuICByZXR1cm4gYWxsUHJvcHNFcXVhbChEciwgZSwgY29uc3RyYWluSXNvRGF0ZUZpZWxkcyhlKSk7XG59XG5cbmZ1bmN0aW9uIGNvbnN0cmFpbklzb0RhdGVGaWVsZHMoZSwgbikge1xuICBjb25zdCB7aXNvWWVhcjogdH0gPSBlLCBvID0gY2xhbXBQcm9wKGUsIFwiaXNvTW9udGhcIiwgMSwgY29tcHV0ZUlzb01vbnRoc0luWWVhcigpLCBuKTtcbiAgcmV0dXJuIHtcbiAgICBpc29ZZWFyOiB0LFxuICAgIGlzb01vbnRoOiBvLFxuICAgIGlzb0RheTogY2xhbXBQcm9wKGUsIFwiaXNvRGF5XCIsIDEsIGNvbXB1dGVJc29EYXlzSW5Nb250aCh0LCBvKSwgbilcbiAgfTtcbn1cblxuZnVuY3Rpb24gY29uc3RyYWluSXNvVGltZUZpZWxkcyhlLCBuKSB7XG4gIHJldHVybiB6aXBQcm9wcyh3LCBbIGNsYW1wUHJvcChlLCBcImlzb0hvdXJcIiwgMCwgMjMsIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaW51dGVcIiwgMCwgNTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29TZWNvbmRcIiwgMCwgNTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaWxsaXNlY29uZFwiLCAwLCA5OTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29NaWNyb3NlY29uZFwiLCAwLCA5OTksIG4pLCBjbGFtcFByb3AoZSwgXCJpc29OYW5vc2Vjb25kXCIsIDAsIDk5OSwgbikgXSk7XG59XG5cbmZ1bmN0aW9uIG10KGUpIHtcbiAgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IDAgOiBYcihyZXF1aXJlT2JqZWN0TGlrZShlKSk7XG59XG5cbmZ1bmN0aW9uIGplKGUsIG4gPSAwKSB7XG4gIGUgPSBub3JtYWxpemVPcHRpb25zKGUpO1xuICBjb25zdCB0ID0gZWkoZSksIG8gPSBuaShlLCBuKTtcbiAgcmV0dXJuIFsgWHIoZSksIG8sIHQgXTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lRGlmZk9wdGlvbnMoZSwgbiwgdCwgbyA9IDksIHIgPSAwLCBpID0gNCkge1xuICBuID0gbm9ybWFsaXplT3B0aW9ucyhuKTtcbiAgbGV0IGEgPSBLcihuLCBvLCByKSwgcyA9IHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKG4pLCBjID0gaWkobiwgaSk7XG4gIGNvbnN0IHUgPSBKcihuLCBvLCByLCAxKTtcbiAgcmV0dXJuIG51bGwgPT0gYSA/IGEgPSBNYXRoLm1heCh0LCB1KSA6IGNoZWNrTGFyZ2VzdFNtYWxsZXN0VW5pdChhLCB1KSwgcyA9IHJlZmluZVJvdW5kaW5nSW5jKHMsIHUsIDEpLCBcbiAgZSAmJiAoYyA9IChlID0+IGUgPCA0ID8gKGUgKyAyKSAlIDQgOiBlKShjKSksIFsgYSwgdSwgcywgYyBdO1xufVxuXG5mdW5jdGlvbiByZWZpbmVSb3VuZGluZ09wdGlvbnMoZSwgbiA9IDYsIHQpIHtcbiAgbGV0IG8gPSBwYXJzZVJvdW5kaW5nSW5jSW50ZWdlcihlID0gbm9ybWFsaXplT3B0aW9uc09yU3RyaW5nKGUsIFJyKSk7XG4gIGNvbnN0IHIgPSBpaShlLCA3KTtcbiAgbGV0IGkgPSBKcihlLCBuKTtcbiAgcmV0dXJuIGkgPSByZXF1aXJlUHJvcERlZmluZWQoUnIsIGkpLCBvID0gcmVmaW5lUm91bmRpbmdJbmMobywgaSwgdm9pZCAwLCB0KSwgWyBpLCBvLCByIF07XG59XG5cbmZ1bmN0aW9uIHJlZmluZURhdGVEaXNwbGF5T3B0aW9ucyhlKSB7XG4gIHJldHVybiB0aShub3JtYWxpemVPcHRpb25zKGUpKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lVGltZURpc3BsYXlPcHRpb25zKGUsIG4pIHtcbiAgcmV0dXJuIHJlZmluZVRpbWVEaXNwbGF5VHVwbGUobm9ybWFsaXplT3B0aW9ucyhlKSwgbik7XG59XG5cbmZ1bmN0aW9uIE1lKGUpIHtcbiAgY29uc3QgbiA9IG5vcm1hbGl6ZU9wdGlvbnNPclN0cmluZyhlLCBxciksIHQgPSByZWZpbmVDaG9pY2VPcHRpb24ocXIsIF9yLCBuLCAwKTtcbiAgaWYgKCF0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVudGl0eShxciwgdCkpO1xuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiByZWZpbmVUaW1lRGlzcGxheVR1cGxlKGUsIG4gPSA0KSB7XG4gIGNvbnN0IHQgPSByZWZpbmVTdWJzZWNEaWdpdHMoZSk7XG4gIHJldHVybiBbIGlpKGUsIDQpLCAuLi5yZWZpbmVTbWFsbGVzdFVuaXRBbmRTdWJzZWNEaWdpdHMoSnIoZSwgbiksIHQpIF07XG59XG5cbmZ1bmN0aW9uIHJlZmluZVNtYWxsZXN0VW5pdEFuZFN1YnNlY0RpZ2l0cyhlLCBuKSB7XG4gIHJldHVybiBudWxsICE9IGUgPyBbIEFvW2VdLCBlIDwgNCA/IDkgLSAzICogZSA6IC0xIF0gOiBbIHZvaWQgMCA9PT0gbiA/IDEgOiAxMCAqKiAoOSAtIG4pLCBuIF07XG59XG5cbmZ1bmN0aW9uIHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKGUpIHtcbiAgY29uc3QgbiA9IGVbenJdO1xuICByZXR1cm4gdm9pZCAwID09PSBuID8gMSA6IHRvSW50ZWdlcihuLCB6cik7XG59XG5cbmZ1bmN0aW9uIHJlZmluZVJvdW5kaW5nSW5jKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IG8gPyBVbyA6IEFvW24gKyAxXTtcbiAgaWYgKHIpIHtcbiAgICBjb25zdCB0ID0gQW9bbl07XG4gICAgaWYgKHIgJSAoKGUgPSBjbGFtcEVudGl0eSh6ciwgZSwgMSwgciAvIHQgLSAobyA/IDAgOiAxKSwgMSkpICogdCkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRFbnRpdHkoenIsIGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZSA9IGNsYW1wRW50aXR5KHpyLCBlLCAxLCB0ID8gMTAgKiogOSA6IDEsIDEpO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiByZWZpbmVTdWJzZWNEaWdpdHMoZSkge1xuICBsZXQgbiA9IGVbVXJdO1xuICBpZiAodm9pZCAwICE9PSBuKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIG4pIHtcbiAgICAgIGlmIChcImF1dG9cIiA9PT0gdG9TdHJpbmcobikpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVudGl0eShVciwgbikpO1xuICAgIH1cbiAgICBuID0gY2xhbXBFbnRpdHkoVXIsIE1hdGguZmxvb3IobiksIDAsIDksIDEpO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBub3JtYWxpemVPcHRpb25zKGUpIHtcbiAgcmV0dXJuIHZvaWQgMCA9PT0gZSA/IHt9IDogcmVxdWlyZU9iamVjdExpa2UoZSk7XG59XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZU9wdGlvbnNPclN0cmluZyhlLCBuKSB7XG4gIHJldHVybiBcInN0cmluZ1wiID09IHR5cGVvZiBlID8ge1xuICAgIFtuXTogZVxuICB9IDogcmVxdWlyZU9iamVjdExpa2UoZSk7XG59XG5cbmZ1bmN0aW9uIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyhlKSB7XG4gIHJldHVybiB7XG4gICAgb3ZlcmZsb3c6IGpyW2VdXG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlZmluZVVuaXRPcHRpb24oZSwgbiwgdCA9IDksIG8gPSAwLCByKSB7XG4gIGxldCBpID0gbltlXTtcbiAgaWYgKHZvaWQgMCA9PT0gaSkge1xuICAgIHJldHVybiByID8gbyA6IHZvaWQgMDtcbiAgfVxuICBpZiAoaSA9IHRvU3RyaW5nKGkpLCBcImF1dG9cIiA9PT0gaSkge1xuICAgIHJldHVybiByID8gbyA6IG51bGw7XG4gIH1cbiAgbGV0IGEgPSBPb1tpXTtcbiAgaWYgKHZvaWQgMCA9PT0gYSAmJiAoYSA9IG1yW2ldKSwgdm9pZCAwID09PSBhKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZENob2ljZShlLCBpLCBPbykpO1xuICB9XG4gIHJldHVybiBjbGFtcEVudGl0eShlLCBhLCBvLCB0LCAxLCBCbyksIGE7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNob2ljZU9wdGlvbihlLCBuLCB0LCBvID0gMCkge1xuICBjb25zdCByID0gdFtlXTtcbiAgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgIHJldHVybiBvO1xuICB9XG4gIGNvbnN0IGkgPSB0b1N0cmluZyhyKSwgYSA9IG5baV07XG4gIGlmICh2b2lkIDAgPT09IGEpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkQ2hvaWNlKGUsIGksIG4pKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY2hlY2tMYXJnZXN0U21hbGxlc3RVbml0KGUsIG4pIHtcbiAgaWYgKG4gPiBlKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRW8pO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhlKGUpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuZGluZzogUmUsXG4gICAgZXBvY2hOYW5vc2Vjb25kczogZVxuICB9O1xufVxuXG5mdW5jdGlvbiBfZShlLCBuLCB0KSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmRpbmc6IHosXG4gICAgY2FsZW5kYXI6IHQsXG4gICAgdGltZVpvbmU6IG4sXG4gICAgZXBvY2hOYW5vc2Vjb25kczogZVxuICB9O1xufVxuXG5mdW5jdGlvbiBqdChlLCBuID0gZS5jYWxlbmRhcikge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiB4LFxuICAgIGNhbGVuZGFyOiBuLFxuICAgIC4uLm5uKE5yLCBlKVxuICB9O1xufVxuXG5mdW5jdGlvbiBXKGUsIG4gPSBlLmNhbGVuZGFyKSB7XG4gIHJldHVybiB7XG4gICAgYnJhbmRpbmc6IEcsXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgLi4ubm4oSXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWluWWVhck1vbnRoU2xvdHMoZSwgbiA9IGUuY2FsZW5kYXIpIHtcbiAgcmV0dXJuIHtcbiAgICBicmFuZGluZzogVXQsXG4gICAgY2FsZW5kYXI6IG4sXG4gICAgLi4ubm4oSXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVBsYWluTW9udGhEYXlTbG90cyhlLCBuID0gZS5jYWxlbmRhcikge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBxdCxcbiAgICBjYWxlbmRhcjogbixcbiAgICAuLi5ubihJciwgZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gU3QoZSkge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBmdCxcbiAgICAuLi5ubihNciwgZSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gT2UoZSkge1xuICByZXR1cm4ge1xuICAgIGJyYW5kaW5nOiBOLFxuICAgIHNpZ246IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksXG4gICAgLi4ubm4odXIsIGUpXG4gIH07XG59XG5cbmZ1bmN0aW9uIEkoZSkge1xuICByZXR1cm4gZGl2TW9kQmlnTmFubyhlLmVwb2NoTmFub3NlY29uZHMsIFFlKVswXTtcbn1cblxuZnVuY3Rpb24gdihlKSB7XG4gIHJldHVybiAoKGUsIG4gPSAxKSA9PiB7XG4gICAgY29uc3QgW3QsIG9dID0gZSwgciA9IE1hdGguZmxvb3IobyAvIG4pLCBpID0gVW8gLyBuO1xuICAgIHJldHVybiBCaWdJbnQodCkgKiBCaWdJbnQoaSkgKyBCaWdJbnQocik7XG4gIH0pKGUuZXBvY2hOYW5vc2Vjb25kcyk7XG59XG5cbmZ1bmN0aW9uIGV4dHJhY3RFcG9jaE5hbm8oZSkge1xuICByZXR1cm4gZS5lcG9jaE5hbm9zZWNvbmRzO1xufVxuXG5mdW5jdGlvbiBKKGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IGdldE1heER1cmF0aW9uVW5pdChvKSwgW2EsIHNdID0gKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IG4oKGUgPSBub3JtYWxpemVPcHRpb25zT3JTdHJpbmcoZSwgWnIpKVtBcl0pO1xuICAgIGxldCBvID0gUXIoZSk7XG4gICAgcmV0dXJuIG8gPSByZXF1aXJlUHJvcERlZmluZWQoWnIsIG8pLCBbIG8sIHQgXTtcbiAgfSkociwgZSksIGMgPSBNYXRoLm1heChhLCBpKTtcbiAgaWYgKCFzICYmIGlzVW5pZm9ybVVuaXQoYywgcykpIHtcbiAgICByZXR1cm4gdG90YWxEYXlUaW1lRHVyYXRpb24obywgYSk7XG4gIH1cbiAgaWYgKCFzKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoeW8pO1xuICB9XG4gIGlmICghby5zaWduKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgY29uc3QgW3UsIGYsIGxdID0gY3JlYXRlTWFya2VyU3lzdGVtKG4sIHQsIHMpLCBkID0gY3JlYXRlTWFya2VyVG9FcG9jaE5hbm8obCksIG0gPSBjcmVhdGVNb3ZlTWFya2VyKGwpLCBoID0gY3JlYXRlRGlmZk1hcmtlcnMobCksIGcgPSBtKGYsIHUsIG8pO1xuICBpc1pvbmVkRXBvY2hTbG90cyhzKSB8fCAoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHUpLCBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoZykpO1xuICBjb25zdCBEID0gaChmLCB1LCBnLCBhKTtcbiAgcmV0dXJuIGlzVW5pZm9ybVVuaXQoYSwgcykgPyB0b3RhbERheVRpbWVEdXJhdGlvbihELCBhKSA6ICgoZSwgbiwgdCwgbywgciwgaSwgYSkgPT4ge1xuICAgIGNvbnN0IHMgPSBjb21wdXRlRHVyYXRpb25TaWduKGUpLCBbYywgdV0gPSBjbGFtcFJlbGF0aXZlRHVyYXRpb24obywgZ3IodCwgZSksIHQsIHMsIHIsIGksIGEpLCBmID0gY29tcHV0ZUVwb2NoTmFub0ZyYWMobiwgYywgdSk7XG4gICAgcmV0dXJuIGVbcFt0XV0gKyBmICogcztcbiAgfSkoRCwgZChnKSwgYSwgZiwgdSwgZCwgbSk7XG59XG5cbmZ1bmN0aW9uIHRvdGFsRGF5VGltZUR1cmF0aW9uKGUsIG4pIHtcbiAgcmV0dXJuIGJpZ05hbm9Ub051bWJlcihkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgQW9bbl0sIDEpO1xufVxuXG5mdW5jdGlvbiBjbGFtcFJlbGF0aXZlRHVyYXRpb24oZSwgbiwgdCwgbywgciwgaSwgYSkge1xuICBjb25zdCBzID0gcFt0XSwgYyA9IHtcbiAgICAuLi5uLFxuICAgIFtzXTogbltzXSArIG9cbiAgfSwgdSA9IGEoZSwgciwgbiksIGYgPSBhKGUsIHIsIGMpO1xuICByZXR1cm4gWyBpKHUpLCBpKGYpIF07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVFcG9jaE5hbm9GcmFjKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IGJpZ05hbm9Ub051bWJlcihkaWZmQmlnTmFub3MobiwgdCkpO1xuICBpZiAoIW8pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gIH1cbiAgcmV0dXJuIGJpZ05hbm9Ub051bWJlcihkaWZmQmlnTmFub3MobiwgZSkpIC8gbztcbn1cblxuZnVuY3Rpb24gTGUoZSwgbikge1xuICBjb25zdCBbdCwgbywgcl0gPSByZWZpbmVSb3VuZGluZ09wdGlvbnMobiwgNSwgMSk7XG4gIHJldHVybiB4ZShyb3VuZEJpZ05hbm8oZS5lcG9jaE5hbm9zZWNvbmRzLCB0LCBvLCByLCAxKSk7XG59XG5cbmZ1bmN0aW9uIEllKGUsIG4sIHQpIHtcbiAgbGV0IHtlcG9jaE5hbm9zZWNvbmRzOiBvLCB0aW1lWm9uZTogciwgY2FsZW5kYXI6IGl9ID0gbjtcbiAgY29uc3QgW2EsIHMsIGNdID0gcmVmaW5lUm91bmRpbmdPcHRpb25zKHQpO1xuICBpZiAoMCA9PT0gYSAmJiAxID09PSBzKSB7XG4gICAgcmV0dXJuIG47XG4gIH1cbiAgY29uc3QgdSA9IGUocik7XG4gIGlmICg2ID09PSBhKSB7XG4gICAgbyA9ICgoZSwgbiwgdCwgbykgPT4ge1xuICAgICAgY29uc3QgciA9IGhlKHQsIG4pLCBbaSwgYV0gPSBlKHIpLCBzID0gdC5lcG9jaE5hbm9zZWNvbmRzLCBjID0gZ2V0U3RhcnRPZkRheUluc3RhbnRGb3IobiwgaSksIHUgPSBnZXRTdGFydE9mRGF5SW5zdGFudEZvcihuLCBhKTtcbiAgICAgIGlmIChiaWdOYW5vT3V0c2lkZShzLCBjLCB1KSkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcm91bmRXaXRoTW9kZShjb21wdXRlRXBvY2hOYW5vRnJhYyhzLCBjLCB1KSwgbykgPyB1IDogYztcbiAgICB9KShjb21wdXRlRGF5SW50ZXJ2YWwsIHUsIG4sIGMpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGUgPSB1LlIobyk7XG4gICAgbyA9IGdldE1hdGNoaW5nSW5zdGFudEZvcih1LCByb3VuZERhdGVUaW1lKGVwb2NoTmFub1RvSXNvKG8sIGUpLCBhLCBzLCBjKSwgZSwgMiwgMCwgMSk7XG4gIH1cbiAgcmV0dXJuIF9lKG8sIHIsIGkpO1xufVxuXG5mdW5jdGlvbiB2dChlLCBuKSB7XG4gIHJldHVybiBqdChyb3VuZERhdGVUaW1lKGUsIC4uLnJlZmluZVJvdW5kaW5nT3B0aW9ucyhuKSksIGUuY2FsZW5kYXIpO1xufVxuXG5mdW5jdGlvbiBsdChlLCBuKSB7XG4gIGNvbnN0IFt0LCBvLCByXSA9IHJlZmluZVJvdW5kaW5nT3B0aW9ucyhuLCA1KTtcbiAgdmFyIGk7XG4gIHJldHVybiBTdCgoaSA9IHIsIHJvdW5kVGltZVRvTmFubyhlLCBjb21wdXRlTmFub0luYyh0LCBvKSwgaSlbMF0pKTtcbn1cblxuZnVuY3Rpb24gVGUoZSwgbikge1xuICBjb25zdCB0ID0gZShuLnRpbWVab25lKSwgbyA9IGhlKG4sIHQpLCBbciwgaV0gPSBjb21wdXRlRGF5SW50ZXJ2YWwobyksIGEgPSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKHQsIHIpLCBnZXRTdGFydE9mRGF5SW5zdGFudEZvcih0LCBpKSksIHpvLCAxKTtcbiAgaWYgKGEgPD0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZvKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gdmUoZSwgbikge1xuICBjb25zdCB7dGltZVpvbmU6IHQsIGNhbGVuZGFyOiBvfSA9IG4sIHIgPSAoKGUsIG4sIHQpID0+IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKG4sIGUoaGUodCwgbikpKSkoY29tcHV0ZURheUZsb29yLCBlKHQpLCBuKTtcbiAgcmV0dXJuIF9lKHIsIHQsIG8pO1xufVxuXG5mdW5jdGlvbiByb3VuZERhdGVUaW1lKGUsIG4sIHQsIG8pIHtcbiAgcmV0dXJuIHJvdW5kRGF0ZVRpbWVUb05hbm8oZSwgY29tcHV0ZU5hbm9JbmMobiwgdCksIG8pO1xufVxuXG5mdW5jdGlvbiByb3VuZERhdGVUaW1lVG9OYW5vKGUsIG4sIHQpIHtcbiAgY29uc3QgW28sIHJdID0gcm91bmRUaW1lVG9OYW5vKGUsIG4sIHQpO1xuICByZXR1cm4gY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHtcbiAgICAuLi5tb3ZlQnlEYXlzKGUsIHIpLFxuICAgIC4uLm9cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHJvdW5kVGltZVRvTmFubyhlLCBuLCB0KSB7XG4gIHJldHVybiBuYW5vVG9Jc29UaW1lQW5kRGF5KHJvdW5kQnlJbmMoaXNvVGltZUZpZWxkc1RvTmFubyhlKSwgbiwgdCkpO1xufVxuXG5mdW5jdGlvbiByb3VuZFRvTWludXRlKGUpIHtcbiAgcmV0dXJuIHJvdW5kQnlJbmMoZSwgWm8sIDcpO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTmFub0luYyhlLCBuKSB7XG4gIHJldHVybiBBb1tlXSAqIG47XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEYXlJbnRlcnZhbChlKSB7XG4gIGNvbnN0IG4gPSBjb21wdXRlRGF5Rmxvb3IoZSk7XG4gIHJldHVybiBbIG4sIG1vdmVCeURheXMobiwgMSkgXTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZURheUZsb29yKGUpIHtcbiAgcmV0dXJuIHlyKDYsIGUpO1xufVxuXG5mdW5jdGlvbiByb3VuZERheVRpbWVEdXJhdGlvbkJ5SW5jKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IE1hdGgubWluKGdldE1heER1cmF0aW9uVW5pdChlKSwgNik7XG4gIHJldHVybiBuYW5vVG9EdXJhdGlvbkRheVRpbWVGaWVsZHMocm91bmRCaWdOYW5vQnlJbmMoZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSwgbyksIG4sIHQpLCBvKTtcbn1cblxuZnVuY3Rpb24gcm91bmRSZWxhdGl2ZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUpIHtcbiAgaWYgKDAgPT09IG8gJiYgMSA9PT0gcikge1xuICAgIHJldHVybiBlO1xuICB9XG4gIGNvbnN0IGYgPSBpc1VuaWZvcm1Vbml0KG8sIHMpID8gaXNab25lZEVwb2NoU2xvdHMocykgJiYgbyA8IDYgJiYgdCA+PSA2ID8gbnVkZ2Vab25lZFRpbWVEdXJhdGlvbiA6IG51ZGdlRGF5VGltZUR1cmF0aW9uIDogbnVkZ2VSZWxhdGl2ZUR1cmF0aW9uO1xuICBsZXQgW2wsIGQsIG1dID0gZihlLCBuLCB0LCBvLCByLCBpLCBhLCBzLCBjLCB1KTtcbiAgcmV0dXJuIG0gJiYgNyAhPT0gbyAmJiAobCA9ICgoZSwgbiwgdCwgbywgciwgaSwgYSwgcykgPT4ge1xuICAgIGNvbnN0IGMgPSBjb21wdXRlRHVyYXRpb25TaWduKGUpO1xuICAgIGZvciAobGV0IHUgPSBvICsgMTsgdSA8PSB0OyB1KyspIHtcbiAgICAgIGlmICg3ID09PSB1ICYmIDcgIT09IHQpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBvID0gZ3IodSwgZSk7XG4gICAgICBvW3BbdV1dICs9IGM7XG4gICAgICBjb25zdCBmID0gYmlnTmFub1RvTnVtYmVyKGRpZmZCaWdOYW5vcyhhKHMociwgaSwgbykpLCBuKSk7XG4gICAgICBpZiAoZiAmJiBNYXRoLnNpZ24oZikgIT09IGMpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBlID0gbztcbiAgICB9XG4gICAgcmV0dXJuIGU7XG4gIH0pKGwsIGQsIHQsIE1hdGgubWF4KDYsIG8pLCBhLCBzLCBjLCB1KSksIGw7XG59XG5cbmZ1bmN0aW9uIHJvdW5kQmlnTmFubyhlLCBuLCB0LCBvLCByKSB7XG4gIGlmICg2ID09PSBuKSB7XG4gICAgY29uc3QgbiA9IChlID0+IGVbMF0gKyBlWzFdIC8gVW8pKGUpO1xuICAgIHJldHVybiBbIHJvdW5kQnlJbmMobiwgdCwgbyksIDAgXTtcbiAgfVxuICByZXR1cm4gcm91bmRCaWdOYW5vQnlJbmMoZSwgY29tcHV0ZU5hbm9JbmMobiwgdCksIG8sIHIpO1xufVxuXG5mdW5jdGlvbiByb3VuZEJpZ05hbm9CeUluYyhlLCBuLCB0LCBvKSB7XG4gIGxldCBbciwgaV0gPSBlO1xuICBvICYmIGkgPCAwICYmIChpICs9IFVvLCByIC09IDEpO1xuICBjb25zdCBbYSwgc10gPSBkaXZNb2RGbG9vcihyb3VuZEJ5SW5jKGksIG4sIHQpLCBVbyk7XG4gIHJldHVybiBjcmVhdGVCaWdOYW5vKHIgKyBhLCBzKTtcbn1cblxuZnVuY3Rpb24gcm91bmRCeUluYyhlLCBuLCB0KSB7XG4gIHJldHVybiByb3VuZFdpdGhNb2RlKGUgLyBuLCB0KSAqIG47XG59XG5cbmZ1bmN0aW9uIHJvdW5kV2l0aE1vZGUoZSwgbikge1xuICByZXR1cm4gYWlbbl0oZSk7XG59XG5cbmZ1bmN0aW9uIG51ZGdlRGF5VGltZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGkpIHtcbiAgY29uc3QgYSA9IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksIHMgPSBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgYyA9IHJvdW5kQmlnTmFubyhzLCBvLCByLCBpKSwgdSA9IGRpZmZCaWdOYW5vcyhzLCBjKSwgZiA9IE1hdGguc2lnbihjWzBdIC0gc1swXSkgPT09IGEsIGwgPSBuYW5vVG9EdXJhdGlvbkRheVRpbWVGaWVsZHMoYywgTWF0aC5taW4odCwgNikpO1xuICByZXR1cm4gWyB7XG4gICAgLi4uZSxcbiAgICAuLi5sXG4gIH0sIGFkZEJpZ05hbm9zKG4sIHUpLCBmIF07XG59XG5cbmZ1bmN0aW9uIG51ZGdlWm9uZWRUaW1lRHVyYXRpb24oZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYywgdSkge1xuICBjb25zdCBmID0gY29tcHV0ZUR1cmF0aW9uU2lnbihlKSB8fCAxLCBsID0gYmlnTmFub1RvTnVtYmVyKGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKGUsIDUpKSwgZCA9IGNvbXB1dGVOYW5vSW5jKG8sIHIpO1xuICBsZXQgbSA9IHJvdW5kQnlJbmMobCwgZCwgaSk7XG4gIGNvbnN0IFtwLCBoXSA9IGNsYW1wUmVsYXRpdmVEdXJhdGlvbihhLCB7XG4gICAgLi4uZSxcbiAgICAuLi5oclxuICB9LCA2LCBmLCBzLCBjLCB1KSwgZyA9IG0gLSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKHAsIGgpKTtcbiAgbGV0IEQgPSAwO1xuICBnICYmIE1hdGguc2lnbihnKSAhPT0gZiA/IG4gPSBtb3ZlQmlnTmFubyhwLCBtKSA6IChEICs9IGYsIG0gPSByb3VuZEJ5SW5jKGcsIGQsIGkpLCBcbiAgbiA9IG1vdmVCaWdOYW5vKGgsIG0pKTtcbiAgY29uc3QgVCA9IG5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyhtKTtcbiAgcmV0dXJuIFsge1xuICAgIC4uLmUsXG4gICAgLi4uVCxcbiAgICBkYXlzOiBlLmRheXMgKyBEXG4gIH0sIG4sIEJvb2xlYW4oRCkgXTtcbn1cblxuZnVuY3Rpb24gbnVkZ2VSZWxhdGl2ZUR1cmF0aW9uKGUsIG4sIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUpIHtcbiAgY29uc3QgZiA9IGNvbXB1dGVEdXJhdGlvblNpZ24oZSksIGwgPSBwW29dLCBkID0gZ3IobywgZSk7XG4gIDcgPT09IG8gJiYgKGUgPSB7XG4gICAgLi4uZSxcbiAgICB3ZWVrczogZS53ZWVrcyArIE1hdGgudHJ1bmMoZS5kYXlzIC8gNylcbiAgfSk7XG4gIGNvbnN0IG0gPSBkaXZUcnVuYyhlW2xdLCByKSAqIHI7XG4gIGRbbF0gPSBtO1xuICBjb25zdCBbaCwgZ10gPSBjbGFtcFJlbGF0aXZlRHVyYXRpb24oYSwgZCwgbywgciAqIGYsIHMsIGMsIHUpLCBEID0gbSArIGNvbXB1dGVFcG9jaE5hbm9GcmFjKG4sIGgsIGcpICogZiAqIHIsIFQgPSByb3VuZEJ5SW5jKEQsIHIsIGkpLCBJID0gTWF0aC5zaWduKFQgLSBEKSA9PT0gZjtcbiAgcmV0dXJuIGRbbF0gPSBULCBbIGQsIEkgPyBnIDogaCwgSSBdO1xufVxuXG5mdW5jdGlvbiBrZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IFtyLCBpLCBhLCBzXSA9IChlID0+IHtcbiAgICBjb25zdCBuID0gcmVmaW5lVGltZURpc3BsYXlUdXBsZShlID0gbm9ybWFsaXplT3B0aW9ucyhlKSk7XG4gICAgcmV0dXJuIFsgZS50aW1lWm9uZSwgLi4ubiBdO1xuICB9KShvKSwgYyA9IHZvaWQgMCAhPT0gcjtcbiAgcmV0dXJuICgoZSwgbiwgdCwgbywgciwgaSkgPT4ge1xuICAgIHQgPSByb3VuZEJpZ05hbm9CeUluYyh0LCByLCBvLCAxKTtcbiAgICBjb25zdCBhID0gbi5SKHQpO1xuICAgIHJldHVybiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlcG9jaE5hbm9Ub0lzbyh0LCBhKSwgaSkgKyAoZSA/IFNlKHJvdW5kVG9NaW51dGUoYSkpIDogXCJaXCIpO1xuICB9KShjLCBuKGMgPyBlKHIpIDogc2kpLCB0LmVwb2NoTmFub3NlY29uZHMsIGksIGEsIHMpO1xufVxuXG5mdW5jdGlvbiBGZShlLCBuLCB0KSB7XG4gIGNvbnN0IFtvLCByLCBpLCBhLCBzLCBjXSA9IChlID0+IHtcbiAgICBlID0gbm9ybWFsaXplT3B0aW9ucyhlKTtcbiAgICBjb25zdCBuID0gdGkoZSksIHQgPSByZWZpbmVTdWJzZWNEaWdpdHMoZSksIG8gPSByaShlKSwgciA9IGlpKGUsIDQpLCBpID0gSnIoZSwgNCk7XG4gICAgcmV0dXJuIFsgbiwgb2koZSksIG8sIHIsIC4uLnJlZmluZVNtYWxsZXN0VW5pdEFuZFN1YnNlY0RpZ2l0cyhpLCB0KSBdO1xuICB9KSh0KTtcbiAgcmV0dXJuICgoZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYywgdSkgPT4ge1xuICAgIG8gPSByb3VuZEJpZ05hbm9CeUluYyhvLCBjLCBzLCAxKTtcbiAgICBjb25zdCBmID0gZSh0KS5SKG8pO1xuICAgIHJldHVybiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlcG9jaE5hbm9Ub0lzbyhvLCBmKSwgdSkgKyBTZShyb3VuZFRvTWludXRlKGYpLCBhKSArICgoZSwgbikgPT4gMSAhPT0gbiA/IFwiW1wiICsgKDIgPT09IG4gPyBcIiFcIiA6IFwiXCIpICsgZSArIFwiXVwiIDogXCJcIikodCwgaSkgKyBmb3JtYXRDYWxlbmRhcihuLCByKTtcbiAgfSkoZSwgbi5jYWxlbmRhciwgbi50aW1lWm9uZSwgbi5lcG9jaE5hbm9zZWNvbmRzLCBvLCByLCBpLCBhLCBzLCBjKTtcbn1cblxuZnVuY3Rpb24gRnQoZSwgbikge1xuICBjb25zdCBbdCwgbywgciwgaV0gPSAoZSA9PiAoZSA9IG5vcm1hbGl6ZU9wdGlvbnMoZSksIFsgdGkoZSksIC4uLnJlZmluZVRpbWVEaXNwbGF5VHVwbGUoZSkgXSkpKG4pO1xuICByZXR1cm4gYSA9IGUuY2FsZW5kYXIsIHMgPSB0LCBjID0gaSwgZm9ybWF0SXNvRGF0ZVRpbWVGaWVsZHMocm91bmREYXRlVGltZVRvTmFubyhlLCByLCBvKSwgYykgKyBmb3JtYXRDYWxlbmRhcihhLCBzKTtcbiAgdmFyIGEsIHMsIGM7XG59XG5cbmZ1bmN0aW9uIGNlKGUsIG4pIHtcbiAgcmV0dXJuIHQgPSBlLmNhbGVuZGFyLCBvID0gZSwgciA9IHJlZmluZURhdGVEaXNwbGF5T3B0aW9ucyhuKSwgZm9ybWF0SXNvRGF0ZUZpZWxkcyhvKSArIGZvcm1hdENhbGVuZGFyKHQsIHIpO1xuICB2YXIgdCwgbywgcjtcbn1cblxuZnVuY3Rpb24gS3QoZSwgbikge1xuICByZXR1cm4gZm9ybWF0RGF0ZUxpa2VJc28oZS5jYWxlbmRhciwgZm9ybWF0SXNvWWVhck1vbnRoRmllbGRzLCBlLCByZWZpbmVEYXRlRGlzcGxheU9wdGlvbnMobikpO1xufVxuXG5mdW5jdGlvbiBKdChlLCBuKSB7XG4gIHJldHVybiBmb3JtYXREYXRlTGlrZUlzbyhlLmNhbGVuZGFyLCBmb3JtYXRJc29Nb250aERheUZpZWxkcywgZSwgcmVmaW5lRGF0ZURpc3BsYXlPcHRpb25zKG4pKTtcbn1cblxuZnVuY3Rpb24gY3QoZSwgbikge1xuICBjb25zdCBbdCwgbywgcl0gPSByZWZpbmVUaW1lRGlzcGxheU9wdGlvbnMobik7XG4gIHJldHVybiBpID0gciwgZm9ybWF0SXNvVGltZUZpZWxkcyhyb3VuZFRpbWVUb05hbm8oZSwgbywgdClbMF0sIGkpO1xuICB2YXIgaTtcbn1cblxuZnVuY3Rpb24gayhlLCBuKSB7XG4gIGNvbnN0IFt0LCBvLCByXSA9IHJlZmluZVRpbWVEaXNwbGF5T3B0aW9ucyhuLCAzKTtcbiAgcmV0dXJuIG8gPiAxICYmIGNoZWNrRHVyYXRpb25Vbml0cyhlID0ge1xuICAgIC4uLmUsXG4gICAgLi4ucm91bmREYXlUaW1lRHVyYXRpb25CeUluYyhlLCBvLCB0KVxuICB9KSwgKChlLCBuKSA9PiB7XG4gICAgY29uc3Qge3NpZ246IHR9ID0gZSwgbyA9IC0xID09PSB0ID8gbmVnYXRlRHVyYXRpb25GaWVsZHMoZSkgOiBlLCB7aG91cnM6IHIsIG1pbnV0ZXM6IGl9ID0gbywgW2EsIHNdID0gZGl2TW9kQmlnTmFubyhkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhvLCAzKSwgUm8sIGRpdk1vZFRydW5jKTtcbiAgICBjaGVja0R1cmF0aW9uVGltZVVuaXQoYSk7XG4gICAgY29uc3QgYyA9IGZvcm1hdFN1YnNlY05hbm8ocywgbiksIHUgPSBuID49IDAgfHwgIXQgfHwgYztcbiAgICByZXR1cm4gKHQgPCAwID8gXCItXCIgOiBcIlwiKSArIFwiUFwiICsgZm9ybWF0RHVyYXRpb25GcmFnbWVudHMoe1xuICAgICAgWTogZm9ybWF0RHVyYXRpb25OdW1iZXIoby55ZWFycyksXG4gICAgICBNOiBmb3JtYXREdXJhdGlvbk51bWJlcihvLm1vbnRocyksXG4gICAgICBXOiBmb3JtYXREdXJhdGlvbk51bWJlcihvLndlZWtzKSxcbiAgICAgIEQ6IGZvcm1hdER1cmF0aW9uTnVtYmVyKG8uZGF5cylcbiAgICB9KSArIChyIHx8IGkgfHwgYSB8fCB1ID8gXCJUXCIgKyBmb3JtYXREdXJhdGlvbkZyYWdtZW50cyh7XG4gICAgICBIOiBmb3JtYXREdXJhdGlvbk51bWJlcihyKSxcbiAgICAgIE06IGZvcm1hdER1cmF0aW9uTnVtYmVyKGkpLFxuICAgICAgUzogZm9ybWF0RHVyYXRpb25OdW1iZXIoYSwgdSkgKyBjXG4gICAgfSkgOiBcIlwiKTtcbiAgfSkoZSwgcik7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdERhdGVMaWtlSXNvKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IG8gPiAxIHx8IDAgPT09IG8gJiYgZSAhPT0gbDtcbiAgcmV0dXJuIDEgPT09IG8gPyBlID09PSBsID8gbih0KSA6IGZvcm1hdElzb0RhdGVGaWVsZHModCkgOiByID8gZm9ybWF0SXNvRGF0ZUZpZWxkcyh0KSArIGZvcm1hdENhbGVuZGFySWQoZSwgMiA9PT0gbykgOiBuKHQpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREdXJhdGlvbkZyYWdtZW50cyhlKSB7XG4gIGNvbnN0IG4gPSBbXTtcbiAgZm9yIChjb25zdCB0IGluIGUpIHtcbiAgICBjb25zdCBvID0gZVt0XTtcbiAgICBvICYmIG4ucHVzaChvLCB0KTtcbiAgfVxuICByZXR1cm4gbi5qb2luKFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29EYXRlVGltZUZpZWxkcyhlLCBuKSB7XG4gIHJldHVybiBmb3JtYXRJc29EYXRlRmllbGRzKGUpICsgXCJUXCIgKyBmb3JtYXRJc29UaW1lRmllbGRzKGUsIG4pO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29EYXRlRmllbGRzKGUpIHtcbiAgcmV0dXJuIGZvcm1hdElzb1llYXJNb250aEZpZWxkcyhlKSArIFwiLVwiICsgYm8oZS5pc29EYXkpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRJc29ZZWFyTW9udGhGaWVsZHMoZSkge1xuICBjb25zdCB7aXNvWWVhcjogbn0gPSBlO1xuICByZXR1cm4gKG4gPCAwIHx8IG4gPiA5OTk5ID8gZ2V0U2lnblN0cihuKSArIHBhZE51bWJlcig2LCBNYXRoLmFicyhuKSkgOiBwYWROdW1iZXIoNCwgbikpICsgXCItXCIgKyBibyhlLmlzb01vbnRoKTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SXNvTW9udGhEYXlGaWVsZHMoZSkge1xuICByZXR1cm4gYm8oZS5pc29Nb250aCkgKyBcIi1cIiArIGJvKGUuaXNvRGF5KTtcbn1cblxuZnVuY3Rpb24gZm9ybWF0SXNvVGltZUZpZWxkcyhlLCBuKSB7XG4gIGNvbnN0IHQgPSBbIGJvKGUuaXNvSG91ciksIGJvKGUuaXNvTWludXRlKSBdO1xuICByZXR1cm4gLTEgIT09IG4gJiYgdC5wdXNoKGJvKGUuaXNvU2Vjb25kKSArICgoZSwgbiwgdCwgbykgPT4gZm9ybWF0U3Vic2VjTmFubyhlICogUWUgKyBuICogWW8gKyB0LCBvKSkoZS5pc29NaWxsaXNlY29uZCwgZS5pc29NaWNyb3NlY29uZCwgZS5pc29OYW5vc2Vjb25kLCBuKSksIFxuICB0LmpvaW4oXCI6XCIpO1xufVxuXG5mdW5jdGlvbiBTZShlLCBuID0gMCkge1xuICBpZiAoMSA9PT0gbikge1xuICAgIHJldHVybiBcIlwiO1xuICB9XG4gIGNvbnN0IFt0LCBvXSA9IGRpdk1vZEZsb29yKE1hdGguYWJzKGUpLCB6byksIFtyLCBpXSA9IGRpdk1vZEZsb29yKG8sIFpvKSwgW2EsIHNdID0gZGl2TW9kRmxvb3IoaSwgUm8pO1xuICByZXR1cm4gZ2V0U2lnblN0cihlKSArIGJvKHQpICsgXCI6XCIgKyBibyhyKSArIChhIHx8IHMgPyBcIjpcIiArIGJvKGEpICsgZm9ybWF0U3Vic2VjTmFubyhzKSA6IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBmb3JtYXRDYWxlbmRhcihlLCBuKSB7XG4gIHJldHVybiAxICE9PSBuICYmIChuID4gMSB8fCAwID09PSBuICYmIGUgIT09IGwpID8gZm9ybWF0Q2FsZW5kYXJJZChlLCAyID09PSBuKSA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdENhbGVuZGFySWQoZSwgbikge1xuICByZXR1cm4gXCJbXCIgKyAobiA/IFwiIVwiIDogXCJcIikgKyBcInUtY2E9XCIgKyBlICsgXCJdXCI7XG59XG5cbmZ1bmN0aW9uIGZvcm1hdFN1YnNlY05hbm8oZSwgbikge1xuICBsZXQgdCA9IHBhZE51bWJlcig5LCBlKTtcbiAgcmV0dXJuIHQgPSB2b2lkIDAgPT09IG4gPyB0LnJlcGxhY2UobGksIFwiXCIpIDogdC5zbGljZSgwLCBuKSwgdCA/IFwiLlwiICsgdCA6IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGdldFNpZ25TdHIoZSkge1xuICByZXR1cm4gZSA8IDAgPyBcIi1cIiA6IFwiK1wiO1xufVxuXG5mdW5jdGlvbiBmb3JtYXREdXJhdGlvbk51bWJlcihlLCBuKSB7XG4gIHJldHVybiBlIHx8IG4gPyBlLnRvTG9jYWxlU3RyaW5nKFwiZnVsbHdpZGVcIiwge1xuICAgIHVzZUdyb3VwaW5nOiAwXG4gIH0pIDogXCJcIjtcbn1cblxuZnVuY3Rpb24gX3pvbmVkRXBvY2hTbG90c1RvSXNvKGUsIG4pIHtcbiAgY29uc3Qge2Vwb2NoTmFub3NlY29uZHM6IHR9ID0gZSwgbyA9IChuLlIgPyBuIDogbihlLnRpbWVab25lKSkuUih0KSwgciA9IGVwb2NoTmFub1RvSXNvKHQsIG8pO1xuICByZXR1cm4ge1xuICAgIGNhbGVuZGFyOiBlLmNhbGVuZGFyLFxuICAgIC4uLnIsXG4gICAgb2Zmc2V0TmFub3NlY29uZHM6IG9cbiAgfTtcbn1cblxuZnVuY3Rpb24gZ2V0TWF0Y2hpbmdJbnN0YW50Rm9yKGUsIG4sIHQsIG8gPSAwLCByID0gMCwgaSwgYSkge1xuICBpZiAodm9pZCAwICE9PSB0ICYmIDEgPT09IG8gJiYgKDEgPT09IG8gfHwgYSkpIHtcbiAgICByZXR1cm4gaXNvVG9FcG9jaE5hbm9XaXRoT2Zmc2V0KG4sIHQpO1xuICB9XG4gIGNvbnN0IHMgPSBlLkkobik7XG4gIGlmICh2b2lkIDAgIT09IHQgJiYgMyAhPT0gbykge1xuICAgIGNvbnN0IGUgPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBpc29Ub0Vwb2NoTmFubyhuKTtcbiAgICAgIG8gJiYgKHQgPSByb3VuZFRvTWludXRlKHQpKTtcbiAgICAgIGZvciAoY29uc3QgbiBvZiBlKSB7XG4gICAgICAgIGxldCBlID0gYmlnTmFub1RvTnVtYmVyKGRpZmZCaWdOYW5vcyhuLCByKSk7XG4gICAgICAgIGlmIChvICYmIChlID0gcm91bmRUb01pbnV0ZShlKSksIGUgPT09IHQpIHtcbiAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pKHMsIG4sIHQsIGkpO1xuICAgIGlmICh2b2lkIDAgIT09IGUpIHtcbiAgICAgIHJldHVybiBlO1xuICAgIH1cbiAgICBpZiAoMCA9PT0gbykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gYSA/IGlzb1RvRXBvY2hOYW5vKG4pIDogZ2V0U2luZ2xlSW5zdGFudEZvcihlLCBuLCByLCBzKTtcbn1cblxuZnVuY3Rpb24gZ2V0U2luZ2xlSW5zdGFudEZvcihlLCBuLCB0ID0gMCwgbyA9IGUuSShuKSkge1xuICBpZiAoMSA9PT0gby5sZW5ndGgpIHtcbiAgICByZXR1cm4gb1swXTtcbiAgfVxuICBpZiAoMSA9PT0gdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFRvKTtcbiAgfVxuICBpZiAoby5sZW5ndGgpIHtcbiAgICByZXR1cm4gb1szID09PSB0ID8gMSA6IDBdO1xuICB9XG4gIGNvbnN0IHIgPSBpc29Ub0Vwb2NoTmFubyhuKSwgaSA9ICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSBlLlIobW92ZUJpZ05hbm8obiwgLVVvKSk7XG4gICAgcmV0dXJuIChlID0+IHtcbiAgICAgIGlmIChlID4gVW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZ28pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSkoZS5SKG1vdmVCaWdOYW5vKG4sIFVvKSkgLSB0KTtcbiAgfSkoZSwgciksIGEgPSBpICogKDIgPT09IHQgPyAtMSA6IDEpO1xuICByZXR1cm4gKG8gPSBlLkkoZXBvY2hOYW5vVG9Jc28ociwgYSkpKVsyID09PSB0ID8gMCA6IG8ubGVuZ3RoIC0gMV07XG59XG5cbmZ1bmN0aW9uIGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKGUsIG4pIHtcbiAgY29uc3QgdCA9IGUuSShuKTtcbiAgaWYgKHQubGVuZ3RoKSB7XG4gICAgcmV0dXJuIHRbMF07XG4gIH1cbiAgY29uc3QgbyA9IG1vdmVCaWdOYW5vKGlzb1RvRXBvY2hOYW5vKG4pLCAtVW8pO1xuICByZXR1cm4gZS5PKG8sIDEpO1xufVxuXG5mdW5jdGlvbiBZZShlLCBuLCB0KSB7XG4gIHJldHVybiB4ZShjaGVja0Vwb2NoTmFub0luQm91bmRzKGFkZEJpZ05hbm9zKG4uZXBvY2hOYW5vc2Vjb25kcywgKGUgPT4ge1xuICAgIGlmIChkdXJhdGlvbkhhc0RhdGVQYXJ0cyhlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3Iodm8pO1xuICAgIH1cbiAgICByZXR1cm4gZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSwgNSk7XG4gIH0pKGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyh0KSA6IHQpKSkpO1xufVxuXG5mdW5jdGlvbiBwZShlLCBuLCB0LCBvLCByLCBpID0gT2JqZWN0LmNyZWF0ZShudWxsKSkge1xuICBjb25zdCBhID0gbihvLnRpbWVab25lKSwgcyA9IGUoby5jYWxlbmRhcik7XG4gIHJldHVybiB7XG4gICAgLi4ubyxcbiAgICAuLi5tb3ZlWm9uZWRFcG9jaHMoYSwgcywgbywgdCA/IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKHIpIDogciwgaSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gd3QoZSwgbiwgdCwgbywgciA9IE9iamVjdC5jcmVhdGUobnVsbCkpIHtcbiAgY29uc3Qge2NhbGVuZGFyOiBpfSA9IHQ7XG4gIHJldHVybiBqdChtb3ZlRGF0ZVRpbWUoZShpKSwgdCwgbiA/IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKG8pIDogbywgciksIGkpO1xufVxuXG5mdW5jdGlvbiBuZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogaX0gPSB0O1xuICByZXR1cm4gVyhtb3ZlRGF0ZShlKGkpLCB0LCBuID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobykgOiBvLCByKSwgaSk7XG59XG5cbmZ1bmN0aW9uIEd0KGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IHQuY2FsZW5kYXIsIGEgPSBlKGkpO1xuICBsZXQgcyA9IGNoZWNrSXNvRGF0ZUluQm91bmRzKG1vdmVUb0RheU9mTW9udGhVbnNhZmUoYSwgdCkpO1xuICBuICYmIChvID0gQihvKSksIG8uc2lnbiA8IDAgJiYgKHMgPSBhLlAocywge1xuICAgIC4uLnByLFxuICAgIG1vbnRoczogMVxuICB9KSwgcyA9IG1vdmVCeURheXMocywgLTEpKTtcbiAgY29uc3QgYyA9IGEuUChzLCBvLCByKTtcbiAgcmV0dXJuIGNyZWF0ZVBsYWluWWVhck1vbnRoU2xvdHMobW92ZVRvRGF5T2ZNb250aFVuc2FmZShhLCBjKSwgaSk7XG59XG5cbmZ1bmN0aW9uIGF0KGUsIG4sIHQpIHtcbiAgcmV0dXJuIFN0KG1vdmVUaW1lKG4sIGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyh0KSA6IHQpWzBdKTtcbn1cblxuZnVuY3Rpb24gbW92ZVpvbmVkRXBvY2hzKGUsIG4sIHQsIG8sIHIpIHtcbiAgY29uc3QgaSA9IGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKG8sIDUpO1xuICBsZXQgYSA9IHQuZXBvY2hOYW5vc2Vjb25kcztcbiAgaWYgKGR1cmF0aW9uSGFzRGF0ZVBhcnRzKG8pKSB7XG4gICAgY29uc3QgcyA9IGhlKHQsIGUpO1xuICAgIGEgPSBhZGRCaWdOYW5vcyhnZXRTaW5nbGVJbnN0YW50Rm9yKGUsIHtcbiAgICAgIC4uLm1vdmVEYXRlKG4sIHMsIHtcbiAgICAgICAgLi4ubyxcbiAgICAgICAgLi4uaHJcbiAgICAgIH0sIHIpLFxuICAgICAgLi4ubm4odywgcylcbiAgICB9KSwgaSk7XG4gIH0gZWxzZSB7XG4gICAgYSA9IGFkZEJpZ05hbm9zKGEsIGkpLCBtdChyKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVwb2NoTmFub3NlY29uZHM6IGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoYSlcbiAgfTtcbn1cblxuZnVuY3Rpb24gbW92ZURhdGVUaW1lKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgW3IsIGldID0gbW92ZVRpbWUobiwgdCk7XG4gIHJldHVybiBjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLm1vdmVEYXRlKGUsIG4sIHtcbiAgICAgIC4uLnQsXG4gICAgICAuLi5ocixcbiAgICAgIGRheXM6IHQuZGF5cyArIGlcbiAgICB9LCBvKSxcbiAgICAuLi5yXG4gIH0pO1xufVxuXG5mdW5jdGlvbiBtb3ZlRGF0ZShlLCBuLCB0LCBvKSB7XG4gIGlmICh0LnllYXJzIHx8IHQubW9udGhzIHx8IHQud2Vla3MpIHtcbiAgICByZXR1cm4gZS5QKG4sIHQsIG8pO1xuICB9XG4gIG10KG8pO1xuICBjb25zdCByID0gdC5kYXlzICsgZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8odCwgNSlbMF07XG4gIHJldHVybiByID8gY2hlY2tJc29EYXRlSW5Cb3VuZHMobW92ZUJ5RGF5cyhuLCByKSkgOiBuO1xufVxuXG5mdW5jdGlvbiBtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKGUsIG4sIHQgPSAxKSB7XG4gIHJldHVybiBtb3ZlQnlEYXlzKG4sIHQgLSBlLmRheShuKSk7XG59XG5cbmZ1bmN0aW9uIG1vdmVUaW1lKGUsIG4pIHtcbiAgY29uc3QgW3QsIG9dID0gZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8obiwgNSksIFtyLCBpXSA9IG5hbm9Ub0lzb1RpbWVBbmREYXkoaXNvVGltZUZpZWxkc1RvTmFubyhlKSArIG8pO1xuICByZXR1cm4gWyByLCB0ICsgaSBdO1xufVxuXG5mdW5jdGlvbiBtb3ZlQnlEYXlzKGUsIG4pIHtcbiAgcmV0dXJuIG4gPyB7XG4gICAgLi4uZSxcbiAgICAuLi5lcG9jaE1pbGxpVG9Jc28oaXNvVG9FcG9jaE1pbGxpKGUpICsgbiAqIGtvKVxuICB9IDogZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTWFya2VyU3lzdGVtKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IGUodC5jYWxlbmRhcik7XG4gIHJldHVybiBpc1pvbmVkRXBvY2hTbG90cyh0KSA/IFsgdCwgbywgbih0LnRpbWVab25lKSBdIDogWyB7XG4gICAgLi4udCxcbiAgICAuLi5OdFxuICB9LCBvIF07XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1hcmtlclRvRXBvY2hOYW5vKGUpIHtcbiAgcmV0dXJuIGUgPyBleHRyYWN0RXBvY2hOYW5vIDogaXNvVG9FcG9jaE5hbm87XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU1vdmVNYXJrZXIoZSkge1xuICByZXR1cm4gZSA/IFB0KG1vdmVab25lZEVwb2NocywgZSkgOiBtb3ZlRGF0ZVRpbWU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZURpZmZNYXJrZXJzKGUpIHtcbiAgcmV0dXJuIGUgPyBQdChkaWZmWm9uZWRFcG9jaHNFeGFjdCwgZSkgOiBkaWZmRGF0ZVRpbWVzRXhhY3Q7XG59XG5cbmZ1bmN0aW9uIGlzWm9uZWRFcG9jaFNsb3RzKGUpIHtcbiAgcmV0dXJuIGUgJiYgZS5lcG9jaE5hbm9zZWNvbmRzO1xufVxuXG5mdW5jdGlvbiBpc1VuaWZvcm1Vbml0KGUsIG4pIHtcbiAgcmV0dXJuIGUgPD0gNiAtIChpc1pvbmVkRXBvY2hTbG90cyhuKSA/IDEgOiAwKTtcbn1cblxuZnVuY3Rpb24gRShlLCBuLCB0LCBvLCByLCBpLCBhKSB7XG4gIGNvbnN0IHMgPSBlKG5vcm1hbGl6ZU9wdGlvbnMoYSkucmVsYXRpdmVUbyksIGMgPSBNYXRoLm1heChnZXRNYXhEdXJhdGlvblVuaXQociksIGdldE1heER1cmF0aW9uVW5pdChpKSk7XG4gIGlmIChpc1VuaWZvcm1Vbml0KGMsIHMpKSB7XG4gICAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cygoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBhZGRCaWdOYW5vcyhkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8obiksIG8gPyAtMSA6IDEpO1xuICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUoclswXSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHIsXG4gICAgICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhyLCB0KVxuICAgICAgfTtcbiAgICB9KShyLCBpLCBjLCBvKSkpO1xuICB9XG4gIGlmICghcykge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHlvKTtcbiAgfVxuICBvICYmIChpID0gbmVnYXRlRHVyYXRpb25GaWVsZHMoaSkpO1xuICBjb25zdCBbdSwgZiwgbF0gPSBjcmVhdGVNYXJrZXJTeXN0ZW0obiwgdCwgcyksIGQgPSBjcmVhdGVNb3ZlTWFya2VyKGwpLCBtID0gY3JlYXRlRGlmZk1hcmtlcnMobCksIHAgPSBkKGYsIHUsIHIpO1xuICByZXR1cm4gT2UobShmLCB1LCBkKGYsIHAsIGkpLCBjKSk7XG59XG5cbmZ1bmN0aW9uIFYoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0TWF4RHVyYXRpb25Vbml0KG8pLCBbYSwgcywgYywgdSwgZl0gPSAoKGUsIG4sIHQpID0+IHtcbiAgICBlID0gbm9ybWFsaXplT3B0aW9uc09yU3RyaW5nKGUsIFJyKTtcbiAgICBsZXQgbyA9IEtyKGUpO1xuICAgIGNvbnN0IHIgPSB0KGVbQXJdKTtcbiAgICBsZXQgaSA9IHBhcnNlUm91bmRpbmdJbmNJbnRlZ2VyKGUpO1xuICAgIGNvbnN0IGEgPSBpaShlLCA3KTtcbiAgICBsZXQgcyA9IEpyKGUpO1xuICAgIGlmICh2b2lkIDAgPT09IG8gJiYgdm9pZCAwID09PSBzKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihQbyk7XG4gICAgfVxuICAgIGlmIChudWxsID09IHMgJiYgKHMgPSAwKSwgbnVsbCA9PSBvICYmIChvID0gTWF0aC5tYXgocywgbikpLCBjaGVja0xhcmdlc3RTbWFsbGVzdFVuaXQobywgcyksIFxuICAgIGkgPSByZWZpbmVSb3VuZGluZ0luYyhpLCBzLCAxKSwgaSA+IDEgJiYgcyA+IDUgJiYgbyAhPT0gcykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJGb3IgY2FsZW5kYXIgdW5pdHMgd2l0aCByb3VuZGluZ0luY3JlbWVudCA+IDEsIHVzZSBsYXJnZXN0VW5pdCA9IHNtYWxsZXN0VW5pdFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIFsgbywgcywgaSwgYSwgciBdO1xuICB9KShyLCBpLCBlKSwgbCA9IE1hdGgubWF4KGksIGEpO1xuICBpZiAoIWYgJiYgbCA8PSA2KSB7XG4gICAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cygoKGUsIG4sIHQsIG8sIHIpID0+IHtcbiAgICAgIGNvbnN0IGkgPSByb3VuZEJpZ05hbm8oZHVyYXRpb25GaWVsZHNUb0JpZ05hbm8oZSksIHQsIG8sIHIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucHIsXG4gICAgICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhpLCBuKVxuICAgICAgfTtcbiAgICB9KShvLCBhLCBzLCBjLCB1KSkpO1xuICB9XG4gIGlmICghaXNab25lZEVwb2NoU2xvdHMoZikgJiYgIW8uc2lnbikge1xuICAgIHJldHVybiBvO1xuICB9XG4gIGlmICghZikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHlvKTtcbiAgfVxuICBjb25zdCBbZCwgbSwgcF0gPSBjcmVhdGVNYXJrZXJTeXN0ZW0obiwgdCwgZiksIGggPSBjcmVhdGVNYXJrZXJUb0Vwb2NoTmFubyhwKSwgZyA9IGNyZWF0ZU1vdmVNYXJrZXIocCksIEQgPSBjcmVhdGVEaWZmTWFya2VycyhwKSwgVCA9IGcobSwgZCwgbyk7XG4gIGlzWm9uZWRFcG9jaFNsb3RzKGYpIHx8IChjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoZCksIGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyhUKSk7XG4gIGxldCBJID0gRChtLCBkLCBULCBhKTtcbiAgY29uc3QgTSA9IG8uc2lnbiwgTiA9IGNvbXB1dGVEdXJhdGlvblNpZ24oSSk7XG4gIGlmIChNICYmIE4gJiYgTSAhPT0gTikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZvKTtcbiAgfVxuICByZXR1cm4gSSA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihJLCBoKFQpLCBhLCBzLCBjLCB1LCBtLCBkLCBoLCBnKSwgT2UoSSk7XG59XG5cbmZ1bmN0aW9uIFkoZSkge1xuICByZXR1cm4gLTEgPT09IGUuc2lnbiA/IEIoZSkgOiBlO1xufVxuXG5mdW5jdGlvbiBCKGUpIHtcbiAgcmV0dXJuIE9lKG5lZ2F0ZUR1cmF0aW9uRmllbGRzKGUpKTtcbn1cblxuZnVuY3Rpb24gbmVnYXRlRHVyYXRpb25GaWVsZHMoZSkge1xuICBjb25zdCBuID0ge307XG4gIGZvciAoY29uc3QgdCBvZiBwKSB7XG4gICAgblt0XSA9IC0xICogZVt0XSB8fCAwO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiB5KGUpIHtcbiAgcmV0dXJuICFlLnNpZ247XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVEdXJhdGlvblNpZ24oZSwgbiA9IHApIHtcbiAgbGV0IHQgPSAwO1xuICBmb3IgKGNvbnN0IG8gb2Ygbikge1xuICAgIGNvbnN0IG4gPSBNYXRoLnNpZ24oZVtvXSk7XG4gICAgaWYgKG4pIHtcbiAgICAgIGlmICh0ICYmIHQgIT09IG4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoTm8pO1xuICAgICAgfVxuICAgICAgdCA9IG47XG4gICAgfVxuICB9XG4gIHJldHVybiB0O1xufVxuXG5mdW5jdGlvbiBjaGVja0R1cmF0aW9uVW5pdHMoZSkge1xuICBmb3IgKGNvbnN0IG4gb2YgZHIpIHtcbiAgICBjbGFtcEVudGl0eShuLCBlW25dLCAtZGksIGRpLCAxKTtcbiAgfVxuICByZXR1cm4gY2hlY2tEdXJhdGlvblRpbWVVbml0KGJpZ05hbm9Ub051bWJlcihkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlKSwgUm8pKSwgZTtcbn1cblxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvblRpbWVVbml0KGUpIHtcbiAgaWYgKCFOdW1iZXIuaXNTYWZlSW50ZWdlcihlKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKE1vKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhlLCBuID0gNikge1xuICByZXR1cm4gZ2l2ZW5GaWVsZHNUb0JpZ05hbm8oZSwgbiwgcCk7XG59XG5cbmZ1bmN0aW9uIG5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhlLCBuID0gNikge1xuICBjb25zdCBbdCwgb10gPSBlLCByID0gbmFub1RvR2l2ZW5GaWVsZHMobywgbiwgcCk7XG4gIGlmIChyW3Bbbl1dICs9IHQgKiAoVW8gLyBBb1tuXSksICFOdW1iZXIuaXNGaW5pdGUocltwW25dXSkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihJbyk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyhlLCBuID0gNSkge1xuICByZXR1cm4gbmFub1RvR2l2ZW5GaWVsZHMoZSwgbiwgcCk7XG59XG5cbmZ1bmN0aW9uIGR1cmF0aW9uSGFzRGF0ZVBhcnRzKGUpIHtcbiAgcmV0dXJuIEJvb2xlYW4oY29tcHV0ZUR1cmF0aW9uU2lnbihlLCBscikpO1xufVxuXG5mdW5jdGlvbiBnZXRNYXhEdXJhdGlvblVuaXQoZSkge1xuICBsZXQgbiA9IDk7XG4gIGZvciAoO24gPiAwICYmICFlW3Bbbl1dOyBuLS0pIHt9XG4gIHJldHVybiBuO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVTcGxpdFR1cGxlKGUsIG4pIHtcbiAgcmV0dXJuIFsgZSwgbiBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlUGVyaW9kKGUpIHtcbiAgY29uc3QgbiA9IE1hdGguZmxvb3IoZSAvIGNpKSAqIGNpO1xuICByZXR1cm4gWyBuLCBuICsgY2kgXTtcbn1cblxuZnVuY3Rpb24gV2UoZSkge1xuICBjb25zdCBuID0gcGFyc2VEYXRlVGltZUxpa2UoZSA9IHRvU3RyaW5nVmlhUHJpbWl0aXZlKGUpKTtcbiAgaWYgKCFuKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIGxldCB0O1xuICBpZiAobi5qKSB7XG4gICAgdCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCFuLm9mZnNldCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICAgIH1cbiAgICB0ID0gcGFyc2VPZmZzZXROYW5vKG4ub2Zmc2V0KTtcbiAgfVxuICByZXR1cm4gbi50aW1lWm9uZSAmJiBwYXJzZU9mZnNldE5hbm9NYXliZShuLnRpbWVab25lLCAxKSwgeGUoaXNvVG9FcG9jaE5hbm9XaXRoT2Zmc2V0KGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMobiksIHQpKTtcbn1cblxuZnVuY3Rpb24gSChlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZURhdGVUaW1lTGlrZShtKGUpKTtcbiAgaWYgKCFuKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIGlmIChuLnRpbWVab25lKSB7XG4gICAgcmV0dXJuIGZpbmFsaXplWm9uZWREYXRlVGltZShuLCBuLm9mZnNldCA/IHBhcnNlT2Zmc2V0TmFubyhuLm9mZnNldCkgOiB2b2lkIDApO1xuICB9XG4gIGlmIChuLmopIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgcmV0dXJuIGZpbmFsaXplRGF0ZShuKTtcbn1cblxuZnVuY3Rpb24gQWUoZSwgbikge1xuICBjb25zdCB0ID0gcGFyc2VEYXRlVGltZUxpa2UobShlKSk7XG4gIGlmICghdCB8fCAhdC50aW1lWm9uZSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZhaWxlZFBhcnNlKGUpKTtcbiAgfVxuICBjb25zdCB7b2Zmc2V0OiBvfSA9IHQsIHIgPSBvID8gcGFyc2VPZmZzZXROYW5vKG8pIDogdm9pZCAwLCBbLCBpLCBhXSA9IGplKG4pO1xuICByZXR1cm4gZmluYWxpemVab25lZERhdGVUaW1lKHQsIHIsIGksIGEpO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9mZnNldE5hbm8oZSkge1xuICBjb25zdCBuID0gcGFyc2VPZmZzZXROYW5vTWF5YmUoZSk7XG4gIGlmICh2b2lkIDAgPT09IG4pIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbmZ1bmN0aW9uIEJ0KGUpIHtcbiAgY29uc3QgbiA9IHBhcnNlRGF0ZVRpbWVMaWtlKG0oZSkpO1xuICBpZiAoIW4gfHwgbi5qKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBqdChmaW5hbGl6ZURhdGVUaW1lKG4pKTtcbn1cblxuZnVuY3Rpb24gZGUoZSwgbiwgdCkge1xuICBsZXQgbyA9IHBhcnNlRGF0ZVRpbWVMaWtlKG0oZSkpO1xuICBpZiAoIW8gfHwgby5qKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBuID8gby5jYWxlbmRhciA9PT0gbCAmJiAobyA9IC0yNzE4MjEgPT09IG8uaXNvWWVhciAmJiA0ID09PSBvLmlzb01vbnRoID8ge1xuICAgIC4uLm8sXG4gICAgaXNvRGF5OiAyMCxcbiAgICAuLi5OdFxuICB9IDoge1xuICAgIC4uLm8sXG4gICAgaXNvRGF5OiAxLFxuICAgIC4uLk50XG4gIH0pIDogdCAmJiBvLmNhbGVuZGFyID09PSBsICYmIChvID0ge1xuICAgIC4uLm8sXG4gICAgaXNvWWVhcjogQnJcbiAgfSksIFcoby5DID8gZmluYWxpemVEYXRlVGltZShvKSA6IGZpbmFsaXplRGF0ZShvKSk7XG59XG5cbmZ1bmN0aW9uIF90KGUsIG4pIHtcbiAgY29uc3QgdCA9IHBhcnNlWWVhck1vbnRoT25seShtKG4pKTtcbiAgaWYgKHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlzb0NhbGVuZGFyKHQpLCBjcmVhdGVQbGFpblllYXJNb250aFNsb3RzKGNoZWNrSXNvWWVhck1vbnRoSW5Cb3VuZHMoY2hlY2tJc29EYXRlRmllbGRzKHQpKSk7XG4gIH1cbiAgY29uc3QgbyA9IGRlKG4sIDEpO1xuICByZXR1cm4gY3JlYXRlUGxhaW5ZZWFyTW9udGhTbG90cyhtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKGUoby5jYWxlbmRhciksIG8pKTtcbn1cblxuZnVuY3Rpb24gcmVxdWlyZUlzb0NhbGVuZGFyKGUpIHtcbiAgaWYgKGUuY2FsZW5kYXIgIT09IGwpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKGUuY2FsZW5kYXIpKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB4dChlLCBuKSB7XG4gIGNvbnN0IHQgPSBwYXJzZU1vbnRoRGF5T25seShtKG4pKTtcbiAgaWYgKHQpIHtcbiAgICByZXR1cm4gcmVxdWlyZUlzb0NhbGVuZGFyKHQpLCBjcmVhdGVQbGFpbk1vbnRoRGF5U2xvdHMoY2hlY2tJc29EYXRlRmllbGRzKHQpKTtcbiAgfVxuICBjb25zdCBvID0gZGUobiwgMCwgMSksIHtjYWxlbmRhcjogcn0gPSBvLCBpID0gZShyKSwgW2EsIHMsIGNdID0gaS52KG8pLCBbdSwgZl0gPSBpLnEoYSwgcyksIFtsLCBkXSA9IGkuRyh1LCBmLCBjKTtcbiAgcmV0dXJuIGNyZWF0ZVBsYWluTW9udGhEYXlTbG90cyhjaGVja0lzb0RhdGVJbkJvdW5kcyhpLlYobCwgZCwgYykpLCByKTtcbn1cblxuZnVuY3Rpb24gaHQoZSkge1xuICBsZXQgbiwgdCA9IChlID0+IHtcbiAgICBjb25zdCBuID0gUGkuZXhlYyhlKTtcbiAgICByZXR1cm4gbiA/IChvcmdhbml6ZUFubm90YXRpb25QYXJ0cyhuWzEwXSksIG9yZ2FuaXplVGltZVBhcnRzKG4pKSA6IHZvaWQgMDtcbiAgfSkobShlKSk7XG4gIGlmICghdCkge1xuICAgIGlmICh0ID0gcGFyc2VEYXRlVGltZUxpa2UoZSksICF0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gICAgfVxuICAgIGlmICghdC5DKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gICAgfVxuICAgIGlmICh0LmopIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoXCJaXCIpKTtcbiAgICB9XG4gICAgcmVxdWlyZUlzb0NhbGVuZGFyKHQpO1xuICB9XG4gIGlmICgobiA9IHBhcnNlWWVhck1vbnRoT25seShlKSkgJiYgaXNJc29EYXRlRmllbGRzVmFsaWQobikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmYWlsZWRQYXJzZShlKSk7XG4gIH1cbiAgaWYgKChuID0gcGFyc2VNb250aERheU9ubHkoZSkpICYmIGlzSXNvRGF0ZUZpZWxkc1ZhbGlkKG4pKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZmFpbGVkUGFyc2UoZSkpO1xuICB9XG4gIHJldHVybiBTdChjb25zdHJhaW5Jc29UaW1lRmllbGRzKHQsIDEpKTtcbn1cblxuZnVuY3Rpb24gUihlKSB7XG4gIGNvbnN0IG4gPSAoZSA9PiB7XG4gICAgY29uc3QgbiA9IEZpLmV4ZWMoZSk7XG4gICAgcmV0dXJuIG4gPyAoZSA9PiB7XG4gICAgICBmdW5jdGlvbiBwYXJzZVVuaXQoZSwgciwgaSkge1xuICAgICAgICBsZXQgYSA9IDAsIHMgPSAwO1xuICAgICAgICBpZiAoaSAmJiAoW2EsIG9dID0gZGl2TW9kRmxvb3IobywgQW9baV0pKSwgdm9pZCAwICE9PSBlKSB7XG4gICAgICAgICAgaWYgKHQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBzID0gKGUgPT4ge1xuICAgICAgICAgICAgY29uc3QgbiA9IHBhcnNlSW50KGUpO1xuICAgICAgICAgICAgaWYgKCFOdW1iZXIuaXNGaW5pdGUobikpIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZFN1YnN0cmluZyhlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbjtcbiAgICAgICAgICB9KShlKSwgbiA9IDEsIHIgJiYgKG8gPSBwYXJzZVN1YnNlY05hbm8ocikgKiAoQW9baV0gLyBSbyksIHQgPSAxKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYSArIHM7XG4gICAgICB9XG4gICAgICBsZXQgbiA9IDAsIHQgPSAwLCBvID0gMCwgciA9IHtcbiAgICAgICAgLi4uemlwUHJvcHMocCwgWyBwYXJzZVVuaXQoZVsyXSksIHBhcnNlVW5pdChlWzNdKSwgcGFyc2VVbml0KGVbNF0pLCBwYXJzZVVuaXQoZVs1XSksIHBhcnNlVW5pdChlWzZdLCBlWzddLCA1KSwgcGFyc2VVbml0KGVbOF0sIGVbOV0sIDQpLCBwYXJzZVVuaXQoZVsxMF0sIGVbMTFdLCAzKSBdKSxcbiAgICAgICAgLi4ubmFub1RvR2l2ZW5GaWVsZHMobywgMiwgcClcbiAgICAgIH07XG4gICAgICBpZiAoIW4pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3Iobm9WYWxpZEZpZWxkcyhwKSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcGFyc2VTaWduKGVbMV0pIDwgMCAmJiAociA9IG5lZ2F0ZUR1cmF0aW9uRmllbGRzKHIpKSwgcjtcbiAgICB9KShuKSA6IHZvaWQgMDtcbiAgfSkobShlKSk7XG4gIGlmICghbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGZhaWxlZFBhcnNlKGUpKTtcbiAgfVxuICByZXR1cm4gT2UoY2hlY2tEdXJhdGlvblVuaXRzKG4pKTtcbn1cblxuZnVuY3Rpb24gZihlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZURhdGVUaW1lTGlrZShlKSB8fCBwYXJzZVllYXJNb250aE9ubHkoZSkgfHwgcGFyc2VNb250aERheU9ubHkoZSk7XG4gIHJldHVybiBuID8gbi5jYWxlbmRhciA6IGU7XG59XG5cbmZ1bmN0aW9uIFooZSkge1xuICBjb25zdCBuID0gcGFyc2VEYXRlVGltZUxpa2UoZSk7XG4gIHJldHVybiBuICYmIChuLnRpbWVab25lIHx8IG4uaiAmJiBzaSB8fCBuLm9mZnNldCkgfHwgZTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVab25lZERhdGVUaW1lKGUsIG4sIHQgPSAwLCBvID0gMCkge1xuICBjb25zdCByID0gTShlLnRpbWVab25lKSwgaSA9IEwocik7XG4gIGxldCBhO1xuICByZXR1cm4gY2hlY2tJc29EYXRlVGltZUZpZWxkcyhlKSwgYSA9IGUuQyA/IGdldE1hdGNoaW5nSW5zdGFudEZvcihpLCBlLCBuLCB0LCBvLCAhaS4kLCBlLmopIDogZ2V0U3RhcnRPZkRheUluc3RhbnRGb3IoaSwgZSksIFxuICBfZShhLCByLCB1KGUuY2FsZW5kYXIpKTtcbn1cblxuZnVuY3Rpb24gZmluYWxpemVEYXRlVGltZShlKSB7XG4gIHJldHVybiByZXNvbHZlU2xvdHNDYWxlbmRhcihjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoY2hlY2tJc29EYXRlVGltZUZpZWxkcyhlKSkpO1xufVxuXG5mdW5jdGlvbiBmaW5hbGl6ZURhdGUoZSkge1xuICByZXR1cm4gcmVzb2x2ZVNsb3RzQ2FsZW5kYXIoY2hlY2tJc29EYXRlSW5Cb3VuZHMoY2hlY2tJc29EYXRlRmllbGRzKGUpKSk7XG59XG5cbmZ1bmN0aW9uIHJlc29sdmVTbG90c0NhbGVuZGFyKGUpIHtcbiAgcmV0dXJuIHtcbiAgICAuLi5lLFxuICAgIGNhbGVuZGFyOiB1KGUuY2FsZW5kYXIpXG4gIH07XG59XG5cbmZ1bmN0aW9uIHBhcnNlRGF0ZVRpbWVMaWtlKGUpIHtcbiAgY29uc3QgbiA9IHZpLmV4ZWMoZSk7XG4gIHJldHVybiBuID8gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBlWzEwXSwgdCA9IFwiWlwiID09PSAobiB8fCBcIlwiKS50b1VwcGVyQ2FzZSgpO1xuICAgIHJldHVybiB7XG4gICAgICBpc29ZZWFyOiBvcmdhbml6ZUlzb1llYXJQYXJ0cyhlKSxcbiAgICAgIGlzb01vbnRoOiBwYXJzZUludChlWzRdKSxcbiAgICAgIGlzb0RheTogcGFyc2VJbnQoZVs1XSksXG4gICAgICAuLi5vcmdhbml6ZVRpbWVQYXJ0cyhlLnNsaWNlKDUpKSxcbiAgICAgIC4uLm9yZ2FuaXplQW5ub3RhdGlvblBhcnRzKGVbMTZdKSxcbiAgICAgIEM6IEJvb2xlYW4oZVs2XSksXG4gICAgICBqOiB0LFxuICAgICAgb2Zmc2V0OiB0ID8gdm9pZCAwIDogblxuICAgIH07XG4gIH0pKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZVllYXJNb250aE9ubHkoZSkge1xuICBjb25zdCBuID0gTmkuZXhlYyhlKTtcbiAgcmV0dXJuIG4gPyAoZSA9PiAoe1xuICAgIGlzb1llYXI6IG9yZ2FuaXplSXNvWWVhclBhcnRzKGUpLFxuICAgIGlzb01vbnRoOiBwYXJzZUludChlWzRdKSxcbiAgICBpc29EYXk6IDEsXG4gICAgLi4ub3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZVs1XSlcbiAgfSkpKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZU1vbnRoRGF5T25seShlKSB7XG4gIGNvbnN0IG4gPSB5aS5leGVjKGUpO1xuICByZXR1cm4gbiA/IChlID0+ICh7XG4gICAgaXNvWWVhcjogQnIsXG4gICAgaXNvTW9udGg6IHBhcnNlSW50KGVbMV0pLFxuICAgIGlzb0RheTogcGFyc2VJbnQoZVsyXSksXG4gICAgLi4ub3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZVszXSlcbiAgfSkpKG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBwYXJzZU9mZnNldE5hbm9NYXliZShlLCBuKSB7XG4gIGNvbnN0IHQgPSBFaS5leGVjKGUpO1xuICByZXR1cm4gdCA/ICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSBlWzRdIHx8IGVbNV07XG4gICAgaWYgKG4gJiYgdCkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZFN1YnN0cmluZyh0KSk7XG4gICAgfVxuICAgIHJldHVybiAoZSA9PiB7XG4gICAgICBpZiAoTWF0aC5hYnMoZSkgPj0gVW8pIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaG8pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGU7XG4gICAgfSkoKHBhcnNlSW50MChlWzJdKSAqIHpvICsgcGFyc2VJbnQwKGVbM10pICogWm8gKyBwYXJzZUludDAoZVs0XSkgKiBSbyArIHBhcnNlU3Vic2VjTmFubyhlWzVdIHx8IFwiXCIpKSAqIHBhcnNlU2lnbihlWzFdKSk7XG4gIH0pKHQsIG4pIDogdm9pZCAwO1xufVxuXG5mdW5jdGlvbiBvcmdhbml6ZUlzb1llYXJQYXJ0cyhlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZVNpZ24oZVsxXSksIHQgPSBwYXJzZUludChlWzJdIHx8IGVbM10pO1xuICBpZiAobiA8IDAgJiYgIXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKC0wKSk7XG4gIH1cbiAgcmV0dXJuIG4gKiB0O1xufVxuXG5mdW5jdGlvbiBvcmdhbml6ZVRpbWVQYXJ0cyhlKSB7XG4gIGNvbnN0IG4gPSBwYXJzZUludDAoZVszXSk7XG4gIHJldHVybiB7XG4gICAgLi4ubmFub1RvSXNvVGltZUFuZERheShwYXJzZVN1YnNlY05hbm8oZVs0XSB8fCBcIlwiKSlbMF0sXG4gICAgaXNvSG91cjogcGFyc2VJbnQwKGVbMV0pLFxuICAgIGlzb01pbnV0ZTogcGFyc2VJbnQwKGVbMl0pLFxuICAgIGlzb1NlY29uZDogNjAgPT09IG4gPyA1OSA6IG5cbiAgfTtcbn1cblxuZnVuY3Rpb24gb3JnYW5pemVBbm5vdGF0aW9uUGFydHMoZSkge1xuICBsZXQgbiwgdDtcbiAgY29uc3QgbyA9IFtdO1xuICBpZiAoZS5yZXBsYWNlKFNpLCAoKGUsIHIsIGkpID0+IHtcbiAgICBjb25zdCBhID0gQm9vbGVhbihyKSwgW3MsIGNdID0gaS5zcGxpdChcIj1cIikucmV2ZXJzZSgpO1xuICAgIGlmIChjKSB7XG4gICAgICBpZiAoXCJ1LWNhXCIgPT09IGMpIHtcbiAgICAgICAgby5wdXNoKHMpLCBuIHx8IChuID0gYSk7XG4gICAgICB9IGVsc2UgaWYgKGEgfHwgL1tBLVpdLy50ZXN0KGMpKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpZiAodCkge1xuICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihpbnZhbGlkU3Vic3RyaW5nKGUpKTtcbiAgICAgIH1cbiAgICAgIHQgPSBzO1xuICAgIH1cbiAgICByZXR1cm4gXCJcIjtcbiAgfSkpLCBvLmxlbmd0aCA+IDEgJiYgbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRTdWJzdHJpbmcoZSkpO1xuICB9XG4gIHJldHVybiB7XG4gICAgdGltZVpvbmU6IHQsXG4gICAgY2FsZW5kYXI6IG9bMF0gfHwgbFxuICB9O1xufVxuXG5mdW5jdGlvbiBwYXJzZVN1YnNlY05hbm8oZSkge1xuICByZXR1cm4gcGFyc2VJbnQoZS5wYWRFbmQoOSwgXCIwXCIpKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlUmVnRXhwKGUpIHtcbiAgcmV0dXJuIG5ldyBSZWdFeHAoYF4ke2V9JGAsIFwiaVwiKTtcbn1cblxuZnVuY3Rpb24gcGFyc2VTaWduKGUpIHtcbiAgcmV0dXJuIGUgJiYgXCIrXCIgIT09IGUgPyAtMSA6IDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50MChlKSB7XG4gIHJldHVybiB2b2lkIDAgPT09IGUgPyAwIDogcGFyc2VJbnQoZSk7XG59XG5cbmZ1bmN0aW9uIFplKGUpIHtcbiAgcmV0dXJuIE0obShlKSk7XG59XG5cbmZ1bmN0aW9uIE0oZSkge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IFNlKG4pIDogbiA/IChlID0+IHtcbiAgICBpZiAoT2kudGVzdChlKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoRihlKSk7XG4gICAgfVxuICAgIGlmIChiaS50ZXN0KGUpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihwbyk7XG4gICAgfVxuICAgIHJldHVybiBlLnRvTG93ZXJDYXNlKCkuc3BsaXQoXCIvXCIpLm1hcCgoKGUsIG4pID0+IChlLmxlbmd0aCA8PSAzIHx8IC9cXGQvLnRlc3QoZSkpICYmICEvZXRjfHlhcC8udGVzdChlKSA/IGUudG9VcHBlckNhc2UoKSA6IGUucmVwbGFjZSgvYmFqYXxkdW1vbnR8W2Etel0rL2csICgoZSwgdCkgPT4gZS5sZW5ndGggPD0gMiAmJiAhbiB8fCBcImluXCIgPT09IGUgfHwgXCJjaGF0XCIgPT09IGUgPyBlLnRvVXBwZXJDYXNlKCkgOiBlLmxlbmd0aCA+IDIgfHwgIXQgPyBjYXBpdGFsaXplKGUpLnJlcGxhY2UoL2lzbGFuZHxub3JvbmhhfG11cmRvfHJpdmFkYXZpYXx1cnZpbGxlLywgY2FwaXRhbGl6ZSkgOiBlKSkpKS5qb2luKFwiL1wiKTtcbiAgfSkoZSkgOiBzaTtcbn1cblxuZnVuY3Rpb24gZ2V0VGltZVpvbmVBdG9taWMoZSkge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJudW1iZXJcIiA9PSB0eXBlb2YgbiA/IG4gOiBuID8gbi5yZXNvbHZlZE9wdGlvbnMoKS50aW1lWm9uZSA6IHNpO1xufVxuXG5mdW5jdGlvbiBnZXRUaW1lWm9uZUVzc2VuY2UoZSkge1xuICBjb25zdCBuID0gcGFyc2VPZmZzZXROYW5vTWF5YmUoZSA9IGUudG9VcHBlckNhc2UoKSwgMSk7XG4gIHJldHVybiB2b2lkIDAgIT09IG4gPyBuIDogZSAhPT0gc2kgPyB3aShlKSA6IHZvaWQgMDtcbn1cblxuZnVuY3Rpb24gS2UoZSwgbikge1xuICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGUuZXBvY2hOYW5vc2Vjb25kcywgbi5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24gQmUoZSwgbikge1xuICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGUuZXBvY2hOYW5vc2Vjb25kcywgbi5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24gSyhlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBlKG5vcm1hbGl6ZU9wdGlvbnMoaSkucmVsYXRpdmVUbyksIHMgPSBNYXRoLm1heChnZXRNYXhEdXJhdGlvblVuaXQobyksIGdldE1heER1cmF0aW9uVW5pdChyKSk7XG4gIGlmIChhbGxQcm9wc0VxdWFsKHAsIG8sIHIpKSB7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgaWYgKGlzVW5pZm9ybVVuaXQocywgYSkpIHtcbiAgICByZXR1cm4gY29tcGFyZUJpZ05hbm9zKGR1cmF0aW9uRmllbGRzVG9CaWdOYW5vKG8pLCBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhyKSk7XG4gIH1cbiAgaWYgKCFhKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoeW8pO1xuICB9XG4gIGNvbnN0IFtjLCB1LCBmXSA9IGNyZWF0ZU1hcmtlclN5c3RlbShuLCB0LCBhKSwgbCA9IGNyZWF0ZU1hcmtlclRvRXBvY2hOYW5vKGYpLCBkID0gY3JlYXRlTW92ZU1hcmtlcihmKTtcbiAgcmV0dXJuIGNvbXBhcmVCaWdOYW5vcyhsKGQodSwgYywgbykpLCBsKGQodSwgYywgcikpKTtcbn1cblxuZnVuY3Rpb24gWXQoZSwgbikge1xuICByZXR1cm4gdGUoZSwgbikgfHwgRHQoZSwgbik7XG59XG5cbmZ1bmN0aW9uIHRlKGUsIG4pIHtcbiAgcmV0dXJuIGNvbXBhcmVOdW1iZXJzKGlzb1RvRXBvY2hNaWxsaShlKSwgaXNvVG9FcG9jaE1pbGxpKG4pKTtcbn1cblxuZnVuY3Rpb24gRHQoZSwgbikge1xuICByZXR1cm4gY29tcGFyZU51bWJlcnMoaXNvVGltZUZpZWxkc1RvTmFubyhlKSwgaXNvVGltZUZpZWxkc1RvTmFubyhuKSk7XG59XG5cbmZ1bmN0aW9uIFZlKGUsIG4pIHtcbiAgcmV0dXJuICFLZShlLCBuKTtcbn1cblxuZnVuY3Rpb24gQ2UoZSwgbikge1xuICByZXR1cm4gIUJlKGUsIG4pICYmICEhaXNUaW1lWm9uZUlkc0VxdWFsKGUudGltZVpvbmUsIG4udGltZVpvbmUpICYmIGUuY2FsZW5kYXIgPT09IG4uY2FsZW5kYXI7XG59XG5cbmZ1bmN0aW9uIEN0KGUsIG4pIHtcbiAgcmV0dXJuICFZdChlLCBuKSAmJiBlLmNhbGVuZGFyID09PSBuLmNhbGVuZGFyO1xufVxuXG5mdW5jdGlvbiByZShlLCBuKSB7XG4gIHJldHVybiAhdGUoZSwgbikgJiYgZS5jYWxlbmRhciA9PT0gbi5jYWxlbmRhcjtcbn1cblxuZnVuY3Rpb24gJHQoZSwgbikge1xuICByZXR1cm4gIXRlKGUsIG4pICYmIGUuY2FsZW5kYXIgPT09IG4uY2FsZW5kYXI7XG59XG5cbmZ1bmN0aW9uIEx0KGUsIG4pIHtcbiAgcmV0dXJuICF0ZShlLCBuKSAmJiBlLmNhbGVuZGFyID09PSBuLmNhbGVuZGFyO1xufVxuXG5mdW5jdGlvbiBzdChlLCBuKSB7XG4gIHJldHVybiAhRHQoZSwgbik7XG59XG5cbmZ1bmN0aW9uIGlzVGltZVpvbmVJZHNFcXVhbChlLCBuKSB7XG4gIGlmIChlID09PSBuKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4gZ2V0VGltZVpvbmVBdG9taWMoZSkgPT09IGdldFRpbWVab25lQXRvbWljKG4pO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG5mdW5jdGlvbiBFZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSByZWZpbmVEaWZmT3B0aW9ucyhlLCBvLCAzLCA1KSwgaSA9IGRpZmZFcG9jaE5hbm9zKG4uZXBvY2hOYW5vc2Vjb25kcywgdC5lcG9jaE5hbm9zZWNvbmRzLCAuLi5yKTtcbiAgcmV0dXJuIE9lKGUgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyhpKSA6IGkpO1xufVxuXG5mdW5jdGlvbiB3ZShlLCBuLCB0LCBvLCByLCBpKSB7XG4gIGNvbnN0IGEgPSBnZXRDb21tb25DYWxlbmRhcklkKG8uY2FsZW5kYXIsIHIuY2FsZW5kYXIpLCBbcywgYywgdSwgZl0gPSByZWZpbmVEaWZmT3B0aW9ucyh0LCBpLCA1KSwgbCA9IG8uZXBvY2hOYW5vc2Vjb25kcywgZCA9IHIuZXBvY2hOYW5vc2Vjb25kcywgbSA9IGNvbXBhcmVCaWdOYW5vcyhkLCBsKTtcbiAgbGV0IHA7XG4gIGlmIChtKSB7XG4gICAgaWYgKHMgPCA2KSB7XG4gICAgICBwID0gZGlmZkVwb2NoTmFub3MobCwgZCwgcywgYywgdSwgZik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IHQgPSBuKCgoZSwgbikgPT4ge1xuICAgICAgICBpZiAoIWlzVGltZVpvbmVJZHNFcXVhbChlLCBuKSkge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1vKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH0pKG8udGltZVpvbmUsIHIudGltZVpvbmUpKSwgbCA9IGUoYSk7XG4gICAgICBwID0gZGlmZlpvbmVkRXBvY2hzQmlnKGwsIHQsIG8sIHIsIG0sIHMsIGkpLCBwID0gcm91bmRSZWxhdGl2ZUR1cmF0aW9uKHAsIGQsIHMsIGMsIHUsIGYsIGwsIG8sIGV4dHJhY3RFcG9jaE5hbm8sIFB0KG1vdmVab25lZEVwb2NocywgdCkpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwID0gcHI7XG4gIH1cbiAgcmV0dXJuIE9lKHQgPyBuZWdhdGVEdXJhdGlvbkZpZWxkcyhwKSA6IHApO1xufVxuXG5mdW5jdGlvbiBJdChlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBnZXRDb21tb25DYWxlbmRhcklkKHQuY2FsZW5kYXIsIG8uY2FsZW5kYXIpLCBbYSwgcywgYywgdV0gPSByZWZpbmVEaWZmT3B0aW9ucyhuLCByLCA2KSwgZiA9IGlzb1RvRXBvY2hOYW5vKHQpLCBsID0gaXNvVG9FcG9jaE5hbm8obyksIGQgPSBjb21wYXJlQmlnTmFub3MobCwgZik7XG4gIGxldCBtO1xuICBpZiAoZCkge1xuICAgIGlmIChhIDw9IDYpIHtcbiAgICAgIG0gPSBkaWZmRXBvY2hOYW5vcyhmLCBsLCBhLCBzLCBjLCB1KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgbiA9IGUoaSk7XG4gICAgICBtID0gZGlmZkRhdGVUaW1lc0JpZyhuLCB0LCBvLCBkLCBhLCByKSwgbSA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihtLCBsLCBhLCBzLCBjLCB1LCBuLCB0LCBpc29Ub0Vwb2NoTmFubywgbW92ZURhdGVUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbSA9IHByO1xuICB9XG4gIHJldHVybiBPZShuID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobSkgOiBtKTtcbn1cblxuZnVuY3Rpb24gb2UoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0Q29tbW9uQ2FsZW5kYXJJZCh0LmNhbGVuZGFyLCBvLmNhbGVuZGFyKTtcbiAgcmV0dXJuIGRpZmZEYXRlTGlrZShuLCAoKCkgPT4gZShpKSksIHQsIG8sIC4uLnJlZmluZURpZmZPcHRpb25zKG4sIHIsIDYsIDksIDYpKTtcbn1cblxuZnVuY3Rpb24genQoZSwgbiwgdCwgbywgcikge1xuICBjb25zdCBpID0gZ2V0Q29tbW9uQ2FsZW5kYXJJZCh0LmNhbGVuZGFyLCBvLmNhbGVuZGFyKSwgYSA9IHJlZmluZURpZmZPcHRpb25zKG4sIHIsIDksIDksIDgpLCBzID0gZShpKSwgYyA9IG1vdmVUb0RheU9mTW9udGhVbnNhZmUocywgdCksIHUgPSBtb3ZlVG9EYXlPZk1vbnRoVW5zYWZlKHMsIG8pO1xuICByZXR1cm4gYy5pc29ZZWFyID09PSB1Lmlzb1llYXIgJiYgYy5pc29Nb250aCA9PT0gdS5pc29Nb250aCAmJiBjLmlzb0RheSA9PT0gdS5pc29EYXkgPyBPZShwcikgOiBkaWZmRGF0ZUxpa2UobiwgKCgpID0+IHMpLCBjaGVja0lzb0RhdGVJbkJvdW5kcyhjKSwgY2hlY2tJc29EYXRlSW5Cb3VuZHModSksIC4uLmEsIDgpO1xufVxuXG5mdW5jdGlvbiBkaWZmRGF0ZUxpa2UoZSwgbiwgdCwgbywgciwgaSwgYSwgcywgYyA9IDYpIHtcbiAgY29uc3QgdSA9IGlzb1RvRXBvY2hOYW5vKHQpLCBmID0gaXNvVG9FcG9jaE5hbm8obyk7XG4gIGlmICh2b2lkIDAgPT09IHUgfHwgdm9pZCAwID09PSBmKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICB9XG4gIGxldCBsO1xuICBpZiAoY29tcGFyZUJpZ05hbm9zKGYsIHUpKSB7XG4gICAgaWYgKDYgPT09IHIpIHtcbiAgICAgIGwgPSBkaWZmRXBvY2hOYW5vcyh1LCBmLCByLCBpLCBhLCBzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgZSA9IG4oKTtcbiAgICAgIGwgPSBlLk4odCwgbywgciksIGkgPT09IGMgJiYgMSA9PT0gYSB8fCAobCA9IHJvdW5kUmVsYXRpdmVEdXJhdGlvbihsLCBmLCByLCBpLCBhLCBzLCBlLCB0LCBpc29Ub0Vwb2NoTmFubywgbW92ZURhdGUpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbCA9IHByO1xuICB9XG4gIHJldHVybiBPZShlID8gbmVnYXRlRHVyYXRpb25GaWVsZHMobCkgOiBsKTtcbn1cblxuZnVuY3Rpb24gaXQoZSwgbiwgdCwgbykge1xuICBjb25zdCBbciwgaSwgYSwgc10gPSByZWZpbmVEaWZmT3B0aW9ucyhlLCBvLCA1LCA1KSwgYyA9IHJvdW5kQnlJbmMoZGlmZlRpbWVzKG4sIHQpLCBjb21wdXRlTmFub0luYyhpLCBhKSwgcyksIHUgPSB7XG4gICAgLi4ucHIsXG4gICAgLi4ubmFub1RvRHVyYXRpb25UaW1lRmllbGRzKGMsIHIpXG4gIH07XG4gIHJldHVybiBPZShlID8gbmVnYXRlRHVyYXRpb25GaWVsZHModSkgOiB1KTtcbn1cblxuZnVuY3Rpb24gZGlmZlpvbmVkRXBvY2hzRXhhY3QoZSwgbiwgdCwgbywgciwgaSkge1xuICBjb25zdCBhID0gY29tcGFyZUJpZ05hbm9zKG8uZXBvY2hOYW5vc2Vjb25kcywgdC5lcG9jaE5hbm9zZWNvbmRzKTtcbiAgcmV0dXJuIGEgPyByIDwgNiA/IGRpZmZFcG9jaE5hbm9zRXhhY3QodC5lcG9jaE5hbm9zZWNvbmRzLCBvLmVwb2NoTmFub3NlY29uZHMsIHIpIDogZGlmZlpvbmVkRXBvY2hzQmlnKG4sIGUsIHQsIG8sIGEsIHIsIGkpIDogcHI7XG59XG5cbmZ1bmN0aW9uIGRpZmZEYXRlVGltZXNFeGFjdChlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBpc29Ub0Vwb2NoTmFubyhuKSwgYSA9IGlzb1RvRXBvY2hOYW5vKHQpLCBzID0gY29tcGFyZUJpZ05hbm9zKGEsIGkpO1xuICByZXR1cm4gcyA/IG8gPD0gNiA/IGRpZmZFcG9jaE5hbm9zRXhhY3QoaSwgYSwgbykgOiBkaWZmRGF0ZVRpbWVzQmlnKGUsIG4sIHQsIHMsIG8sIHIpIDogcHI7XG59XG5cbmZ1bmN0aW9uIGRpZmZab25lZEVwb2Noc0JpZyhlLCBuLCB0LCBvLCByLCBpLCBhKSB7XG4gIGNvbnN0IFtzLCBjLCB1XSA9ICgoZSwgbiwgdCwgbykgPT4ge1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU1pZCgpIHtcbiAgICAgIHJldHVybiBmID0ge1xuICAgICAgICAuLi5tb3ZlQnlEYXlzKGEsIGMrKyAqIC1vKSxcbiAgICAgICAgLi4uaVxuICAgICAgfSwgbCA9IGdldFNpbmdsZUluc3RhbnRGb3IoZSwgZiksIGNvbXBhcmVCaWdOYW5vcyhzLCBsKSA9PT0gLW87XG4gICAgfVxuICAgIGNvbnN0IHIgPSBoZShuLCBlKSwgaSA9IG5uKHcsIHIpLCBhID0gaGUodCwgZSksIHMgPSB0LmVwb2NoTmFub3NlY29uZHM7XG4gICAgbGV0IGMgPSAwO1xuICAgIGNvbnN0IHUgPSBkaWZmVGltZXMociwgYSk7XG4gICAgbGV0IGYsIGw7XG4gICAgaWYgKE1hdGguc2lnbih1KSA9PT0gLW8gJiYgYysrLCB1cGRhdGVNaWQoKSAmJiAoLTEgPT09IG8gfHwgdXBkYXRlTWlkKCkpKSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihmbyk7XG4gICAgfVxuICAgIGNvbnN0IGQgPSBiaWdOYW5vVG9OdW1iZXIoZGlmZkJpZ05hbm9zKGwsIHMpKTtcbiAgICByZXR1cm4gWyByLCBmLCBkIF07XG4gIH0pKG4sIHQsIG8sIHIpO1xuICB2YXIgZiwgbDtcbiAgcmV0dXJuIHtcbiAgICAuLi42ID09PSBpID8gKGYgPSBzLCBsID0gYywge1xuICAgICAgLi4ucHIsXG4gICAgICBkYXlzOiBkaWZmRGF5cyhmLCBsKVxuICAgIH0pIDogZS5OKHMsIGMsIGksIGEpLFxuICAgIC4uLm5hbm9Ub0R1cmF0aW9uVGltZUZpZWxkcyh1KVxuICB9O1xufVxuXG5mdW5jdGlvbiBkaWZmRGF0ZVRpbWVzQmlnKGUsIG4sIHQsIG8sIHIsIGkpIHtcbiAgY29uc3QgW2EsIHMsIGNdID0gKChlLCBuLCB0KSA9PiB7XG4gICAgbGV0IG8gPSBuLCByID0gZGlmZlRpbWVzKGUsIG4pO1xuICAgIHJldHVybiBNYXRoLnNpZ24ocikgPT09IC10ICYmIChvID0gbW92ZUJ5RGF5cyhuLCAtdCksIHIgKz0gVW8gKiB0KSwgWyBlLCBvLCByIF07XG4gIH0pKG4sIHQsIG8pO1xuICByZXR1cm4ge1xuICAgIC4uLmUuTihhLCBzLCByLCBpKSxcbiAgICAuLi5uYW5vVG9EdXJhdGlvblRpbWVGaWVsZHMoYylcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkVwb2NoTmFub3MoZSwgbiwgdCwgbywgciwgaSkge1xuICByZXR1cm4ge1xuICAgIC4uLnByLFxuICAgIC4uLm5hbm9Ub0R1cmF0aW9uRGF5VGltZUZpZWxkcyhyb3VuZEJpZ05hbm8oZGlmZkJpZ05hbm9zKGUsIG4pLCBvLCByLCBpKSwgdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkVwb2NoTmFub3NFeGFjdChlLCBuLCB0KSB7XG4gIHJldHVybiB7XG4gICAgLi4ucHIsXG4gICAgLi4ubmFub1RvRHVyYXRpb25EYXlUaW1lRmllbGRzKGRpZmZCaWdOYW5vcyhlLCBuKSwgdClcbiAgfTtcbn1cblxuZnVuY3Rpb24gZGlmZkRheXMoZSwgbikge1xuICByZXR1cm4gZGlmZkVwb2NoTWlsbGlCeURheShpc29Ub0Vwb2NoTWlsbGkoZSksIGlzb1RvRXBvY2hNaWxsaShuKSk7XG59XG5cbmZ1bmN0aW9uIGRpZmZFcG9jaE1pbGxpQnlEYXkoZSwgbikge1xuICByZXR1cm4gTWF0aC50cnVuYygobiAtIGUpIC8ga28pO1xufVxuXG5mdW5jdGlvbiBkaWZmVGltZXMoZSwgbikge1xuICByZXR1cm4gaXNvVGltZUZpZWxkc1RvTmFubyhuKSAtIGlzb1RpbWVGaWVsZHNUb05hbm8oZSk7XG59XG5cbmZ1bmN0aW9uIGdldENvbW1vbkNhbGVuZGFySWQoZSwgbikge1xuICBpZiAoZSAhPT0gbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGxvKTtcbiAgfVxuICByZXR1cm4gZTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZU5hdGl2ZVdlZWtPZlllYXIoZSkge1xuICByZXR1cm4gdGhpcy5tKGUpWzBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlTmF0aXZlWWVhck9mV2VlayhlKSB7XG4gIHJldHVybiB0aGlzLm0oZSlbMV07XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVOYXRpdmVEYXlPZlllYXIoZSkge1xuICBjb25zdCBbbl0gPSB0aGlzLnYoZSk7XG4gIHJldHVybiBkaWZmRXBvY2hNaWxsaUJ5RGF5KHRoaXMucChuKSwgaXNvVG9FcG9jaE1pbGxpKGUpKSArIDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlTW9udGhDb2RlKGUpIHtcbiAgY29uc3QgbiA9IEJpLmV4ZWMoZSk7XG4gIGlmICghbikge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGludmFsaWRNb250aENvZGUoZSkpO1xuICB9XG4gIHJldHVybiBbIHBhcnNlSW50KG5bMV0pLCBCb29sZWFuKG5bMl0pIF07XG59XG5cbmZ1bmN0aW9uIGZvcm1hdE1vbnRoQ29kZShlLCBuKSB7XG4gIHJldHVybiBcIk1cIiArIGJvKGUpICsgKG4gPyBcIkxcIiA6IFwiXCIpO1xufVxuXG5mdW5jdGlvbiBtb250aENvZGVOdW1iZXJUb01vbnRoKGUsIG4sIHQpIHtcbiAgcmV0dXJuIGUgKyAobiB8fCB0ICYmIGUgPj0gdCA/IDEgOiAwKTtcbn1cblxuZnVuY3Rpb24gbW9udGhUb01vbnRoQ29kZU51bWJlcihlLCBuKSB7XG4gIHJldHVybiBlIC0gKG4gJiYgZSA+PSBuID8gMSA6IDApO1xufVxuXG5mdW5jdGlvbiBlcmFZZWFyVG9ZZWFyKGUsIG4pIHtcbiAgcmV0dXJuIChuICsgZSkgKiAoTWF0aC5zaWduKG4pIHx8IDEpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyRXJhT3JpZ2lucyhlKSB7XG4gIHJldHVybiBpcltnZXRDYWxlbmRhcklkQmFzZShlKV07XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YShlKSB7XG4gIHJldHVybiBzcltnZXRDYWxlbmRhcklkQmFzZShlKV07XG59XG5cbmZ1bmN0aW9uIGdldENhbGVuZGFySWRCYXNlKGUpIHtcbiAgcmV0dXJuIGNvbXB1dGVDYWxlbmRhcklkQmFzZShlLmlkIHx8IGwpO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVJbnRsQ2FsZW5kYXIoZSkge1xuICBmdW5jdGlvbiBlcG9jaE1pbGxpVG9JbnRsRmllbGRzKGUpIHtcbiAgICByZXR1cm4gKChlLCBuKSA9PiAoe1xuICAgICAgLi4ucGFyc2VJbnRsWWVhcihlLCBuKSxcbiAgICAgIG86IGUubW9udGgsXG4gICAgICBkYXk6IHBhcnNlSW50KGUuZGF5KVxuICAgIH0pKShoYXNoSW50bEZvcm1hdFBhcnRzKG4sIGUpLCB0KTtcbiAgfVxuICBjb25zdCBuID0gQ2koZSksIHQgPSBjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSk7XG4gIHJldHVybiB7XG4gICAgaWQ6IGUsXG4gICAgaDogY3JlYXRlSW50bEZpZWxkQ2FjaGUoZXBvY2hNaWxsaVRvSW50bEZpZWxkcyksXG4gICAgbDogY3JlYXRlSW50bFllYXJEYXRhQ2FjaGUoZXBvY2hNaWxsaVRvSW50bEZpZWxkcylcbiAgfTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50bEZpZWxkQ2FjaGUoZSkge1xuICByZXR1cm4gb24oKG4gPT4ge1xuICAgIGNvbnN0IHQgPSBpc29Ub0Vwb2NoTWlsbGkobik7XG4gICAgcmV0dXJuIGUodCk7XG4gIH0pLCBXZWFrTWFwKTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlSW50bFllYXJEYXRhQ2FjaGUoZSkge1xuICBjb25zdCBuID0gZSgwKS55ZWFyIC0gT3I7XG4gIHJldHVybiBvbigodCA9PiB7XG4gICAgbGV0IG8sIHIgPSBpc29BcmdzVG9FcG9jaE1pbGxpKHQgLSBuKSwgaSA9IDA7XG4gICAgY29uc3QgYSA9IFtdLCBzID0gW107XG4gICAgZG8ge1xuICAgICAgciArPSA0MDAgKiBrbztcbiAgICB9IHdoaWxlICgobyA9IGUocikpLnllYXIgPD0gdCk7XG4gICAgZG8ge1xuICAgICAgaWYgKHIgKz0gKDEgLSBvLmRheSkgKiBrbywgby55ZWFyID09PSB0ICYmIChhLnB1c2gociksIHMucHVzaChvLm8pKSwgciAtPSBrbywgKytpID4gMTAwIHx8IHIgPCAtUHIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZm8pO1xuICAgICAgfVxuICAgIH0gd2hpbGUgKChvID0gZShyKSkueWVhciA+PSB0KTtcbiAgICByZXR1cm4ge1xuICAgICAgaTogYS5yZXZlcnNlKCksXG4gICAgICB1OiBGbyhzLnJldmVyc2UoKSlcbiAgICB9O1xuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHBhcnNlSW50bFllYXIoZSwgbikge1xuICBsZXQgdCwgbywgciA9IHBhcnNlSW50bFBhcnRzWWVhcihlKTtcbiAgaWYgKGUuZXJhKSB7XG4gICAgY29uc3QgaSA9IGlyW25dLCBhID0gYXJbbl0gfHwge307XG4gICAgdm9pZCAwICE9PSBpICYmICh0ID0gXCJpc2xhbWljXCIgPT09IG4gPyBcImFoXCIgOiBlLmVyYS5ub3JtYWxpemUoXCJORkRcIikudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9bXmEtejAtOV0vZywgXCJcIiksIFxuICAgIFwiYmNcIiA9PT0gdCB8fCBcImJcIiA9PT0gdCA/IHQgPSBcImJjZVwiIDogXCJhZFwiID09PSB0IHx8IFwiYVwiID09PSB0ID8gdCA9IFwiY2VcIiA6IFwiYmVmb3Jlcm9jXCIgPT09IHQgJiYgKHQgPSBcImJyb2NcIiksIFxuICAgIHQgPSBhW3RdIHx8IHQsIG8gPSByLCByID0gZXJhWWVhclRvWWVhcihvLCBpW3RdIHx8IDApKTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGVyYTogdCxcbiAgICBlcmFZZWFyOiBvLFxuICAgIHllYXI6IHJcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VJbnRsUGFydHNZZWFyKGUpIHtcbiAgcmV0dXJuIHBhcnNlSW50KGUucmVsYXRlZFllYXIgfHwgZS55ZWFyKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxEYXRlUGFydHMoZSkge1xuICBjb25zdCB7eWVhcjogbiwgbzogdCwgZGF5OiBvfSA9IHRoaXMuaChlKSwge3U6IHJ9ID0gdGhpcy5sKG4pO1xuICByZXR1cm4gWyBuLCByW3RdICsgMSwgbyBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bEVwb2NoTWlsbGkoZSwgbiA9IDEsIHQgPSAxKSB7XG4gIHJldHVybiB0aGlzLmwoZSkuaVtuIC0gMV0gKyAodCAtIDEpICoga287XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRsTW9udGhDb2RlUGFydHMoZSwgbikge1xuICBjb25zdCB0ID0gY29tcHV0ZUludGxMZWFwTW9udGguY2FsbCh0aGlzLCBlKTtcbiAgcmV0dXJuIFsgbW9udGhUb01vbnRoQ29kZU51bWJlcihuLCB0KSwgdCA9PT0gbiBdO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bExlYXBNb250aChlKSB7XG4gIGNvbnN0IG4gPSBxdWVyeU1vbnRoU3RyaW5ncyh0aGlzLCBlKSwgdCA9IHF1ZXJ5TW9udGhTdHJpbmdzKHRoaXMsIGUgLSAxKSwgbyA9IG4ubGVuZ3RoO1xuICBpZiAobyA+IHQubGVuZ3RoKSB7XG4gICAgY29uc3QgZSA9IGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YSh0aGlzKTtcbiAgICBpZiAoZSA8IDApIHtcbiAgICAgIHJldHVybiAtZTtcbiAgICB9XG4gICAgZm9yIChsZXQgZSA9IDA7IGUgPCBvOyBlKyspIHtcbiAgICAgIGlmIChuW2VdICE9PSB0W2VdKSB7XG4gICAgICAgIHJldHVybiBlICsgMTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxEYXlzSW5ZZWFyKGUpIHtcbiAgcmV0dXJuIGRpZmZFcG9jaE1pbGxpQnlEYXkoY29tcHV0ZUludGxFcG9jaE1pbGxpLmNhbGwodGhpcywgZSksIGNvbXB1dGVJbnRsRXBvY2hNaWxsaS5jYWxsKHRoaXMsIGUgKyAxKSk7XG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVJbnRsRGF5c0luTW9udGgoZSwgbikge1xuICBjb25zdCB7aTogdH0gPSB0aGlzLmwoZSk7XG4gIGxldCBvID0gbiArIDEsIHIgPSB0O1xuICByZXR1cm4gbyA+IHQubGVuZ3RoICYmIChvID0gMSwgciA9IHRoaXMubChlICsgMSkuaSksIGRpZmZFcG9jaE1pbGxpQnlEYXkodFtuIC0gMV0sIHJbbyAtIDFdKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZUludGxNb250aHNJblllYXIoZSkge1xuICByZXR1cm4gdGhpcy5sKGUpLmkubGVuZ3RoO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlSW50bEVyYVBhcnRzKGUpIHtcbiAgY29uc3QgbiA9IHRoaXMuaChlKTtcbiAgcmV0dXJuIFsgbi5lcmEsIG4uZXJhWWVhciBdO1xufVxuXG5mdW5jdGlvbiBxdWVyeU1vbnRoU3RyaW5ncyhlLCBuKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhlLmwobikudSk7XG59XG5cbmZ1bmN0aW9uIE10KGUpIHtcbiAgcmV0dXJuIHUobShlKSk7XG59XG5cbmZ1bmN0aW9uIHUoZSkge1xuICBpZiAoKGUgPSBlLnRvTG93ZXJDYXNlKCkpICE9PSBsICYmIGUgIT09IG9yKSB7XG4gICAgY29uc3QgbiA9IENpKGUpLnJlc29sdmVkT3B0aW9ucygpLmNhbGVuZGFyO1xuICAgIGlmIChjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSkgIT09IGNvbXB1dGVDYWxlbmRhcklkQmFzZShuKSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYyhlKSk7XG4gICAgfVxuICAgIHJldHVybiBuO1xuICB9XG4gIHJldHVybiBlO1xufVxuXG5mdW5jdGlvbiBjb21wdXRlQ2FsZW5kYXJJZEJhc2UoZSkge1xuICByZXR1cm4gXCJpc2xhbWljY1wiID09PSBlICYmIChlID0gXCJpc2xhbWljXCIpLCBlLnNwbGl0KFwiLVwiKVswXTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTmF0aXZlT3BzQ3JlYXRvcihlLCBuKSB7XG4gIHJldHVybiB0ID0+IHQgPT09IGwgPyBlIDogdCA9PT0gb3IgfHwgdCA9PT0gcnIgPyBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUoZSksIHtcbiAgICBpZDogdFxuICB9KSA6IE9iamVjdC5hc3NpZ24oT2JqZWN0LmNyZWF0ZShuKSwga2kodCkpO1xufVxuXG5mdW5jdGlvbiAkKGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IHJlZmluZUNhbGVuZGFyRmllbGRzKHQsIG8sIFhvLCBbXSwgeG8pO1xuICBpZiAodm9pZCAwICE9PSByLnRpbWVab25lKSB7XG4gICAgY29uc3QgbyA9IHQuRihyKSwgaSA9IHJlZmluZVRpbWVCYWcociksIGEgPSBlKHIudGltZVpvbmUpO1xuICAgIHJldHVybiB7XG4gICAgICBlcG9jaE5hbm9zZWNvbmRzOiBnZXRNYXRjaGluZ0luc3RhbnRGb3IobihhKSwge1xuICAgICAgICAuLi5vLFxuICAgICAgICAuLi5pXG4gICAgICB9LCB2b2lkIDAgIT09IHIub2Zmc2V0ID8gcGFyc2VPZmZzZXROYW5vKHIub2Zmc2V0KSA6IHZvaWQgMCksXG4gICAgICB0aW1lWm9uZTogYVxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICAuLi50LkYociksXG4gICAgLi4uTnRcbiAgfTtcbn1cblxuZnVuY3Rpb24gTmUoZSwgbiwgdCwgbywgciwgaSkge1xuICBjb25zdCBhID0gcmVmaW5lQ2FsZW5kYXJGaWVsZHModCwgciwgWG8sIGpvLCB4byksIHMgPSBlKGEudGltZVpvbmUpLCBbYywgdSwgZl0gPSBqZShpKSwgbCA9IHQuRihhLCBmYWJyaWNhdGVPdmVyZmxvd09wdGlvbnMoYykpLCBkID0gcmVmaW5lVGltZUJhZyhhLCBjKTtcbiAgcmV0dXJuIF9lKGdldE1hdGNoaW5nSW5zdGFudEZvcihuKHMpLCB7XG4gICAgLi4ubCxcbiAgICAuLi5kXG4gIH0sIHZvaWQgMCAhPT0gYS5vZmZzZXQgPyBwYXJzZU9mZnNldE5hbm8oYS5vZmZzZXQpIDogdm9pZCAwLCB1LCBmKSwgcywgbyk7XG59XG5cbmZ1bmN0aW9uIEF0KGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIFhvLCBbXSwgTyksIHIgPSBtdCh0KTtcbiAgcmV0dXJuIGp0KGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyh7XG4gICAgLi4uZS5GKG8sIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyhyKSksXG4gICAgLi4ucmVmaW5lVGltZUJhZyhvLCByKVxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIG1lKGUsIG4sIHQsIG8gPSBbXSkge1xuICBjb25zdCByID0gcmVmaW5lQ2FsZW5kYXJGaWVsZHMoZSwgbiwgWG8sIG8pO1xuICByZXR1cm4gZS5GKHIsIHQpO1xufVxuXG5mdW5jdGlvbiBYdChlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSByZWZpbmVDYWxlbmRhckZpZWxkcyhlLCBuLCBLbywgbyk7XG4gIHJldHVybiBlLksociwgdCk7XG59XG5cbmZ1bmN0aW9uIFJ0KGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIHQsIFhvLCBKbyk7XG4gIHJldHVybiBuICYmIHZvaWQgMCAhPT0gci5tb250aCAmJiB2b2lkIDAgPT09IHIubW9udGhDb2RlICYmIHZvaWQgMCA9PT0gci55ZWFyICYmIChyLnllYXIgPSBCciksIFxuICBlLl8ociwgbyk7XG59XG5cbmZ1bmN0aW9uIFR0KGUsIG4pIHtcbiAgcmV0dXJuIFN0KHJlZmluZVRpbWVCYWcocmVmaW5lRmllbGRzKGUsIHFvLCBbXSwgMSksIG10KG4pKSk7XG59XG5cbmZ1bmN0aW9uIHEoZSkge1xuICBjb25zdCBuID0gcmVmaW5lRmllbGRzKGUsIHVyKTtcbiAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cyh7XG4gICAgLi4ucHIsXG4gICAgLi4ublxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIHQsIG8gPSBbXSwgciA9IFtdKSB7XG4gIHJldHVybiByZWZpbmVGaWVsZHMobiwgWyAuLi5lLmZpZWxkcyh0KSwgLi4uciBdLnNvcnQoKSwgbyk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZUZpZWxkcyhlLCBuLCB0LCBvID0gIXQpIHtcbiAgY29uc3QgciA9IHt9O1xuICBsZXQgaSwgYSA9IDA7XG4gIGZvciAoY29uc3QgbyBvZiBuKSB7XG4gICAgaWYgKG8gPT09IGkpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKGR1cGxpY2F0ZUZpZWxkcyhvKSk7XG4gICAgfVxuICAgIGlmIChcImNvbnN0cnVjdG9yXCIgPT09IG8gfHwgXCJfX3Byb3RvX19cIiA9PT0gbykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoZm9yYmlkZGVuRmllbGQobykpO1xuICAgIH1cbiAgICBsZXQgbiA9IGVbb107XG4gICAgaWYgKHZvaWQgMCAhPT0gbikge1xuICAgICAgYSA9IDEsIExpW29dICYmIChuID0gTGlbb10obiwgbykpLCByW29dID0gbjtcbiAgICB9IGVsc2UgaWYgKHQpIHtcbiAgICAgIGlmICh0LmluY2x1ZGVzKG8pKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IobWlzc2luZ0ZpZWxkKG8pKTtcbiAgICAgIH1cbiAgICAgIHJbb10gPSB0cltvXTtcbiAgICB9XG4gICAgaSA9IG87XG4gIH1cbiAgaWYgKG8gJiYgIWEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG5vVmFsaWRGaWVsZHMobikpO1xuICB9XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiByZWZpbmVUaW1lQmFnKGUsIG4pIHtcbiAgcmV0dXJuIGNvbnN0cmFpbklzb1RpbWVGaWVsZHMoeGkoe1xuICAgIC4uLnRyLFxuICAgIC4uLmVcbiAgfSksIG4pO1xufVxuXG5mdW5jdGlvbiBEZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IHtjYWxlbmRhcjogaSwgdGltZVpvbmU6IGF9ID0gdCwgcyA9IGUoaSksIGMgPSBuKGEpLCB1ID0gWyAuLi5zLmZpZWxkcyhYbyksIC4uLkxvIF0uc29ydCgpLCBmID0gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBoZShlLCBMKSwgdCA9IFNlKG4ub2Zmc2V0TmFub3NlY29uZHMpLCBvID0gamkoZS5jYWxlbmRhciksIFtyLCBpLCBhXSA9IG8udihuKSwgW3MsIGNdID0gby5xKHIsIGkpLCB1ID0gZm9ybWF0TW9udGhDb2RlKHMsIGMpO1xuICAgIHJldHVybiB7XG4gICAgICAuLi4kaShuKSxcbiAgICAgIHllYXI6IHIsXG4gICAgICBtb250aENvZGU6IHUsXG4gICAgICBkYXk6IGEsXG4gICAgICBvZmZzZXQ6IHRcbiAgICB9O1xuICB9KSh0KSwgbCA9IHJlZmluZUZpZWxkcyhvLCB1KSwgZCA9IHMuayhmLCBsKSwgbSA9IHtcbiAgICAuLi5mLFxuICAgIC4uLmxcbiAgfSwgW3AsIGgsIGddID0gamUociwgMik7XG4gIHJldHVybiBfZShnZXRNYXRjaGluZ0luc3RhbnRGb3IoYywge1xuICAgIC4uLnMuRihkLCBmYWJyaWNhdGVPdmVyZmxvd09wdGlvbnMocCkpLFxuICAgIC4uLmNvbnN0cmFpbklzb1RpbWVGaWVsZHMoeGkobSksIHApXG4gIH0sIHBhcnNlT2Zmc2V0TmFubyhtLm9mZnNldCksIGgsIGcpLCBhLCBpKTtcbn1cblxuZnVuY3Rpb24gZ3QoZSwgbiwgdCwgbykge1xuICBjb25zdCByID0gZShuLmNhbGVuZGFyKSwgaSA9IFsgLi4uci5maWVsZHMoWG8pLCAuLi5PIF0uc29ydCgpLCBhID0ge1xuICAgIC4uLmNvbXB1dGVEYXRlRXNzZW50aWFscyhzID0gbiksXG4gICAgaG91cjogcy5pc29Ib3VyLFxuICAgIG1pbnV0ZTogcy5pc29NaW51dGUsXG4gICAgc2Vjb25kOiBzLmlzb1NlY29uZCxcbiAgICBtaWxsaXNlY29uZDogcy5pc29NaWxsaXNlY29uZCxcbiAgICBtaWNyb3NlY29uZDogcy5pc29NaWNyb3NlY29uZCxcbiAgICBuYW5vc2Vjb25kOiBzLmlzb05hbm9zZWNvbmRcbiAgfTtcbiAgdmFyIHM7XG4gIGNvbnN0IGMgPSByZWZpbmVGaWVsZHModCwgaSksIHUgPSBtdChvKSwgZiA9IHIuayhhLCBjKSwgbCA9IHtcbiAgICAuLi5hLFxuICAgIC4uLmNcbiAgfTtcbiAgcmV0dXJuIGp0KGNoZWNrSXNvRGF0ZVRpbWVJbkJvdW5kcyh7XG4gICAgLi4uci5GKGYsIGZhYnJpY2F0ZU92ZXJmbG93T3B0aW9ucyh1KSksXG4gICAgLi4uY29uc3RyYWluSXNvVGltZUZpZWxkcyh4aShsKSwgdSlcbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBlZShlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSBlKG4uY2FsZW5kYXIpLCBpID0gci5maWVsZHMoWG8pLnNvcnQoKSwgYSA9IGNvbXB1dGVEYXRlRXNzZW50aWFscyhuKSwgcyA9IHJlZmluZUZpZWxkcyh0LCBpKSwgYyA9IHIuayhhLCBzKTtcbiAgcmV0dXJuIHIuRihjLCBvKTtcbn1cblxuZnVuY3Rpb24gV3QoZSwgbiwgdCwgbykge1xuICBjb25zdCByID0gZShuLmNhbGVuZGFyKSwgaSA9IHIuZmllbGRzKEtvKS5zb3J0KCksIGEgPSAoZSA9PiB7XG4gICAgY29uc3QgbiA9IGppKGUuY2FsZW5kYXIpLCBbdCwgb10gPSBuLnYoZSksIFtyLCBpXSA9IG4ucSh0LCBvKTtcbiAgICByZXR1cm4ge1xuICAgICAgeWVhcjogdCxcbiAgICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKHIsIGkpXG4gICAgfTtcbiAgfSkobiksIHMgPSByZWZpbmVGaWVsZHModCwgaSksIGMgPSByLmsoYSwgcyk7XG4gIHJldHVybiByLksoYywgbyk7XG59XG5cbmZ1bmN0aW9uIEV0KGUsIG4sIHQsIG8pIHtcbiAgY29uc3QgciA9IGUobi5jYWxlbmRhciksIGkgPSByLmZpZWxkcyhYbykuc29ydCgpLCBhID0gKGUgPT4ge1xuICAgIGNvbnN0IG4gPSBqaShlLmNhbGVuZGFyKSwgW3QsIG8sIHJdID0gbi52KGUpLCBbaSwgYV0gPSBuLnEodCwgbyk7XG4gICAgcmV0dXJuIHtcbiAgICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKGksIGEpLFxuICAgICAgZGF5OiByXG4gICAgfTtcbiAgfSkobiksIHMgPSByZWZpbmVGaWVsZHModCwgaSksIGMgPSByLmsoYSwgcyk7XG4gIHJldHVybiByLl8oYywgbyk7XG59XG5cbmZ1bmN0aW9uIHJ0KGUsIG4sIHQpIHtcbiAgcmV0dXJuIFN0KCgoZSwgbiwgdCkgPT4gcmVmaW5lVGltZUJhZyh7XG4gICAgLi4ubm4ocW8sIGUpLFxuICAgIC4uLnJlZmluZUZpZWxkcyhuLCBxbylcbiAgfSwgbXQodCkpKShlLCBuLCB0KSk7XG59XG5cbmZ1bmN0aW9uIEEoZSwgbikge1xuICByZXR1cm4gT2UoKHQgPSBlLCBvID0gbiwgY2hlY2tEdXJhdGlvblVuaXRzKHtcbiAgICAuLi50LFxuICAgIC4uLnJlZmluZUZpZWxkcyhvLCB1cilcbiAgfSkpKTtcbiAgdmFyIHQsIG87XG59XG5cbmZ1bmN0aW9uIGNvbnZlcnRUb0lzbyhlLCBuLCB0LCBvLCByKSB7XG4gIG4gPSBubih0ID0gZS5maWVsZHModCksIG4pLCBvID0gcmVmaW5lRmllbGRzKG8sIHIgPSBlLmZpZWxkcyhyKSwgW10pO1xuICBsZXQgaSA9IGUuayhuLCBvKTtcbiAgcmV0dXJuIGkgPSByZWZpbmVGaWVsZHMoaSwgWyAuLi50LCAuLi5yIF0uc29ydCgpLCBbXSksIGUuRihpKTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lWWVhcihlLCBuKSB7XG4gIGNvbnN0IHQgPSBnZXRDYWxlbmRhckVyYU9yaWdpbnMoZSksIG8gPSBhcltlLmlkIHx8IFwiXCJdIHx8IHt9O1xuICBsZXQge2VyYTogciwgZXJhWWVhcjogaSwgeWVhcjogYX0gPSBuO1xuICBpZiAodm9pZCAwICE9PSByIHx8IHZvaWQgMCAhPT0gaSkge1xuICAgIGlmICh2b2lkIDAgPT09IHIgfHwgdm9pZCAwID09PSBpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGlvKTtcbiAgICB9XG4gICAgaWYgKCF0KSB7XG4gICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihybyk7XG4gICAgfVxuICAgIGNvbnN0IGUgPSB0W29bcl0gfHwgcl07XG4gICAgaWYgKHZvaWQgMCA9PT0gZSkge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoaW52YWxpZEVyYShyKSk7XG4gICAgfVxuICAgIGNvbnN0IG4gPSBlcmFZZWFyVG9ZZWFyKGksIGUpO1xuICAgIGlmICh2b2lkIDAgIT09IGEgJiYgYSAhPT0gbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoYW8pO1xuICAgIH1cbiAgICBhID0gbjtcbiAgfSBlbHNlIGlmICh2b2lkIDAgPT09IGEpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKG1pc3NpbmdZZWFyKHQpKTtcbiAgfVxuICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gcmVmaW5lTW9udGgoZSwgbiwgdCwgbykge1xuICBsZXQge21vbnRoOiByLCBtb250aENvZGU6IGl9ID0gbjtcbiAgaWYgKHZvaWQgMCAhPT0gaSkge1xuICAgIGNvbnN0IG4gPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICAgIGNvbnN0IHIgPSBlLkwodCksIFtpLCBhXSA9IHBhcnNlTW9udGhDb2RlKG4pO1xuICAgICAgbGV0IHMgPSBtb250aENvZGVOdW1iZXJUb01vbnRoKGksIGEsIHIpO1xuICAgICAgaWYgKGEpIHtcbiAgICAgICAgY29uc3QgbiA9IGdldENhbGVuZGFyTGVhcE1vbnRoTWV0YShlKTtcbiAgICAgICAgaWYgKHZvaWQgMCA9PT0gbikge1xuICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICBpZiAocyA+IG4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgICAgICAgICAgaWYgKDEgPT09IG8pIHtcbiAgICAgICAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IodW8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcy0tO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocyAhPT0gLW4pIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHVvKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHZvaWQgMCA9PT0gciAmJiAxID09PSBvKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcih1byk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcztcbiAgICB9KShlLCBpLCB0LCBvKTtcbiAgICBpZiAodm9pZCAwICE9PSByICYmIHIgIT09IG4pIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKHNvKTtcbiAgICB9XG4gICAgciA9IG4sIG8gPSAxO1xuICB9IGVsc2UgaWYgKHZvaWQgMCA9PT0gcikge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY28pO1xuICB9XG4gIHJldHVybiBjbGFtcEVudGl0eShcIm1vbnRoXCIsIHIsIDEsIGUuQih0KSwgbyk7XG59XG5cbmZ1bmN0aW9uIHJlZmluZURheShlLCBuLCB0LCBvLCByKSB7XG4gIHJldHVybiBjbGFtcFByb3AobiwgXCJkYXlcIiwgMSwgZS5VKG8sIHQpLCByKTtcbn1cblxuZnVuY3Rpb24gc3BsaWNlRmllbGRzKGUsIG4sIHQsIG8pIHtcbiAgbGV0IHIgPSAwO1xuICBjb25zdCBpID0gW107XG4gIGZvciAoY29uc3QgZSBvZiB0KSB7XG4gICAgdm9pZCAwICE9PSBuW2VdID8gciA9IDEgOiBpLnB1c2goZSk7XG4gIH1cbiAgaWYgKE9iamVjdC5hc3NpZ24oZSwgbiksIHIpIHtcbiAgICBmb3IgKGNvbnN0IG4gb2YgbyB8fCBpKSB7XG4gICAgICBkZWxldGUgZVtuXTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcHV0ZURhdGVFc3NlbnRpYWxzKGUpIHtcbiAgY29uc3QgbiA9IGppKGUuY2FsZW5kYXIpLCBbdCwgbywgcl0gPSBuLnYoZSksIFtpLCBhXSA9IG4ucSh0LCBvKTtcbiAgcmV0dXJuIHtcbiAgICB5ZWFyOiB0LFxuICAgIG1vbnRoQ29kZTogZm9ybWF0TW9udGhDb2RlKGksIGEpLFxuICAgIGRheTogclxuICB9O1xufVxuXG5mdW5jdGlvbiBxZShlKSB7XG4gIHJldHVybiB4ZShjaGVja0Vwb2NoTmFub0luQm91bmRzKGJpZ0ludFRvQmlnTmFubyh0b0JpZ0ludChlKSkpKTtcbn1cblxuZnVuY3Rpb24geWUoZSwgbiwgdCwgbywgciA9IGwpIHtcbiAgcmV0dXJuIF9lKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoYmlnSW50VG9CaWdOYW5vKHRvQmlnSW50KHQpKSksIG4obyksIGUocikpO1xufVxuXG5mdW5jdGlvbiBadChuLCB0LCBvLCByLCBpID0gMCwgYSA9IDAsIHMgPSAwLCBjID0gMCwgdSA9IDAsIGYgPSAwLCBkID0gbCkge1xuICByZXR1cm4ganQoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKGNoZWNrSXNvRGF0ZVRpbWVGaWVsZHMoZSh0b0ludGVnZXIsIHppcFByb3BzKFRyLCBbIHQsIG8sIHIsIGksIGEsIHMsIGMsIHUsIGYgXSkpKSksIG4oZCkpO1xufVxuXG5mdW5jdGlvbiB1ZShuLCB0LCBvLCByLCBpID0gbCkge1xuICByZXR1cm4gVyhjaGVja0lzb0RhdGVJbkJvdW5kcyhjaGVja0lzb0RhdGVGaWVsZHMoZSh0b0ludGVnZXIsIHtcbiAgICBpc29ZZWFyOiB0LFxuICAgIGlzb01vbnRoOiBvLFxuICAgIGlzb0RheTogclxuICB9KSkpLCBuKGkpKTtcbn1cblxuZnVuY3Rpb24gUXQoZSwgbiwgdCwgbyA9IGwsIHIgPSAxKSB7XG4gIGNvbnN0IGkgPSB0b0ludGVnZXIobiksIGEgPSB0b0ludGVnZXIodCksIHMgPSBlKG8pO1xuICByZXR1cm4gY3JlYXRlUGxhaW5ZZWFyTW9udGhTbG90cyhjaGVja0lzb1llYXJNb250aEluQm91bmRzKGNoZWNrSXNvRGF0ZUZpZWxkcyh7XG4gICAgaXNvWWVhcjogaSxcbiAgICBpc29Nb250aDogYSxcbiAgICBpc29EYXk6IHRvSW50ZWdlcihyKVxuICB9KSksIHMpO1xufVxuXG5mdW5jdGlvbiBrdChlLCBuLCB0LCBvID0gbCwgciA9IEJyKSB7XG4gIGNvbnN0IGkgPSB0b0ludGVnZXIobiksIGEgPSB0b0ludGVnZXIodCksIHMgPSBlKG8pO1xuICByZXR1cm4gY3JlYXRlUGxhaW5Nb250aERheVNsb3RzKGNoZWNrSXNvRGF0ZUluQm91bmRzKGNoZWNrSXNvRGF0ZUZpZWxkcyh7XG4gICAgaXNvWWVhcjogdG9JbnRlZ2VyKHIpLFxuICAgIGlzb01vbnRoOiBpLFxuICAgIGlzb0RheTogYVxuICB9KSksIHMpO1xufVxuXG5mdW5jdGlvbiB1dChuID0gMCwgdCA9IDAsIG8gPSAwLCByID0gMCwgaSA9IDAsIGEgPSAwKSB7XG4gIHJldHVybiBTdChjb25zdHJhaW5Jc29UaW1lRmllbGRzKGUodG9JbnRlZ2VyLCB6aXBQcm9wcyh3LCBbIG4sIHQsIG8sIHIsIGksIGEgXSkpLCAxKSk7XG59XG5cbmZ1bmN0aW9uIGoobiA9IDAsIHQgPSAwLCBvID0gMCwgciA9IDAsIGkgPSAwLCBhID0gMCwgcyA9IDAsIGMgPSAwLCB1ID0gMCwgZiA9IDApIHtcbiAgcmV0dXJuIE9lKGNoZWNrRHVyYXRpb25Vbml0cyhlKHRvU3RyaWN0SW50ZWdlciwgemlwUHJvcHMocCwgWyBuLCB0LCBvLCByLCBpLCBhLCBzLCBjLCB1LCBmIF0pKSkpO1xufVxuXG5mdW5jdGlvbiBKZShlLCBuLCB0ID0gbCkge1xuICByZXR1cm4gX2UoZS5lcG9jaE5hbm9zZWNvbmRzLCBuLCB0KTtcbn1cblxuZnVuY3Rpb24gYmUoZSkge1xuICByZXR1cm4geGUoZS5lcG9jaE5hbm9zZWNvbmRzKTtcbn1cblxuZnVuY3Rpb24geXQoZSwgbikge1xuICByZXR1cm4ganQoaGUobiwgZSkpO1xufVxuXG5mdW5jdGlvbiBmZShlLCBuKSB7XG4gIHJldHVybiBXKGhlKG4sIGUpKTtcbn1cblxuZnVuY3Rpb24gZHQoZSwgbikge1xuICByZXR1cm4gU3QoaGUobiwgZSkpO1xufVxuXG5mdW5jdGlvbiBidChlLCBuLCB0LCBvKSB7XG4gIGNvbnN0IHIgPSAoKGUsIG4sIHQsIG8pID0+IHtcbiAgICBjb25zdCByID0gKGUgPT4gZWkobm9ybWFsaXplT3B0aW9ucyhlKSkpKG8pO1xuICAgIHJldHVybiBnZXRTaW5nbGVJbnN0YW50Rm9yKGUobiksIHQsIHIpO1xuICB9KShlLCB0LCBuLCBvKTtcbiAgcmV0dXJuIF9lKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMociksIHQsIG4uY2FsZW5kYXIpO1xufVxuXG5mdW5jdGlvbiBhZShlLCBuLCB0LCBvLCByKSB7XG4gIGNvbnN0IGkgPSBlKHIudGltZVpvbmUpLCBhID0gci5wbGFpblRpbWUsIHMgPSB2b2lkIDAgIT09IGEgPyBuKGEpIDogdm9pZCAwLCBjID0gdChpKTtcbiAgbGV0IHU7XG4gIHJldHVybiB1ID0gcyA/IGdldFNpbmdsZUluc3RhbnRGb3IoYywge1xuICAgIC4uLm8sXG4gICAgLi4uc1xuICB9KSA6IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKGMsIHtcbiAgICAuLi5vLFxuICAgIC4uLk50XG4gIH0pLCBfZSh1LCBpLCBvLmNhbGVuZGFyKTtcbn1cblxuZnVuY3Rpb24gaWUoZSwgbiA9IE50KSB7XG4gIHJldHVybiBqdChjaGVja0lzb0RhdGVUaW1lSW5Cb3VuZHMoe1xuICAgIC4uLmUsXG4gICAgLi4ublxuICB9KSk7XG59XG5cbmZ1bmN0aW9uIGxlKGUsIG4sIHQpIHtcbiAgcmV0dXJuICgoZSwgbikgPT4ge1xuICAgIGNvbnN0IHQgPSByZWZpbmVDYWxlbmRhckZpZWxkcyhlLCBuLCBRbyk7XG4gICAgcmV0dXJuIGUuSyh0LCB2b2lkIDApO1xuICB9KShlKG4uY2FsZW5kYXIpLCB0KTtcbn1cblxuZnVuY3Rpb24gc2UoZSwgbiwgdCkge1xuICByZXR1cm4gKChlLCBuKSA9PiB7XG4gICAgY29uc3QgdCA9IHJlZmluZUNhbGVuZGFyRmllbGRzKGUsIG4sIG5yKTtcbiAgICByZXR1cm4gZS5fKHQpO1xuICB9KShlKG4uY2FsZW5kYXIpLCB0KTtcbn1cblxuZnVuY3Rpb24gSHQoZSwgbiwgdCwgbykge1xuICByZXR1cm4gKChlLCBuLCB0KSA9PiBjb252ZXJ0VG9Jc28oZSwgbiwgUW8sIHJlcXVpcmVPYmplY3RMaWtlKHQpLCBKbykpKGUobi5jYWxlbmRhciksIHQsIG8pO1xufVxuXG5mdW5jdGlvbiBWdChlLCBuLCB0LCBvKSB7XG4gIHJldHVybiAoKGUsIG4sIHQpID0+IGNvbnZlcnRUb0lzbyhlLCBuLCBuciwgcmVxdWlyZU9iamVjdExpa2UodCksIEdvKSkoZShuLmNhbGVuZGFyKSwgdCwgbyk7XG59XG5cbmZ1bmN0aW9uICRlKGUpIHtcbiAgcmV0dXJuIHhlKGNoZWNrRXBvY2hOYW5vSW5Cb3VuZHMoR2UodG9TdHJpY3RJbnRlZ2VyKGUpLCBRZSkpKTtcbn1cblxuZnVuY3Rpb24gSGUoZSkge1xuICByZXR1cm4geGUoY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhiaWdJbnRUb0JpZ05hbm8odG9CaWdJbnQoZSkpKSk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnNUcmFuc2Zvcm1lcihlLCBuLCB0KSB7XG4gIGNvbnN0IG8gPSBuZXcgU2V0KHQpO1xuICByZXR1cm4gKHIsIGkpID0+IHtcbiAgICBjb25zdCBhID0gdCAmJiBoYXNBbnlQcm9wc0J5TmFtZShyLCB0KTtcbiAgICBpZiAoIWhhc0FueVByb3BzQnlOYW1lKHIgPSAoKGUsIG4pID0+IHtcbiAgICAgIGNvbnN0IHQgPSB7fTtcbiAgICAgIGZvciAoY29uc3QgbyBpbiBuKSB7XG4gICAgICAgIGUuaGFzKG8pIHx8ICh0W29dID0gbltvXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdDtcbiAgICB9KShvLCByKSwgZSkpIHtcbiAgICAgIGlmIChpICYmIGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgZm9ybWF0dGluZyBvcHRpb25zXCIpO1xuICAgICAgfVxuICAgICAgciA9IHtcbiAgICAgICAgLi4ubixcbiAgICAgICAgLi4uclxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHQgJiYgKHIudGltZVpvbmUgPSBzaSwgWyBcImZ1bGxcIiwgXCJsb25nXCIgXS5pbmNsdWRlcyhyLkopICYmIChyLkogPSBcIm1lZGl1bVwiKSksIFxuICAgIHI7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFEoZSwgbiA9IGFuLCB0ID0gMCkge1xuICBjb25zdCBbbywgLCAsIHJdID0gZTtcbiAgcmV0dXJuIChpLCBhID0gTmEsIC4uLnMpID0+IHtcbiAgICBjb25zdCBjID0gbihyICYmIHIoLi4ucyksIGksIGEsIG8sIHQpLCB1ID0gYy5yZXNvbHZlZE9wdGlvbnMoKTtcbiAgICByZXR1cm4gWyBjLCAuLi50b0Vwb2NoTWlsbGlzKGUsIHUsIHMpIF07XG4gIH07XG59XG5cbmZ1bmN0aW9uIGFuKGUsIG4sIHQsIG8sIHIpIHtcbiAgaWYgKHQgPSBvKHQsIHIpLCBlKSB7XG4gICAgaWYgKHZvaWQgMCAhPT0gdC50aW1lWm9uZSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihTbyk7XG4gICAgfVxuICAgIHQudGltZVpvbmUgPSBlO1xuICB9XG4gIHJldHVybiBuZXcgZW4obiwgdCk7XG59XG5cbmZ1bmN0aW9uIHRvRXBvY2hNaWxsaXMoZSwgbiwgdCkge1xuICBjb25zdCBbLCBvLCByXSA9IGU7XG4gIHJldHVybiB0Lm1hcCgoZSA9PiAoZS5jYWxlbmRhciAmJiAoKGUsIG4sIHQpID0+IHtcbiAgICBpZiAoKHQgfHwgZSAhPT0gbCkgJiYgZSAhPT0gbikge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IobG8pO1xuICAgIH1cbiAgfSkoZS5jYWxlbmRhciwgbi5jYWxlbmRhciwgciksIG8oZSwgbikpKSk7XG59XG5cbmZ1bmN0aW9uIGdlKGUsIG4sIHQpIHtcbiAgY29uc3QgbyA9IG4udGltZVpvbmUsIHIgPSBlKG8pLCBpID0ge1xuICAgIC4uLmhlKG4sIHIpLFxuICAgIC4uLnQgfHwgTnRcbiAgfTtcbiAgbGV0IGE7XG4gIHJldHVybiBhID0gdCA/IGdldE1hdGNoaW5nSW5zdGFudEZvcihyLCBpLCBpLm9mZnNldE5hbm9zZWNvbmRzLCAyKSA6IGdldFN0YXJ0T2ZEYXlJbnN0YW50Rm9yKHIsIGkpLCBcbiAgX2UoYSwgbywgbi5jYWxlbmRhcik7XG59XG5cbmZ1bmN0aW9uIE90KGUsIG4gPSBOdCkge1xuICByZXR1cm4ganQoY2hlY2tJc29EYXRlVGltZUluQm91bmRzKHtcbiAgICAuLi5lLFxuICAgIC4uLm5cbiAgfSkpO1xufVxuXG5mdW5jdGlvbiBwdChlLCBuKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICBjYWxlbmRhcjogblxuICB9O1xufVxuXG5mdW5jdGlvbiBQZShlLCBuKSB7XG4gIHJldHVybiB7XG4gICAgLi4uZSxcbiAgICB0aW1lWm9uZTogblxuICB9O1xufVxuXG5mdW5jdGlvbiB0bihlKSB7XG4gIGNvbnN0IG4gPSBYZSgpO1xuICByZXR1cm4gZXBvY2hOYW5vVG9Jc28obiwgZS5SKG4pKTtcbn1cblxuZnVuY3Rpb24gWGUoKSB7XG4gIHJldHVybiBHZShEYXRlLm5vdygpLCBRZSk7XG59XG5cbmZ1bmN0aW9uIFVlKCkge1xuICByZXR1cm4gdmEgfHwgKHZhID0gKG5ldyBlbikucmVzb2x2ZWRPcHRpb25zKCkudGltZVpvbmUpO1xufVxuXG5jb25zdCBleHBlY3RlZEludGVnZXIgPSAoZSwgbikgPT4gYE5vbi1pbnRlZ2VyICR7ZX06ICR7bn1gLCBleHBlY3RlZFBvc2l0aXZlID0gKGUsIG4pID0+IGBOb24tcG9zaXRpdmUgJHtlfTogJHtufWAsIGV4cGVjdGVkRmluaXRlID0gKGUsIG4pID0+IGBOb24tZmluaXRlICR7ZX06ICR7bn1gLCBmb3JiaWRkZW5CaWdJbnRUb051bWJlciA9IGUgPT4gYENhbm5vdCBjb252ZXJ0IGJpZ2ludCB0byAke2V9YCwgaW52YWxpZEJpZ0ludCA9IGUgPT4gYEludmFsaWQgYmlnaW50OiAke2V9YCwgbm8gPSBcIkNhbm5vdCBjb252ZXJ0IFN5bWJvbCB0byBzdHJpbmdcIiwgb28gPSBcIkludmFsaWQgb2JqZWN0XCIsIG51bWJlck91dE9mUmFuZ2UgPSAoZSwgbiwgdCwgbywgcikgPT4gciA/IG51bWJlck91dE9mUmFuZ2UoZSwgcltuXSwgclt0XSwgcltvXSkgOiBpbnZhbGlkRW50aXR5KGUsIG4pICsgYDsgbXVzdCBiZSBiZXR3ZWVuICR7dH0tJHtvfWAsIGludmFsaWRFbnRpdHkgPSAoZSwgbikgPT4gYEludmFsaWQgJHtlfTogJHtufWAsIG1pc3NpbmdGaWVsZCA9IGUgPT4gYE1pc3NpbmcgJHtlfWAsIGZvcmJpZGRlbkZpZWxkID0gZSA9PiBgSW52YWxpZCBmaWVsZCAke2V9YCwgZHVwbGljYXRlRmllbGRzID0gZSA9PiBgRHVwbGljYXRlIGZpZWxkICR7ZX1gLCBub1ZhbGlkRmllbGRzID0gZSA9PiBcIk5vIHZhbGlkIGZpZWxkczogXCIgKyBlLmpvaW4oKSwgaSA9IFwiSW52YWxpZCBiYWdcIiwgaW52YWxpZENob2ljZSA9IChlLCBuLCB0KSA9PiBpbnZhbGlkRW50aXR5KGUsIG4pICsgXCI7IG11c3QgYmUgXCIgKyBPYmplY3Qua2V5cyh0KS5qb2luKCksIGIgPSBcIkNhbm5vdCB1c2UgdmFsdWVPZlwiLCBhID0gXCJJbnZhbGlkIGNhbGxpbmcgY29udGV4dFwiLCBybyA9IFwiRm9yYmlkZGVuIGVyYS9lcmFZZWFyXCIsIGlvID0gXCJNaXNtYXRjaGluZyBlcmEvZXJhWWVhclwiLCBhbyA9IFwiTWlzbWF0Y2hpbmcgeWVhci9lcmFZZWFyXCIsIGludmFsaWRFcmEgPSBlID0+IGBJbnZhbGlkIGVyYTogJHtlfWAsIG1pc3NpbmdZZWFyID0gZSA9PiBcIk1pc3NpbmcgeWVhclwiICsgKGUgPyBcIi9lcmEvZXJhWWVhclwiIDogXCJcIiksIGludmFsaWRNb250aENvZGUgPSBlID0+IGBJbnZhbGlkIG1vbnRoQ29kZTogJHtlfWAsIHNvID0gXCJNaXNtYXRjaGluZyBtb250aC9tb250aENvZGVcIiwgY28gPSBcIk1pc3NpbmcgbW9udGgvbW9udGhDb2RlXCIsIHVvID0gXCJJbnZhbGlkIGxlYXAgbW9udGhcIiwgZm8gPSBcIkludmFsaWQgcHJvdG9jb2wgcmVzdWx0c1wiLCBjID0gZSA9PiBpbnZhbGlkRW50aXR5KFwiQ2FsZW5kYXJcIiwgZSksIGxvID0gXCJNaXNtYXRjaGluZyBDYWxlbmRhcnNcIiwgRiA9IGUgPT4gaW52YWxpZEVudGl0eShcIlRpbWVab25lXCIsIGUpLCBtbyA9IFwiTWlzbWF0Y2hpbmcgVGltZVpvbmVzXCIsIHBvID0gXCJGb3JiaWRkZW4gSUNVIFRpbWVab25lXCIsIGhvID0gXCJPdXQtb2YtYm91bmRzIG9mZnNldFwiLCBnbyA9IFwiT3V0LW9mLWJvdW5kcyBUaW1lWm9uZSBnYXBcIiwgRG8gPSBcIkludmFsaWQgVGltZVpvbmUgb2Zmc2V0XCIsIFRvID0gXCJBbWJpZ3VvdXMgb2Zmc2V0XCIsIElvID0gXCJPdXQtb2YtYm91bmRzIGRhdGVcIiwgTW8gPSBcIk91dC1vZi1ib3VuZHMgZHVyYXRpb25cIiwgTm8gPSBcIkNhbm5vdCBtaXggZHVyYXRpb24gc2lnbnNcIiwgeW8gPSBcIk1pc3NpbmcgcmVsYXRpdmVUb1wiLCB2byA9IFwiQ2Fubm90IHVzZSBsYXJnZSB1bml0c1wiLCBQbyA9IFwiUmVxdWlyZWQgc21hbGxlc3RVbml0IG9yIGxhcmdlc3RVbml0XCIsIEVvID0gXCJzbWFsbGVzdFVuaXQgPiBsYXJnZXN0VW5pdFwiLCBmYWlsZWRQYXJzZSA9IGUgPT4gYENhbm5vdCBwYXJzZTogJHtlfWAsIGludmFsaWRTdWJzdHJpbmcgPSBlID0+IGBJbnZhbGlkIHN1YnN0cmluZzogJHtlfWAsIHJuID0gZSA9PiBgQ2Fubm90IGZvcm1hdCAke2V9YCwgbG4gPSBcIk1pc21hdGNoaW5nIHR5cGVzIGZvciBmb3JtYXR0aW5nXCIsIFNvID0gXCJDYW5ub3Qgc3BlY2lmeSBUaW1lWm9uZVwiLCBGbyA9IC8qQF9fUFVSRV9fKi8gUHQoZywgKChlLCBuKSA9PiBuKSksIHdvID0gLypAX19QVVJFX18qLyBQdChnLCAoKGUsIG4sIHQpID0+IHQpKSwgYm8gPSAvKkBfX1BVUkVfXyovIFB0KHBhZE51bWJlciwgMiksIE9vID0ge1xuICBuYW5vc2Vjb25kOiAwLFxuICBtaWNyb3NlY29uZDogMSxcbiAgbWlsbGlzZWNvbmQ6IDIsXG4gIHNlY29uZDogMyxcbiAgbWludXRlOiA0LFxuICBob3VyOiA1LFxuICBkYXk6IDYsXG4gIHdlZWs6IDcsXG4gIG1vbnRoOiA4LFxuICB5ZWFyOiA5XG59LCBCbyA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmtleXMoT28pLCBrbyA9IDg2NGU1LCBDbyA9IDFlMywgWW8gPSAxZTMsIFFlID0gMWU2LCBSbyA9IDFlOSwgWm8gPSA2ZTEwLCB6byA9IDM2ZTExLCBVbyA9IDg2NGUxMSwgQW8gPSBbIDEsIFlvLCBRZSwgUm8sIFpvLCB6bywgVW8gXSwgTyA9IC8qQF9fUFVSRV9fKi8gQm8uc2xpY2UoMCwgNiksIHFvID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyhPKSwgV28gPSBbIFwib2Zmc2V0XCIgXSwgam8gPSBbIFwidGltZVpvbmVcIiBdLCBMbyA9IC8qQF9fUFVSRV9fKi8gTy5jb25jYXQoV28pLCB4byA9IC8qQF9fUFVSRV9fKi8gTG8uY29uY2F0KGpvKSwgJG8gPSBbIFwiZXJhXCIsIFwiZXJhWWVhclwiIF0sIEhvID0gLypAX19QVVJFX18qLyAkby5jb25jYXQoWyBcInllYXJcIiBdKSwgR28gPSBbIFwieWVhclwiIF0sIFZvID0gWyBcIm1vbnRoQ29kZVwiIF0sIF9vID0gLypAX19QVVJFX18qLyBbIFwibW9udGhcIiBdLmNvbmNhdChWbyksIEpvID0gWyBcImRheVwiIF0sIEtvID0gLypAX19QVVJFX18qLyBfby5jb25jYXQoR28pLCBRbyA9IC8qQF9fUFVSRV9fKi8gVm8uY29uY2F0KEdvKSwgWG8gPSAvKkBfX1BVUkVfXyovIEpvLmNvbmNhdChLbyksIGVyID0gLypAX19QVVJFX18qLyBKby5jb25jYXQoX28pLCBuciA9IC8qQF9fUFVSRV9fKi8gSm8uY29uY2F0KFZvKSwgdHIgPSAvKkBfX1BVUkVfXyovIHdvKE8sIDApLCBsID0gXCJpc284NjAxXCIsIG9yID0gXCJncmVnb3J5XCIsIHJyID0gXCJqYXBhbmVzZVwiLCBpciA9IHtcbiAgW29yXToge1xuICAgIFwiZ3JlZ29yeS1pbnZlcnNlXCI6IC0xLFxuICAgIGdyZWdvcnk6IDBcbiAgfSxcbiAgW3JyXToge1xuICAgIFwiamFwYW5lc2UtaW52ZXJzZVwiOiAtMSxcbiAgICBqYXBhbmVzZTogMCxcbiAgICBtZWlqaTogMTg2NyxcbiAgICB0YWlzaG86IDE5MTEsXG4gICAgc2hvd2E6IDE5MjUsXG4gICAgaGVpc2VpOiAxOTg4LFxuICAgIHJlaXdhOiAyMDE4XG4gIH0sXG4gIGV0aGlvcGljOiB7XG4gICAgZXRoaW9hYTogMCxcbiAgICBldGhpb3BpYzogNTUwMFxuICB9LFxuICBjb3B0aWM6IHtcbiAgICBcImNvcHRpYy1pbnZlcnNlXCI6IC0xLFxuICAgIGNvcHRpYzogMFxuICB9LFxuICByb2M6IHtcbiAgICBcInJvYy1pbnZlcnNlXCI6IC0xLFxuICAgIHJvYzogMFxuICB9LFxuICBidWRkaGlzdDoge1xuICAgIGJlOiAwXG4gIH0sXG4gIGlzbGFtaWM6IHtcbiAgICBhaDogMFxuICB9LFxuICBpbmRpYW46IHtcbiAgICBzYWthOiAwXG4gIH0sXG4gIHBlcnNpYW46IHtcbiAgICBhcDogMFxuICB9XG59LCBhciA9IHtcbiAgW29yXToge1xuICAgIGJjZTogXCJncmVnb3J5LWludmVyc2VcIixcbiAgICBjZTogXCJncmVnb3J5XCJcbiAgfSxcbiAgW3JyXToge1xuICAgIGJjZTogXCJqYXBhbmVzZS1pbnZlcnNlXCIsXG4gICAgY2U6IFwiamFwYW5lc2VcIlxuICB9LFxuICBldGhpb3BpYzoge1xuICAgIGVyYTA6IFwiZXRoaW9hYVwiLFxuICAgIGVyYTE6IFwiZXRoaW9waWNcIlxuICB9LFxuICBjb3B0aWM6IHtcbiAgICBlcmEwOiBcImNvcHRpYy1pbnZlcnNlXCIsXG4gICAgZXJhMTogXCJjb3B0aWNcIlxuICB9LFxuICByb2M6IHtcbiAgICBicm9jOiBcInJvYy1pbnZlcnNlXCIsXG4gICAgbWluZ3VvOiBcInJvY1wiXG4gIH1cbn0sIHNyID0ge1xuICBjaGluZXNlOiAxMyxcbiAgZGFuZ2k6IDEzLFxuICBoZWJyZXc6IC02XG59LCBtID0gLypAX19QVVJFX18qLyBQdChyZXF1aXJlVHlwZSwgXCJzdHJpbmdcIiksIEQgPSAvKkBfX1BVUkVfXyovIFB0KHJlcXVpcmVUeXBlLCBcImJvb2xlYW5cIiksIGNyID0gLypAX19QVVJFX18qLyBQdChyZXF1aXJlVHlwZSwgXCJudW1iZXJcIiksIHAgPSAvKkBfX1BVUkVfXyovIEJvLm1hcCgoZSA9PiBlICsgXCJzXCIpKSwgdXIgPSAvKkBfX1BVUkVfXyovIHNvcnRTdHJpbmdzKHApLCBmciA9IC8qQF9fUFVSRV9fKi8gcC5zbGljZSgwLCA2KSwgbHIgPSAvKkBfX1BVUkVfXyovIHAuc2xpY2UoNiksIGRyID0gLypAX19QVVJFX18qLyBsci5zbGljZSgxKSwgbXIgPSAvKkBfX1BVUkVfXyovIEZvKHApLCBwciA9IC8qQF9fUFVSRV9fKi8gd28ocCwgMCksIGhyID0gLypAX19QVVJFX18qLyB3byhmciwgMCksIGdyID0gLypAX19QVVJFX18qLyBQdCh6ZXJvT3V0UHJvcHMsIHApLCB3ID0gWyBcImlzb05hbm9zZWNvbmRcIiwgXCJpc29NaWNyb3NlY29uZFwiLCBcImlzb01pbGxpc2Vjb25kXCIsIFwiaXNvU2Vjb25kXCIsIFwiaXNvTWludXRlXCIsIFwiaXNvSG91clwiIF0sIERyID0gWyBcImlzb0RheVwiLCBcImlzb01vbnRoXCIsIFwiaXNvWWVhclwiIF0sIFRyID0gLypAX19QVVJFX18qLyB3LmNvbmNhdChEciksIElyID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyhEciksIE1yID0gLypAX19QVVJFX18qLyBzb3J0U3RyaW5ncyh3KSwgTnIgPSAvKkBfX1BVUkVfXyovIHNvcnRTdHJpbmdzKFRyKSwgTnQgPSAvKkBfX1BVUkVfXyovIHdvKE1yLCAwKSwgeXIgPSAvKkBfX1BVUkVfXyovIFB0KHplcm9PdXRQcm9wcywgVHIpLCB2ciA9IDFlOCwgUHIgPSB2ciAqIGtvLCBFciA9IFsgdnIsIDAgXSwgU3IgPSBbIC12ciwgMCBdLCBGciA9IDI3NTc2MCwgd3IgPSAtMjcxODIxLCBlbiA9IEludGwuRGF0ZVRpbWVGb3JtYXQsIGJyID0gXCJlbi1HQlwiLCBPciA9IDE5NzAsIEJyID0gMTk3Miwga3IgPSAxMiwgQ3IgPSAvKkBfX1BVUkVfXyovIGlzb0FyZ3NUb0Vwb2NoTWlsbGkoMTg2OCwgOSwgOCksIFlyID0gLypAX19QVVJFX18qLyBvbihjb21wdXRlSmFwYW5lc2VFcmFQYXJ0cywgV2Vha01hcCksIFJyID0gXCJzbWFsbGVzdFVuaXRcIiwgWnIgPSBcInVuaXRcIiwgenIgPSBcInJvdW5kaW5nSW5jcmVtZW50XCIsIFVyID0gXCJmcmFjdGlvbmFsU2Vjb25kRGlnaXRzXCIsIEFyID0gXCJyZWxhdGl2ZVRvXCIsIHFyID0gXCJkaXJlY3Rpb25cIiwgV3IgPSB7XG4gIGNvbnN0cmFpbjogMCxcbiAgcmVqZWN0OiAxXG59LCBqciA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmtleXMoV3IpLCBMciA9IHtcbiAgY29tcGF0aWJsZTogMCxcbiAgcmVqZWN0OiAxLFxuICBlYXJsaWVyOiAyLFxuICBsYXRlcjogM1xufSwgeHIgPSB7XG4gIHJlamVjdDogMCxcbiAgdXNlOiAxLFxuICBwcmVmZXI6IDIsXG4gIGlnbm9yZTogM1xufSwgJHIgPSB7XG4gIGF1dG86IDAsXG4gIG5ldmVyOiAxLFxuICBjcml0aWNhbDogMixcbiAgYWx3YXlzOiAzXG59LCBIciA9IHtcbiAgYXV0bzogMCxcbiAgbmV2ZXI6IDEsXG4gIGNyaXRpY2FsOiAyXG59LCBHciA9IHtcbiAgYXV0bzogMCxcbiAgbmV2ZXI6IDFcbn0sIFZyID0ge1xuICBmbG9vcjogMCxcbiAgaGFsZkZsb29yOiAxLFxuICBjZWlsOiAyLFxuICBoYWxmQ2VpbDogMyxcbiAgdHJ1bmM6IDQsXG4gIGhhbGZUcnVuYzogNSxcbiAgZXhwYW5kOiA2LFxuICBoYWxmRXhwYW5kOiA3LFxuICBoYWxmRXZlbjogOFxufSwgX3IgPSB7XG4gIHByZXZpb3VzOiAtMSxcbiAgbmV4dDogMVxufSwgSnIgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZVVuaXRPcHRpb24sIFJyKSwgS3IgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZVVuaXRPcHRpb24sIFwibGFyZ2VzdFVuaXRcIiksIFFyID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVVbml0T3B0aW9uLCBaciksIFhyID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVDaG9pY2VPcHRpb24sIFwib3ZlcmZsb3dcIiwgV3IpLCBlaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcImRpc2FtYmlndWF0aW9uXCIsIExyKSwgbmkgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZUNob2ljZU9wdGlvbiwgXCJvZmZzZXRcIiwgeHIpLCB0aSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcImNhbGVuZGFyTmFtZVwiLCAkciksIG9pID0gLypAX19QVVJFX18qLyBQdChyZWZpbmVDaG9pY2VPcHRpb24sIFwidGltZVpvbmVOYW1lXCIsIEhyKSwgcmkgPSAvKkBfX1BVUkVfXyovIFB0KHJlZmluZUNob2ljZU9wdGlvbiwgXCJvZmZzZXRcIiwgR3IpLCBpaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVmaW5lQ2hvaWNlT3B0aW9uLCBcInJvdW5kaW5nTW9kZVwiLCBWciksIFV0ID0gXCJQbGFpblllYXJNb250aFwiLCBxdCA9IFwiUGxhaW5Nb250aERheVwiLCBHID0gXCJQbGFpbkRhdGVcIiwgeCA9IFwiUGxhaW5EYXRlVGltZVwiLCBmdCA9IFwiUGxhaW5UaW1lXCIsIHogPSBcIlpvbmVkRGF0ZVRpbWVcIiwgUmUgPSBcIkluc3RhbnRcIiwgTiA9IFwiRHVyYXRpb25cIiwgYWkgPSBbIE1hdGguZmxvb3IsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGguZmxvb3IoZSkgOiBNYXRoLnJvdW5kKGUpLCBNYXRoLmNlaWwsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGguY2VpbChlKSA6IE1hdGgucm91bmQoZSksIE1hdGgudHJ1bmMsIGUgPT4gaGFzSGFsZihlKSA/IE1hdGgudHJ1bmMoZSkgfHwgMCA6IE1hdGgucm91bmQoZSksIGUgPT4gZSA8IDAgPyBNYXRoLmZsb29yKGUpIDogTWF0aC5jZWlsKGUpLCBlID0+IE1hdGguc2lnbihlKSAqIE1hdGgucm91bmQoTWF0aC5hYnMoZSkpIHx8IDAsIGUgPT4gaGFzSGFsZihlKSA/IChlID0gTWF0aC50cnVuYyhlKSB8fCAwKSArIGUgJSAyIDogTWF0aC5yb3VuZChlKSBdLCBzaSA9IFwiVVRDXCIsIGNpID0gNTE4NGUzLCB1aSA9IC8qQF9fUFVSRV9fKi8gaXNvQXJnc1RvRXBvY2hTZWMoMTg0NyksIGZpID0gLypAX19QVVJFX18qLyBpc29BcmdzVG9FcG9jaFNlYygvKkBfX1BVUkVfXyovICgvKkBfX1BVUkVfXyovIG5ldyBEYXRlKS5nZXRVVENGdWxsWWVhcigpICsgMTApLCBsaSA9IC8wKyQvLCBoZSA9IC8qQF9fUFVSRV9fKi8gb24oX3pvbmVkRXBvY2hTbG90c1RvSXNvLCBXZWFrTWFwKSwgZGkgPSAyICoqIDMyIC0gMSwgTCA9IC8qQF9fUFVSRV9fKi8gb24oKGUgPT4ge1xuICBjb25zdCBuID0gZ2V0VGltZVpvbmVFc3NlbmNlKGUpO1xuICByZXR1cm4gXCJvYmplY3RcIiA9PSB0eXBlb2YgbiA/IG5ldyBJbnRsVGltZVpvbmUobikgOiBuZXcgRml4ZWRUaW1lWm9uZShuIHx8IDApO1xufSkpO1xuXG5jbGFzcyBGaXhlZFRpbWVab25lIHtcbiAgY29uc3RydWN0b3IoZSkge1xuICAgIHRoaXMuJCA9IGU7XG4gIH1cbiAgUigpIHtcbiAgICByZXR1cm4gdGhpcy4kO1xuICB9XG4gIEkoZSkge1xuICAgIHJldHVybiAoZSA9PiB7XG4gICAgICBjb25zdCBuID0gaXNvVG9FcG9jaE5hbm8oe1xuICAgICAgICAuLi5lLFxuICAgICAgICAuLi5OdFxuICAgICAgfSk7XG4gICAgICBpZiAoIW4gfHwgTWF0aC5hYnMoblswXSkgPiAxZTgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoSW8pO1xuICAgICAgfVxuICAgIH0pKGUpLCBbIGlzb1RvRXBvY2hOYW5vV2l0aE9mZnNldChlLCB0aGlzLiQpIF07XG4gIH1cbiAgTygpIHt9XG59XG5cbmNsYXNzIEludGxUaW1lWm9uZSB7XG4gIGNvbnN0cnVjdG9yKGUpIHtcbiAgICB0aGlzLm5uID0gKGUgPT4ge1xuICAgICAgZnVuY3Rpb24gZ2V0T2Zmc2V0U2VjKGUpIHtcbiAgICAgICAgY29uc3QgaSA9IGNsYW1wTnVtYmVyKGUsIG8sIHIpLCBbYSwgc10gPSBjb21wdXRlUGVyaW9kKGkpLCBjID0gbihhKSwgdSA9IG4ocyk7XG4gICAgICAgIHJldHVybiBjID09PSB1ID8gYyA6IHBpbmNoKHQoYSwgcyksIGMsIHUsIGUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb24gcGluY2gobiwgdCwgbywgcikge1xuICAgICAgICBsZXQgaSwgYTtcbiAgICAgICAgZm9yICg7KHZvaWQgMCA9PT0gciB8fCB2b2lkIDAgPT09IChpID0gciA8IG5bMF0gPyB0IDogciA+PSBuWzFdID8gbyA6IHZvaWQgMCkpICYmIChhID0gblsxXSAtIG5bMF0pOyApIHtcbiAgICAgICAgICBjb25zdCB0ID0gblswXSArIE1hdGguZmxvb3IoYSAvIDIpO1xuICAgICAgICAgIGUodCkgPT09IG8gPyBuWzFdID0gdCA6IG5bMF0gPSB0ICsgMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG4gPSBvbihlKSwgdCA9IG9uKGNyZWF0ZVNwbGl0VHVwbGUpO1xuICAgICAgbGV0IG8gPSB1aSwgciA9IGZpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdG4oZSkge1xuICAgICAgICAgIGNvbnN0IG4gPSBnZXRPZmZzZXRTZWMoZSAtIDg2NDAwKSwgdCA9IGdldE9mZnNldFNlYyhlICsgODY0MDApLCBvID0gZSAtIG4sIHIgPSBlIC0gdDtcbiAgICAgICAgICBpZiAobiA9PT0gdCkge1xuICAgICAgICAgICAgcmV0dXJuIFsgbyBdO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBpID0gZ2V0T2Zmc2V0U2VjKG8pO1xuICAgICAgICAgIHJldHVybiBpID09PSBnZXRPZmZzZXRTZWMocikgPyBbIGUgLSBpIF0gOiBuID4gdCA/IFsgbywgciBdIDogW107XG4gICAgICAgIH0sXG4gICAgICAgIHJuOiBnZXRPZmZzZXRTZWMsXG4gICAgICAgIE8oZSwgaSkge1xuICAgICAgICAgIGNvbnN0IGEgPSBjbGFtcE51bWJlcihlLCBvLCByKTtcbiAgICAgICAgICBsZXQgW3MsIGNdID0gY29tcHV0ZVBlcmlvZChhKTtcbiAgICAgICAgICBjb25zdCB1ID0gY2kgKiBpLCBmID0gaSA8IDAgPyAoKSA9PiBjID4gbyB8fCAobyA9IGEsIDApIDogKCkgPT4gcyA8IHIgfHwgKHIgPSBhLCBcbiAgICAgICAgICAwKTtcbiAgICAgICAgICBmb3IgKDtmKCk7ICkge1xuICAgICAgICAgICAgY29uc3QgbyA9IG4ocyksIHIgPSBuKGMpO1xuICAgICAgICAgICAgaWYgKG8gIT09IHIpIHtcbiAgICAgICAgICAgICAgY29uc3QgbiA9IHQocywgYyk7XG4gICAgICAgICAgICAgIHBpbmNoKG4sIG8sIHIpO1xuICAgICAgICAgICAgICBjb25zdCBhID0gblswXTtcbiAgICAgICAgICAgICAgaWYgKChjb21wYXJlTnVtYmVycyhhLCBlKSB8fCAxKSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBhO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzICs9IHUsIGMgKz0gdTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgfSkoKGUgPT4gbiA9PiB7XG4gICAgICBjb25zdCB0ID0gaGFzaEludGxGb3JtYXRQYXJ0cyhlLCBuICogQ28pO1xuICAgICAgcmV0dXJuIGlzb0FyZ3NUb0Vwb2NoU2VjKHBhcnNlSW50bFBhcnRzWWVhcih0KSwgcGFyc2VJbnQodC5tb250aCksIHBhcnNlSW50KHQuZGF5KSwgcGFyc2VJbnQodC5ob3VyKSwgcGFyc2VJbnQodC5taW51dGUpLCBwYXJzZUludCh0LnNlY29uZCkpIC0gbjtcbiAgICB9KShlKSk7XG4gIH1cbiAgUihlKSB7XG4gICAgcmV0dXJuIHRoaXMubm4ucm4oKGUgPT4gZXBvY2hOYW5vVG9TZWNNb2QoZSlbMF0pKGUpKSAqIFJvO1xuICB9XG4gIEkoZSkge1xuICAgIGNvbnN0IFtuLCB0XSA9IFsgaXNvQXJnc1RvRXBvY2hTZWMoKG8gPSBlKS5pc29ZZWFyLCBvLmlzb01vbnRoLCBvLmlzb0RheSwgby5pc29Ib3VyLCBvLmlzb01pbnV0ZSwgby5pc29TZWNvbmQpLCBvLmlzb01pbGxpc2Vjb25kICogUWUgKyBvLmlzb01pY3Jvc2Vjb25kICogWW8gKyBvLmlzb05hbm9zZWNvbmQgXTtcbiAgICB2YXIgbztcbiAgICByZXR1cm4gdGhpcy5ubi50bihuKS5tYXAoKGUgPT4gY2hlY2tFcG9jaE5hbm9JbkJvdW5kcyhtb3ZlQmlnTmFubyhHZShlLCBSbyksIHQpKSkpO1xuICB9XG4gIE8oZSwgbikge1xuICAgIGNvbnN0IFt0LCBvXSA9IGVwb2NoTmFub1RvU2VjTW9kKGUpLCByID0gdGhpcy5ubi5PKHQgKyAobiA+IDAgfHwgbyA/IDEgOiAwKSwgbik7XG4gICAgaWYgKHZvaWQgMCAhPT0gcikge1xuICAgICAgcmV0dXJuIEdlKHIsIFJvKTtcbiAgICB9XG4gIH1cbn1cblxuY29uc3QgbWkgPSBcIihbKy1dKVwiLCBwaSA9IFwiKD86Wy4sXShcXFxcZHsxLDl9KSk/XCIsIGhpID0gYCg/Oig/OiR7bWl9KFxcXFxkezZ9KSl8KFxcXFxkezR9KSktPyhcXFxcZHsyfSlgLCBnaSA9IFwiKFxcXFxkezJ9KSg/Ojo/KFxcXFxkezJ9KSg/Ojo/KFxcXFxkezJ9KVwiICsgcGkgKyBcIik/KT9cIiwgRGkgPSBtaSArIGdpLCBUaSA9IGhpICsgXCItPyhcXFxcZHsyfSkoPzpbVCBdXCIgKyBnaSArIFwiKFp8XCIgKyBEaSArIFwiKT8pP1wiLCBJaSA9IFwiXFxcXFsoIT8pKFteXFxcXF1dKilcXFxcXVwiLCBNaSA9IGAoKD86JHtJaX0pezAsOX0pYCwgTmkgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlZ0V4cChoaSArIE1pKSwgeWkgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZVJlZ0V4cChcIig/Oi0tKT8oXFxcXGR7Mn0pLT8oXFxcXGR7Mn0pXCIgKyBNaSksIHZpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoVGkgKyBNaSksIFBpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoXCJUP1wiICsgZ2kgKyBcIig/OlwiICsgRGkgKyBcIik/XCIgKyBNaSksIEVpID0gLypAX19QVVJFX18qLyBjcmVhdGVSZWdFeHAoRGkpLCBTaSA9IC8qQF9fUFVSRV9fKi8gbmV3IFJlZ0V4cChJaSwgXCJnXCIpLCBGaSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlUmVnRXhwKGAke21pfT9QKFxcXFxkK1kpPyhcXFxcZCtNKT8oXFxcXGQrVyk/KFxcXFxkK0QpPyg/OlQoPzooXFxcXGQrKSR7cGl9SCk/KD86KFxcXFxkKykke3BpfU0pPyg/OihcXFxcZCspJHtwaX1TKT8pP2ApLCB3aSA9IC8qQF9fUFVSRV9fKi8gb24oKGUgPT4gbmV3IGVuKGJyLCB7XG4gIHRpbWVab25lOiBlLFxuICBlcmE6IFwic2hvcnRcIixcbiAgeWVhcjogXCJudW1lcmljXCIsXG4gIG1vbnRoOiBcIm51bWVyaWNcIixcbiAgZGF5OiBcIm51bWVyaWNcIixcbiAgaG91cjogXCJudW1lcmljXCIsXG4gIG1pbnV0ZTogXCJudW1lcmljXCIsXG4gIHNlY29uZDogXCJudW1lcmljXCJcbn0pKSksIGJpID0gL14oQUN8QUV8QUd8QVJ8QVN8QkV8QlN8Q0F8Q058Q1N8Q1R8RUF8RUN8SUV8SVN8SlN8TUl8TkV8TlN8UEx8UE58UFJ8UFN8U1N8VlMpVCQvLCBPaSA9IC9bXlxcd1xcLzorLV0rLywgQmkgPSAvXk0oXFxkezJ9KShMPykkLywga2kgPSAvKkBfX1BVUkVfXyovIG9uKGNyZWF0ZUludGxDYWxlbmRhciksIENpID0gLypAX19QVVJFX18qLyBvbigoZSA9PiBuZXcgZW4oYnIsIHtcbiAgY2FsZW5kYXI6IGUsXG4gIHRpbWVab25lOiBzaSxcbiAgZXJhOiBcInNob3J0XCIsXG4gIHllYXI6IFwibnVtZXJpY1wiLFxuICBtb250aDogXCJzaG9ydFwiLFxuICBkYXk6IFwibnVtZXJpY1wiXG59KSkpLCBZaSA9IHtcbiAgUChlLCBuLCB0KSB7XG4gICAgY29uc3QgbyA9IG10KHQpO1xuICAgIGxldCByLCB7eWVhcnM6IGksIG1vbnRoczogYSwgd2Vla3M6IHMsIGRheXM6IGN9ID0gbjtcbiAgICBpZiAoYyArPSBkdXJhdGlvbkZpZWxkc1RvQmlnTmFubyhuLCA1KVswXSwgaSB8fCBhKSB7XG4gICAgICByID0gKChlLCBuLCB0LCBvLCByKSA9PiB7XG4gICAgICAgIGxldCBbaSwgYSwgc10gPSBlLnYobik7XG4gICAgICAgIGlmICh0KSB7XG4gICAgICAgICAgY29uc3QgW24sIG9dID0gZS5xKGksIGEpO1xuICAgICAgICAgIGkgKz0gdCwgYSA9IG1vbnRoQ29kZU51bWJlclRvTW9udGgobiwgbywgZS5MKGkpKSwgYSA9IGNsYW1wRW50aXR5KFwibW9udGhcIiwgYSwgMSwgZS5CKGkpLCByKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbyAmJiAoW2ksIGFdID0gZS51bihpLCBhLCBvKSksIHMgPSBjbGFtcEVudGl0eShcImRheVwiLCBzLCAxLCBlLlUoaSwgYSksIHIpLCBcbiAgICAgICAgZS5wKGksIGEsIHMpO1xuICAgICAgfSkodGhpcywgZSwgaSwgYSwgbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICghcyAmJiAhYykge1xuICAgICAgICByZXR1cm4gZTtcbiAgICAgIH1cbiAgICAgIHIgPSBpc29Ub0Vwb2NoTWlsbGkoZSk7XG4gICAgfVxuICAgIGlmICh2b2lkIDAgPT09IHIpIHtcbiAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKElvKTtcbiAgICB9XG4gICAgcmV0dXJuIHIgKz0gKDcgKiBzICsgYykgKiBrbywgY2hlY2tJc29EYXRlSW5Cb3VuZHMoZXBvY2hNaWxsaVRvSXNvKHIpKTtcbiAgfSxcbiAgTihlLCBuLCB0KSB7XG4gICAgaWYgKHQgPD0gNykge1xuICAgICAgbGV0IG8gPSAwLCByID0gZGlmZkRheXMoe1xuICAgICAgICAuLi5lLFxuICAgICAgICAuLi5OdFxuICAgICAgfSwge1xuICAgICAgICAuLi5uLFxuICAgICAgICAuLi5OdFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gNyA9PT0gdCAmJiAoW28sIHJdID0gZGl2TW9kVHJ1bmMociwgNykpLCB7XG4gICAgICAgIC4uLnByLFxuICAgICAgICB3ZWVrczogbyxcbiAgICAgICAgZGF5czogclxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgbyA9IHRoaXMudihlKSwgciA9IHRoaXMudihuKTtcbiAgICBsZXQgW2ksIGEsIHNdID0gKChlLCBuLCB0LCBvLCByLCBpLCBhKSA9PiB7XG4gICAgICBsZXQgcyA9IHIgLSBuLCBjID0gaSAtIHQsIHUgPSBhIC0gbztcbiAgICAgIGlmIChzIHx8IGMpIHtcbiAgICAgICAgY29uc3QgZiA9IE1hdGguc2lnbihzIHx8IGMpO1xuICAgICAgICBsZXQgbCA9IGUuVShyLCBpKSwgZCA9IDA7XG4gICAgICAgIGlmIChNYXRoLnNpZ24odSkgPT09IC1mKSB7XG4gICAgICAgICAgY29uc3QgbyA9IGw7XG4gICAgICAgICAgW3IsIGldID0gZS51bihyLCBpLCAtZiksIHMgPSByIC0gbiwgYyA9IGkgLSB0LCBsID0gZS5VKHIsIGkpLCBkID0gZiA8IDAgPyAtbyA6IGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHUgPSBhIC0gTWF0aC5taW4obywgbCkgKyBkLCBzKSB7XG4gICAgICAgICAgY29uc3QgW28sIGFdID0gZS5xKG4sIHQpLCBbdSwgbF0gPSBlLnEociwgaSk7XG4gICAgICAgICAgaWYgKGMgPSB1IC0gbyB8fCBOdW1iZXIobCkgLSBOdW1iZXIoYSksIE1hdGguc2lnbihjKSA9PT0gLWYpIHtcbiAgICAgICAgICAgIGNvbnN0IHQgPSBmIDwgMCAmJiAtZS5CKHIpO1xuICAgICAgICAgICAgcyA9IChyIC09IGYpIC0gbiwgYyA9IGkgLSBtb250aENvZGVOdW1iZXJUb01vbnRoKG8sIGEsIGUuTChyKSkgKyAodCB8fCBlLkIocikpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIFsgcywgYywgdSBdO1xuICAgIH0pKHRoaXMsIC4uLm8sIC4uLnIpO1xuICAgIHJldHVybiA4ID09PSB0ICYmIChhICs9IHRoaXMuY24oaSwgb1swXSksIGkgPSAwKSwge1xuICAgICAgLi4ucHIsXG4gICAgICB5ZWFyczogaSxcbiAgICAgIG1vbnRoczogYSxcbiAgICAgIGRheXM6IHNcbiAgICB9O1xuICB9LFxuICBGKGUsIG4pIHtcbiAgICBjb25zdCB0ID0gbXQobiksIG8gPSByZWZpbmVZZWFyKHRoaXMsIGUpLCByID0gcmVmaW5lTW9udGgodGhpcywgZSwgbywgdCksIGkgPSByZWZpbmVEYXkodGhpcywgZSwgciwgbywgdCk7XG4gICAgcmV0dXJuIFcoY2hlY2tJc29EYXRlSW5Cb3VuZHModGhpcy5WKG8sIHIsIGkpKSwgdGhpcy5pZCB8fCBsKTtcbiAgfSxcbiAgSyhlLCBuKSB7XG4gICAgY29uc3QgdCA9IG10KG4pLCBvID0gcmVmaW5lWWVhcih0aGlzLCBlKSwgciA9IHJlZmluZU1vbnRoKHRoaXMsIGUsIG8sIHQpO1xuICAgIHJldHVybiBjcmVhdGVQbGFpblllYXJNb250aFNsb3RzKGNoZWNrSXNvWWVhck1vbnRoSW5Cb3VuZHModGhpcy5WKG8sIHIsIDEpKSwgdGhpcy5pZCB8fCBsKTtcbiAgfSxcbiAgXyhlLCBuKSB7XG4gICAgY29uc3QgdCA9IG10KG4pO1xuICAgIGxldCBvLCByLCBpLCBhID0gdm9pZCAwICE9PSBlLmVyYVllYXIgfHwgdm9pZCAwICE9PSBlLnllYXIgPyByZWZpbmVZZWFyKHRoaXMsIGUpIDogdm9pZCAwO1xuICAgIGNvbnN0IHMgPSAhdGhpcy5pZDtcbiAgICBpZiAodm9pZCAwID09PSBhICYmIHMgJiYgKGEgPSBCciksIHZvaWQgMCAhPT0gYSkge1xuICAgICAgY29uc3QgbiA9IHJlZmluZU1vbnRoKHRoaXMsIGUsIGEsIHQpO1xuICAgICAgbyA9IHJlZmluZURheSh0aGlzLCBlLCBuLCBhLCB0KTtcbiAgICAgIGNvbnN0IHMgPSB0aGlzLkwoYSk7XG4gICAgICByID0gbW9udGhUb01vbnRoQ29kZU51bWJlcihuLCBzKSwgaSA9IG4gPT09IHM7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmICh2b2lkIDAgPT09IGUubW9udGhDb2RlKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoY28pO1xuICAgICAgfVxuICAgICAgaWYgKFtyLCBpXSA9IHBhcnNlTW9udGhDb2RlKGUubW9udGhDb2RlKSwgdGhpcy5pZCAmJiB0aGlzLmlkICE9PSBvciAmJiB0aGlzLmlkICE9PSBycikge1xuICAgICAgICBpZiAodGhpcy5pZCAmJiBcImNvcHRpY1wiID09PSBjb21wdXRlQ2FsZW5kYXJJZEJhc2UodGhpcy5pZCkgJiYgMCA9PT0gdCkge1xuICAgICAgICAgIGNvbnN0IG4gPSBpIHx8IDEzICE9PSByID8gMzAgOiA2O1xuICAgICAgICAgIG8gPSBlLmRheSwgbyA9IGNsYW1wTnVtYmVyKG8sIDEsIG4pO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuaWQgJiYgXCJjaGluZXNlXCIgPT09IGNvbXB1dGVDYWxlbmRhcklkQmFzZSh0aGlzLmlkKSAmJiAwID09PSB0KSB7XG4gICAgICAgICAgY29uc3QgbiA9ICFpIHx8IDEgIT09IHIgJiYgOSAhPT0gciAmJiAxMCAhPT0gciAmJiAxMSAhPT0gciAmJiAxMiAhPT0gciA/IDMwIDogMjk7XG4gICAgICAgICAgbyA9IGUuZGF5LCBvID0gY2xhbXBOdW1iZXIobywgMSwgbik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbyA9IGUuZGF5O1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvID0gcmVmaW5lRGF5KHRoaXMsIGUsIHJlZmluZU1vbnRoKHRoaXMsIGUsIEJyLCB0KSwgQnIsIHQpO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjID0gdGhpcy5HKHIsIGksIG8pO1xuICAgIGlmICghYykge1xuICAgICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJDYW5ub3QgZ3Vlc3MgeWVhclwiKTtcbiAgICB9XG4gICAgY29uc3QgW3UsIGZdID0gYztcbiAgICByZXR1cm4gY3JlYXRlUGxhaW5Nb250aERheVNsb3RzKGNoZWNrSXNvRGF0ZUluQm91bmRzKHRoaXMuVih1LCBmLCBvKSksIHRoaXMuaWQgfHwgbCk7XG4gIH0sXG4gIGZpZWxkcyhlKSB7XG4gICAgcmV0dXJuIGdldENhbGVuZGFyRXJhT3JpZ2lucyh0aGlzKSAmJiBlLmluY2x1ZGVzKFwieWVhclwiKSA/IFsgLi4uZSwgLi4uJG8gXSA6IGU7XG4gIH0sXG4gIGsoZSwgbikge1xuICAgIGNvbnN0IHQgPSBPYmplY3QuYXNzaWduKE9iamVjdC5jcmVhdGUobnVsbCksIGUpO1xuICAgIHJldHVybiBzcGxpY2VGaWVsZHModCwgbiwgX28pLCBnZXRDYWxlbmRhckVyYU9yaWdpbnModGhpcykgJiYgKHNwbGljZUZpZWxkcyh0LCBuLCBIbyksIFxuICAgIHRoaXMuaWQgPT09IHJyICYmIHNwbGljZUZpZWxkcyh0LCBuLCBlciwgJG8pKSwgdDtcbiAgfSxcbiAgaW5MZWFwWWVhcihlKSB7XG4gICAgY29uc3QgW25dID0gdGhpcy52KGUpO1xuICAgIHJldHVybiB0aGlzLnNuKG4pO1xuICB9LFxuICBtb250aHNJblllYXIoZSkge1xuICAgIGNvbnN0IFtuXSA9IHRoaXMudihlKTtcbiAgICByZXR1cm4gdGhpcy5CKG4pO1xuICB9LFxuICBkYXlzSW5Nb250aChlKSB7XG4gICAgY29uc3QgW24sIHRdID0gdGhpcy52KGUpO1xuICAgIHJldHVybiB0aGlzLlUobiwgdCk7XG4gIH0sXG4gIGRheXNJblllYXIoZSkge1xuICAgIGNvbnN0IFtuXSA9IHRoaXMudihlKTtcbiAgICByZXR1cm4gdGhpcy5mbihuKTtcbiAgfSxcbiAgZGF5T2ZZZWFyOiBjb21wdXRlTmF0aXZlRGF5T2ZZZWFyLFxuICBlcmEoZSkge1xuICAgIHJldHVybiB0aGlzLmhuKGUpWzBdO1xuICB9LFxuICBlcmFZZWFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5obihlKVsxXTtcbiAgfSxcbiAgbW9udGhDb2RlKGUpIHtcbiAgICBjb25zdCBbbiwgdF0gPSB0aGlzLnYoZSksIFtvLCByXSA9IHRoaXMucShuLCB0KTtcbiAgICByZXR1cm4gZm9ybWF0TW9udGhDb2RlKG8sIHIpO1xuICB9LFxuICBkYXlPZldlZWs6IGNvbXB1dGVJc29EYXlPZldlZWssXG4gIGRheXNJbldlZWsoKSB7XG4gICAgcmV0dXJuIDc7XG4gIH1cbn0sIFJpID0ge1xuICB2OiBjb21wdXRlSXNvRGF0ZVBhcnRzLFxuICBobjogY29tcHV0ZUlzb0VyYVBhcnRzLFxuICBxOiBjb21wdXRlSXNvTW9udGhDb2RlUGFydHNcbn0sIFppID0ge1xuICBkYXlPZlllYXI6IGNvbXB1dGVOYXRpdmVEYXlPZlllYXIsXG4gIHY6IGNvbXB1dGVJc29EYXRlUGFydHMsXG4gIHA6IGlzb0FyZ3NUb0Vwb2NoTWlsbGlcbn0sIHppID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBaaSwge1xuICB3ZWVrT2ZZZWFyOiBjb21wdXRlTmF0aXZlV2Vla09mWWVhcixcbiAgeWVhck9mV2VlazogY29tcHV0ZU5hdGl2ZVllYXJPZldlZWssXG4gIG0oZSkge1xuICAgIGZ1bmN0aW9uIGNvbXB1dGVXZWVrU2hpZnQoZSkge1xuICAgICAgcmV0dXJuICg3IC0gZSA8IG4gPyA3IDogMCkgLSBlO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb21wdXRlV2Vla3NJblllYXIoZSkge1xuICAgICAgY29uc3QgbiA9IGNvbXB1dGVJc29EYXlzSW5ZZWFyKGYgKyBlKSwgdCA9IGUgfHwgMSwgbyA9IGNvbXB1dGVXZWVrU2hpZnQobW9kRmxvb3IoYSArIG4gKiB0LCA3KSk7XG4gICAgICByZXR1cm4gYyA9IChuICsgKG8gLSBzKSAqIHQpIC8gNztcbiAgICB9XG4gICAgY29uc3QgbiA9IHRoaXMuaWQgPyAxIDogNCwgdCA9IGNvbXB1dGVJc29EYXlPZldlZWsoZSksIG8gPSB0aGlzLmRheU9mWWVhcihlKSwgciA9IG1vZEZsb29yKHQgLSAxLCA3KSwgaSA9IG8gLSAxLCBhID0gbW9kRmxvb3IociAtIGksIDcpLCBzID0gY29tcHV0ZVdlZWtTaGlmdChhKTtcbiAgICBsZXQgYywgdSA9IE1hdGguZmxvb3IoKGkgLSBzKSAvIDcpICsgMSwgZiA9IGUuaXNvWWVhcjtcbiAgICByZXR1cm4gdSA/IHUgPiBjb21wdXRlV2Vla3NJblllYXIoMCkgJiYgKHUgPSAxLCBmKyspIDogKHUgPSBjb21wdXRlV2Vla3NJblllYXIoLTEpLCBcbiAgICBmLS0pLCBbIHUsIGYsIGMgXTtcbiAgfVxufSksIFVpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBZaSwgemksIHtcbiAgdjogY29tcHV0ZUlzb0RhdGVQYXJ0cyxcbiAgaG46IGNvbXB1dGVJc29FcmFQYXJ0cyxcbiAgcTogY29tcHV0ZUlzb01vbnRoQ29kZVBhcnRzLFxuICBHKGUsIG4pIHtcbiAgICBpZiAoIW4pIHtcbiAgICAgIHJldHVybiBbIEJyLCBlIF07XG4gICAgfVxuICB9LFxuICBzbjogY29tcHV0ZUlzb0luTGVhcFllYXIsXG4gIEwoKSB7fSxcbiAgQjogY29tcHV0ZUlzb01vbnRoc0luWWVhcixcbiAgY246IGUgPT4gZSAqIGtyLFxuICBVOiBjb21wdXRlSXNvRGF5c0luTW9udGgsXG4gIGZuOiBjb21wdXRlSXNvRGF5c0luWWVhcixcbiAgVjogKGUsIG4sIHQpID0+ICh7XG4gICAgaXNvWWVhcjogZSxcbiAgICBpc29Nb250aDogbixcbiAgICBpc29EYXk6IHRcbiAgfSksXG4gIHA6IGlzb0FyZ3NUb0Vwb2NoTWlsbGksXG4gIHVuOiAoZSwgbiwgdCkgPT4gKGUgKz0gZGl2VHJ1bmModCwga3IpLCAobiArPSBtb2RUcnVuYyh0LCBrcikpIDwgMSA/IChlLS0sIG4gKz0ga3IpIDogbiA+IGtyICYmIChlKyssIFxuICBuIC09IGtyKSwgWyBlLCBuIF0pLFxuICB5ZWFyKGUpIHtcbiAgICByZXR1cm4gZS5pc29ZZWFyO1xuICB9LFxuICBtb250aChlKSB7XG4gICAgcmV0dXJuIGUuaXNvTW9udGg7XG4gIH0sXG4gIGRheTogZSA9PiBlLmlzb0RheVxufSksIEFpID0ge1xuICB2OiBjb21wdXRlSW50bERhdGVQYXJ0cyxcbiAgaG46IGNvbXB1dGVJbnRsRXJhUGFydHMsXG4gIHE6IGNvbXB1dGVJbnRsTW9udGhDb2RlUGFydHNcbn0sIHFpID0ge1xuICBkYXlPZlllYXI6IGNvbXB1dGVOYXRpdmVEYXlPZlllYXIsXG4gIHY6IGNvbXB1dGVJbnRsRGF0ZVBhcnRzLFxuICBwOiBjb21wdXRlSW50bEVwb2NoTWlsbGksXG4gIHdlZWtPZlllYXI6IGNvbXB1dGVOYXRpdmVXZWVrT2ZZZWFyLFxuICB5ZWFyT2ZXZWVrOiBjb21wdXRlTmF0aXZlWWVhck9mV2VlayxcbiAgbSgpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbn0sIFdpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBZaSwgcWksIHtcbiAgdjogY29tcHV0ZUludGxEYXRlUGFydHMsXG4gIGhuOiBjb21wdXRlSW50bEVyYVBhcnRzLFxuICBxOiBjb21wdXRlSW50bE1vbnRoQ29kZVBhcnRzLFxuICBHKGUsIG4sIHQpIHtcbiAgICBjb25zdCBvID0gdGhpcy5pZCAmJiBcImNoaW5lc2VcIiA9PT0gY29tcHV0ZUNhbGVuZGFySWRCYXNlKHRoaXMuaWQpID8gKChlLCBuLCB0KSA9PiB7XG4gICAgICBpZiAobikge1xuICAgICAgICBzd2l0Y2ggKGUpIHtcbiAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICByZXR1cm4gMTY1MTtcblxuICAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTQ3IDogMTc2NTtcblxuICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTY2IDogMTk1NTtcblxuICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTYzIDogMTk0NDtcblxuICAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTcxIDogMTk1MjtcblxuICAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTYwIDogMTk0MTtcblxuICAgICAgICAgY2FzZSA3OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTY4IDogMTkzODtcblxuICAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIHJldHVybiB0IDwgMzAgPyAxOTU3IDogMTcxODtcblxuICAgICAgICAgY2FzZSA5OlxuICAgICAgICAgIHJldHVybiAxODMyO1xuXG4gICAgICAgICBjYXNlIDEwOlxuICAgICAgICAgIHJldHVybiAxODcwO1xuXG4gICAgICAgICBjYXNlIDExOlxuICAgICAgICAgIHJldHVybiAxODE0O1xuXG4gICAgICAgICBjYXNlIDEyOlxuICAgICAgICAgIHJldHVybiAxODkwO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMTk3MjtcbiAgICB9KShlLCBuLCB0KSA6IEJyO1xuICAgIGxldCBbciwgaSwgYV0gPSBjb21wdXRlSW50bERhdGVQYXJ0cy5jYWxsKHRoaXMsIHtcbiAgICAgIGlzb1llYXI6IG8sXG4gICAgICBpc29Nb250aDoga3IsXG4gICAgICBpc29EYXk6IDMxXG4gICAgfSk7XG4gICAgY29uc3QgcyA9IGNvbXB1dGVJbnRsTGVhcE1vbnRoLmNhbGwodGhpcywgciksIGMgPSBpID09PSBzO1xuICAgIDEgPT09IChjb21wYXJlTnVtYmVycyhlLCBtb250aFRvTW9udGhDb2RlTnVtYmVyKGksIHMpKSB8fCBjb21wYXJlTnVtYmVycyhOdW1iZXIobiksIE51bWJlcihjKSkgfHwgY29tcGFyZU51bWJlcnModCwgYSkpICYmIHItLTtcbiAgICBmb3IgKGxldCBvID0gMDsgbyA8IDEwMDsgbysrKSB7XG4gICAgICBjb25zdCBpID0gciAtIG8sIGEgPSBjb21wdXRlSW50bExlYXBNb250aC5jYWxsKHRoaXMsIGkpLCBzID0gbW9udGhDb2RlTnVtYmVyVG9Nb250aChlLCBuLCBhKTtcbiAgICAgIGlmIChuID09PSAocyA9PT0gYSkgJiYgdCA8PSBjb21wdXRlSW50bERheXNJbk1vbnRoLmNhbGwodGhpcywgaSwgcykpIHtcbiAgICAgICAgcmV0dXJuIFsgaSwgcyBdO1xuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgc24oZSkge1xuICAgIGNvbnN0IG4gPSBjb21wdXRlSW50bERheXNJblllYXIuY2FsbCh0aGlzLCBlKTtcbiAgICByZXR1cm4gbiA+IGNvbXB1dGVJbnRsRGF5c0luWWVhci5jYWxsKHRoaXMsIGUgLSAxKSAmJiBuID4gY29tcHV0ZUludGxEYXlzSW5ZZWFyLmNhbGwodGhpcywgZSArIDEpO1xuICB9LFxuICBMOiBjb21wdXRlSW50bExlYXBNb250aCxcbiAgQjogY29tcHV0ZUludGxNb250aHNJblllYXIsXG4gIGNuKGUsIG4pIHtcbiAgICBjb25zdCB0ID0gbiArIGUsIG8gPSBNYXRoLnNpZ24oZSksIHIgPSBvIDwgMCA/IC0xIDogMDtcbiAgICBsZXQgaSA9IDA7XG4gICAgZm9yIChsZXQgZSA9IG47IGUgIT09IHQ7IGUgKz0gbykge1xuICAgICAgaSArPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIGUgKyByKTtcbiAgICB9XG4gICAgcmV0dXJuIGk7XG4gIH0sXG4gIFU6IGNvbXB1dGVJbnRsRGF5c0luTW9udGgsXG4gIGZuOiBjb21wdXRlSW50bERheXNJblllYXIsXG4gIFYoZSwgbiwgdCkge1xuICAgIHJldHVybiBlcG9jaE1pbGxpVG9Jc28oY29tcHV0ZUludGxFcG9jaE1pbGxpLmNhbGwodGhpcywgZSwgbiwgdCkpO1xuICB9LFxuICBwOiBjb21wdXRlSW50bEVwb2NoTWlsbGksXG4gIHVuKGUsIG4sIHQpIHtcbiAgICBpZiAodCkge1xuICAgICAgaWYgKG4gKz0gdCwgIU51bWJlci5pc1NhZmVJbnRlZ2VyKG4pKSB7XG4gICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKElvKTtcbiAgICAgIH1cbiAgICAgIGlmICh0IDwgMCkge1xuICAgICAgICBmb3IgKDtuIDwgMTsgKSB7XG4gICAgICAgICAgbiArPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIC0tZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxldCB0O1xuICAgICAgICBmb3IgKDtuID4gKHQgPSBjb21wdXRlSW50bE1vbnRoc0luWWVhci5jYWxsKHRoaXMsIGUpKTsgKSB7XG4gICAgICAgICAgbiAtPSB0LCBlKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFsgZSwgbiBdO1xuICB9LFxuICB5ZWFyKGUpIHtcbiAgICByZXR1cm4gdGhpcy5oKGUpLnllYXI7XG4gIH0sXG4gIG1vbnRoKGUpIHtcbiAgICBjb25zdCB7eWVhcjogbiwgbzogdH0gPSB0aGlzLmgoZSksIHt1OiBvfSA9IHRoaXMubChuKTtcbiAgICByZXR1cm4gb1t0XSArIDE7XG4gIH0sXG4gIGRheShlKSB7XG4gICAgcmV0dXJuIHRoaXMuaChlKS5kYXk7XG4gIH1cbn0pLCBqaSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlTmF0aXZlT3BzQ3JlYXRvcihSaSwgQWkpLCBDID0gLypAX19QVVJFX18qLyBjcmVhdGVOYXRpdmVPcHNDcmVhdG9yKFVpLCBXaSksIExpID0ge1xuICAuLi57XG4gICAgZXJhOiB0b1N0cmluZ1ZpYVByaW1pdGl2ZSxcbiAgICBlcmFZZWFyOiB0b0ludGVnZXIsXG4gICAgeWVhcjogdG9JbnRlZ2VyLFxuICAgIG1vbnRoOiB0b1Bvc2l0aXZlSW50ZWdlcixcbiAgICBtb250aENvZGUoZSkge1xuICAgICAgY29uc3QgbiA9IHRvU3RyaW5nVmlhUHJpbWl0aXZlKGUpO1xuICAgICAgcmV0dXJuIHBhcnNlTW9udGhDb2RlKG4pLCBuO1xuICAgIH0sXG4gICAgZGF5OiB0b1Bvc2l0aXZlSW50ZWdlclxuICB9LFxuICAuLi4vKkBfX1BVUkVfXyovIHdvKE8sIHRvSW50ZWdlciksXG4gIC4uLi8qQF9fUFVSRV9fKi8gd28ocCwgdG9TdHJpY3RJbnRlZ2VyKSxcbiAgb2Zmc2V0KGUpIHtcbiAgICBjb25zdCBuID0gdG9TdHJpbmdWaWFQcmltaXRpdmUoZSk7XG4gICAgcmV0dXJuIHBhcnNlT2Zmc2V0TmFubyhuKSwgbjtcbiAgfVxufSwgeGkgPSAvKkBfX1BVUkVfXyovIFB0KHJlbWFwUHJvcHMsIE8sIHcpLCAkaSA9IC8qQF9fUFVSRV9fKi8gUHQocmVtYXBQcm9wcywgdywgTyksIEhpID0gXCJudW1lcmljXCIsIEdpID0gWyBcInRpbWVab25lTmFtZVwiIF0sIFZpID0ge1xuICBtb250aDogSGksXG4gIGRheTogSGlcbn0sIF9pID0ge1xuICB5ZWFyOiBIaSxcbiAgbW9udGg6IEhpXG59LCBKaSA9IC8qQF9fUFVSRV9fKi8gT2JqZWN0LmFzc2lnbih7fSwgX2ksIHtcbiAgZGF5OiBIaVxufSksIEtpID0ge1xuICBob3VyOiBIaSxcbiAgbWludXRlOiBIaSxcbiAgc2Vjb25kOiBIaVxufSwgUWkgPSAvKkBfX1BVUkVfXyovIE9iamVjdC5hc3NpZ24oe30sIEppLCBLaSksIFhpID0gLypAX19QVVJFX18qLyBPYmplY3QuYXNzaWduKHt9LCBRaSwge1xuICB0aW1lWm9uZU5hbWU6IFwic2hvcnRcIlxufSksIGVhID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhfaSksIG5hID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhWaSksIHRhID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhKaSksIG9hID0gLypAX19QVVJFX18qLyBPYmplY3Qua2V5cyhLaSksIHJhID0gWyBcImRhdGVTdHlsZVwiIF0sIGlhID0gLypAX19QVVJFX18qLyBlYS5jb25jYXQocmEpLCBhYSA9IC8qQF9fUFVSRV9fKi8gbmEuY29uY2F0KHJhKSwgc2EgPSAvKkBfX1BVUkVfXyovIHRhLmNvbmNhdChyYSwgWyBcIndlZWtkYXlcIiBdKSwgY2EgPSAvKkBfX1BVUkVfXyovIG9hLmNvbmNhdChbIFwiZGF5UGVyaW9kXCIsIFwidGltZVN0eWxlXCIsIFwiZnJhY3Rpb25hbFNlY29uZERpZ2l0c1wiIF0pLCB1YSA9IC8qQF9fUFVSRV9fKi8gc2EuY29uY2F0KGNhKSwgZmEgPSAvKkBfX1BVUkVfXyovIEdpLmNvbmNhdChjYSksIGxhID0gLypAX19QVVJFX18qLyBHaS5jb25jYXQoc2EpLCBkYSA9IC8qQF9fUFVSRV9fKi8gR2kuY29uY2F0KFsgXCJkYXlcIiwgXCJ3ZWVrZGF5XCIgXSwgY2EpLCBtYSA9IC8qQF9fUFVSRV9fKi8gR2kuY29uY2F0KFsgXCJ5ZWFyXCIsIFwid2Vla2RheVwiIF0sIGNhKSwgcGEgPSAvKkBfX1BVUkVfXyovIGNyZWF0ZU9wdGlvbnNUcmFuc2Zvcm1lcih1YSwgUWkpLCBoYSA9IC8qQF9fUFVSRV9fKi8gY3JlYXRlT3B0aW9uc1RyYW5zZm9ybWVyKHVhLCBYaSksIGdhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIodWEsIFFpLCBHaSksIERhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoc2EsIEppLCBmYSksIFRhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoY2EsIEtpLCBsYSksIElhID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoaWEsIF9pLCBkYSksIE1hID0gLypAX19QVVJFX18qLyBjcmVhdGVPcHRpb25zVHJhbnNmb3JtZXIoYWEsIFZpLCBtYSksIE5hID0ge30sIHlhID0gLypAX19QVVJFX18qLyBuZXcgZW4odm9pZCAwLCB7XG4gIGNhbGVuZGFyOiBsXG59KS5yZXNvbHZlZE9wdGlvbnMoKS5jYWxlbmRhciA9PT0gbCwgVSA9IFsgcGEsIEkgXSwgb3QgPSBbIGhhLCBJLCAwLCAoZSwgbikgPT4ge1xuICBjb25zdCB0ID0gZS50aW1lWm9uZTtcbiAgaWYgKG4gJiYgbi50aW1lWm9uZSAhPT0gdCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKG1vKTtcbiAgfVxuICByZXR1cm4gdDtcbn0gXSwgWCA9IFsgZ2EsIGlzb1RvRXBvY2hNaWxsaSBdLCBfID0gWyBEYSwgaXNvVG9FcG9jaE1pbGxpIF0sIHR0ID0gWyBUYSwgZSA9PiBpc29UaW1lRmllbGRzVG9OYW5vKGUpIC8gUWUgXSwgZXQgPSBbIElhLCBpc29Ub0Vwb2NoTWlsbGksIHlhIF0sIG50ID0gWyBNYSwgaXNvVG9FcG9jaE1pbGxpLCB5YSBdO1xuXG5sZXQgdmE7XG5cbmV4cG9ydCB7IE4gYXMgRHVyYXRpb25CcmFuZGluZywgUmUgYXMgSW5zdGFudEJyYW5kaW5nLCBHIGFzIFBsYWluRGF0ZUJyYW5kaW5nLCB4IGFzIFBsYWluRGF0ZVRpbWVCcmFuZGluZywgcXQgYXMgUGxhaW5Nb250aERheUJyYW5kaW5nLCBmdCBhcyBQbGFpblRpbWVCcmFuZGluZywgVXQgYXMgUGxhaW5ZZWFyTW9udGhCcmFuZGluZywgZW4gYXMgUmF3RGF0ZVRpbWVGb3JtYXQsIHogYXMgWm9uZWREYXRlVGltZUJyYW5kaW5nLCBZIGFzIGFic0R1cmF0aW9uLCBFIGFzIGFkZER1cmF0aW9ucywgUHQgYXMgYmluZEFyZ3MsIEsgYXMgY29tcGFyZUR1cmF0aW9ucywgS2UgYXMgY29tcGFyZUluc3RhbnRzLCB0ZSBhcyBjb21wYXJlSXNvRGF0ZUZpZWxkcywgWXQgYXMgY29tcGFyZUlzb0RhdGVUaW1lRmllbGRzLCBEdCBhcyBjb21wYXJlSXNvVGltZUZpZWxkcywgQmUgYXMgY29tcGFyZVpvbmVkRGF0ZVRpbWVzLCBUZSBhcyBjb21wdXRlWm9uZWRIb3Vyc0luRGF5LCB2ZSBhcyBjb21wdXRlWm9uZWRTdGFydE9mRGF5LCBqIGFzIGNvbnN0cnVjdER1cmF0aW9uU2xvdHMsIHFlIGFzIGNvbnN0cnVjdEluc3RhbnRTbG90cywgdWUgYXMgY29uc3RydWN0UGxhaW5EYXRlU2xvdHMsIFp0IGFzIGNvbnN0cnVjdFBsYWluRGF0ZVRpbWVTbG90cywga3QgYXMgY29uc3RydWN0UGxhaW5Nb250aERheVNsb3RzLCB1dCBhcyBjb25zdHJ1Y3RQbGFpblRpbWVTbG90cywgUXQgYXMgY29uc3RydWN0UGxhaW5ZZWFyTW9udGhTbG90cywgeWUgYXMgY29uc3RydWN0Wm9uZWREYXRlVGltZVNsb3RzLCBPZSBhcyBjcmVhdGVEdXJhdGlvblNsb3RzLCBhbiBhcyBjcmVhdGVGb3JtYXRGb3JQcmVwLCBRIGFzIGNyZWF0ZUZvcm1hdFByZXBwZXIsIHQgYXMgY3JlYXRlR2V0dGVyRGVzY3JpcHRvcnMsIHhlIGFzIGNyZWF0ZUluc3RhbnRTbG90cywgciBhcyBjcmVhdGVOYW1lRGVzY3JpcHRvcnMsIEMgYXMgY3JlYXRlTmF0aXZlU3RhbmRhcmRPcHMsIFcgYXMgY3JlYXRlUGxhaW5EYXRlU2xvdHMsIGp0IGFzIGNyZWF0ZVBsYWluRGF0ZVRpbWVTbG90cywgU3QgYXMgY3JlYXRlUGxhaW5UaW1lU2xvdHMsIG4gYXMgY3JlYXRlUHJvcERlc2NyaXB0b3JzLCBvIGFzIGNyZWF0ZVN0cmluZ1RhZ0Rlc2NyaXB0b3JzLCBfZSBhcyBjcmVhdGVab25lZERhdGVUaW1lU2xvdHMsIF8gYXMgZGF0ZUNvbmZpZywgWCBhcyBkYXRlVGltZUNvbmZpZywgRWUgYXMgZGlmZkluc3RhbnRzLCBJdCBhcyBkaWZmUGxhaW5EYXRlVGltZXMsIG9lIGFzIGRpZmZQbGFpbkRhdGVzLCBpdCBhcyBkaWZmUGxhaW5UaW1lcywgenQgYXMgZGlmZlBsYWluWWVhck1vbnRoLCB3ZSBhcyBkaWZmWm9uZWREYXRlVGltZXMsIHAgYXMgZHVyYXRpb25GaWVsZE5hbWVzQXNjLCBBIGFzIGR1cmF0aW9uV2l0aEZpZWxkcywgJGUgYXMgZXBvY2hNaWxsaVRvSW5zdGFudCwgSGUgYXMgZXBvY2hOYW5vVG9JbnN0YW50LCBiIGFzIGZvcmJpZGRlblZhbHVlT2YsIGsgYXMgZm9ybWF0RHVyYXRpb25Jc28sIGtlIGFzIGZvcm1hdEluc3RhbnRJc28sIFNlIGFzIGZvcm1hdE9mZnNldE5hbm8sIGNlIGFzIGZvcm1hdFBsYWluRGF0ZUlzbywgRnQgYXMgZm9ybWF0UGxhaW5EYXRlVGltZUlzbywgSnQgYXMgZm9ybWF0UGxhaW5Nb250aERheUlzbywgY3QgYXMgZm9ybWF0UGxhaW5UaW1lSXNvLCBLdCBhcyBmb3JtYXRQbGFpblllYXJNb250aElzbywgRmUgYXMgZm9ybWF0Wm9uZWREYXRlVGltZUlzbywgWGUgYXMgZ2V0Q3VycmVudEVwb2NoTmFubywgdG4gYXMgZ2V0Q3VycmVudElzb0RhdGVUaW1lLCBVZSBhcyBnZXRDdXJyZW50VGltZVpvbmVJZCwgeSBhcyBnZXREdXJhdGlvbkJsYW5rLCBJIGFzIGdldEVwb2NoTWlsbGksIHYgYXMgZ2V0RXBvY2hOYW5vLCBVIGFzIGluc3RhbnRDb25maWcsIEplIGFzIGluc3RhbnRUb1pvbmVkRGF0ZVRpbWUsIFZlIGFzIGluc3RhbnRzRXF1YWwsIGkgYXMgaW52YWxpZEJhZywgYyBhcyBpbnZhbGlkQ2FsZW5kYXIsIGEgYXMgaW52YWxpZENhbGxpbmdDb250ZXh0LCBybiBhcyBpbnZhbGlkRm9ybWF0VHlwZSwgRiBhcyBpbnZhbGlkVGltZVpvbmUsIHMgYXMgaXNPYmplY3RMaWtlLCBsIGFzIGlzb0NhbGVuZGFySWQsIE50IGFzIGlzb1RpbWVGaWVsZERlZmF1bHRzLCB3IGFzIGlzb1RpbWVGaWVsZE5hbWVzQXNjLCBnIGFzIG1hcFByb3BOYW1lcywgZSBhcyBtYXBQcm9wcywgb24gYXMgbWVtb2l6ZSwgbG4gYXMgbWlzbWF0Y2hpbmdGb3JtYXRUeXBlcywgbnQgYXMgbW9udGhEYXlDb25maWcsIFllIGFzIG1vdmVJbnN0YW50LCBuZSBhcyBtb3ZlUGxhaW5EYXRlLCB3dCBhcyBtb3ZlUGxhaW5EYXRlVGltZSwgYXQgYXMgbW92ZVBsYWluVGltZSwgR3QgYXMgbW92ZVBsYWluWWVhck1vbnRoLCBwZSBhcyBtb3ZlWm9uZWREYXRlVGltZSwgUWUgYXMgbmFub0luTWlsbGksIEIgYXMgbmVnYXRlRHVyYXRpb24sIEdlIGFzIG51bWJlclRvQmlnTmFubywgZiBhcyBwYXJzZUNhbGVuZGFySWQsIFIgYXMgcGFyc2VEdXJhdGlvbiwgV2UgYXMgcGFyc2VJbnN0YW50LCBkZSBhcyBwYXJzZVBsYWluRGF0ZSwgQnQgYXMgcGFyc2VQbGFpbkRhdGVUaW1lLCB4dCBhcyBwYXJzZVBsYWluTW9udGhEYXksIGh0IGFzIHBhcnNlUGxhaW5UaW1lLCBfdCBhcyBwYXJzZVBsYWluWWVhck1vbnRoLCBIIGFzIHBhcnNlUmVsYXRpdmVUb1Nsb3RzLCBaIGFzIHBhcnNlVGltZVpvbmVJZCwgQWUgYXMgcGFyc2Vab25lZERhdGVUaW1lLCBidCBhcyBwbGFpbkRhdGVUaW1lVG9ab25lZERhdGVUaW1lLCBndCBhcyBwbGFpbkRhdGVUaW1lV2l0aEZpZWxkcywgT3QgYXMgcGxhaW5EYXRlVGltZVdpdGhQbGFpblRpbWUsIEN0IGFzIHBsYWluRGF0ZVRpbWVzRXF1YWwsIGllIGFzIHBsYWluRGF0ZVRvUGxhaW5EYXRlVGltZSwgc2UgYXMgcGxhaW5EYXRlVG9QbGFpbk1vbnRoRGF5LCBsZSBhcyBwbGFpbkRhdGVUb1BsYWluWWVhck1vbnRoLCBhZSBhcyBwbGFpbkRhdGVUb1pvbmVkRGF0ZVRpbWUsIGVlIGFzIHBsYWluRGF0ZVdpdGhGaWVsZHMsIHJlIGFzIHBsYWluRGF0ZXNFcXVhbCwgVnQgYXMgcGxhaW5Nb250aERheVRvUGxhaW5EYXRlLCBFdCBhcyBwbGFpbk1vbnRoRGF5V2l0aEZpZWxkcywgTHQgYXMgcGxhaW5Nb250aERheXNFcXVhbCwgcnQgYXMgcGxhaW5UaW1lV2l0aEZpZWxkcywgc3QgYXMgcGxhaW5UaW1lc0VxdWFsLCBIdCBhcyBwbGFpblllYXJNb250aFRvUGxhaW5EYXRlLCBXdCBhcyBwbGFpblllYXJNb250aFdpdGhGaWVsZHMsICR0IGFzIHBsYWluWWVhck1vbnRoc0VxdWFsLCBubiBhcyBwbHVja1Byb3BzLCBMIGFzIHF1ZXJ5TmF0aXZlVGltZVpvbmUsIE10IGFzIHJlZmluZUNhbGVuZGFySWQsIE1lIGFzIHJlZmluZURpcmVjdGlvbk9wdGlvbnMsIHEgYXMgcmVmaW5lRHVyYXRpb25CYWcsICQgYXMgcmVmaW5lTWF5YmVab25lZERhdGVUaW1lQmFnLCBtdCBhcyByZWZpbmVPdmVyZmxvd09wdGlvbnMsIG1lIGFzIHJlZmluZVBsYWluRGF0ZUJhZywgQXQgYXMgcmVmaW5lUGxhaW5EYXRlVGltZUJhZywgUnQgYXMgcmVmaW5lUGxhaW5Nb250aERheUJhZywgVHQgYXMgcmVmaW5lUGxhaW5UaW1lQmFnLCBYdCBhcyByZWZpbmVQbGFpblllYXJNb250aEJhZywgWmUgYXMgcmVmaW5lVGltZVpvbmVJZCwgTmUgYXMgcmVmaW5lWm9uZWREYXRlVGltZUJhZywgamUgYXMgcmVmaW5lWm9uZWRGaWVsZE9wdGlvbnMsIEQgYXMgcmVxdWlyZUJvb2xlYW4sIFQgYXMgcmVxdWlyZUludGVnZXIsIFMgYXMgcmVxdWlyZUludGVnZXJPclVuZGVmaW5lZCwgemUgYXMgcmVxdWlyZU51bWJlcklzSW50ZWdlciwgaCBhcyByZXF1aXJlUG9zaXRpdmVJbnRlZ2VyLCBQIGFzIHJlcXVpcmVQb3NpdGl2ZUludGVnZXJPclVuZGVmaW5lZCwgbSBhcyByZXF1aXJlU3RyaW5nLCBkIGFzIHJlcXVpcmVTdHJpbmdPclVuZGVmaW5lZCwgdSBhcyByZXNvbHZlQ2FsZW5kYXJJZCwgTSBhcyByZXNvbHZlVGltZVpvbmVJZCwgViBhcyByb3VuZER1cmF0aW9uLCBMZSBhcyByb3VuZEluc3RhbnQsIHZ0IGFzIHJvdW5kUGxhaW5EYXRlVGltZSwgbHQgYXMgcm91bmRQbGFpblRpbWUsIEllIGFzIHJvdW5kWm9uZWREYXRlVGltZSwgcHQgYXMgc2xvdHNXaXRoQ2FsZW5kYXJJZCwgUGUgYXMgc2xvdHNXaXRoVGltZVpvbmVJZCwgdHQgYXMgdGltZUNvbmZpZywgTyBhcyB0aW1lRmllbGROYW1lc0FzYywgSiBhcyB0b3RhbER1cmF0aW9uLCBldCBhcyB5ZWFyTW9udGhDb25maWcsIG90IGFzIHpvbmVkQ29uZmlnLCBiZSBhcyB6b25lZERhdGVUaW1lVG9JbnN0YW50LCBmZSBhcyB6b25lZERhdGVUaW1lVG9QbGFpbkRhdGUsIHl0IGFzIHpvbmVkRGF0ZVRpbWVUb1BsYWluRGF0ZVRpbWUsIGR0IGFzIHpvbmVkRGF0ZVRpbWVUb1BsYWluVGltZSwgRGUgYXMgem9uZWREYXRlVGltZVdpdGhGaWVsZHMsIGdlIGFzIHpvbmVkRGF0ZVRpbWVXaXRoUGxhaW5UaW1lLCBDZSBhcyB6b25lZERhdGVUaW1lc0VxdWFsLCBoZSBhcyB6b25lZEVwb2NoU2xvdHNUb0lzbyB9O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/temporal-polyfill/chunks/internal.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/temporal-polyfill/global.esm.js":
/*!******************************************************!*\
  !*** ./node_modules/temporal-polyfill/global.esm.js ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./chunks/classApi.js */ \"(ssr)/./node_modules/temporal-polyfill/chunks/classApi.js\");\n/* harmony import */ var _chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./chunks/internal.js */ \"(ssr)/./node_modules/temporal-polyfill/chunks/internal.js\");\n\n\n\n\nObject.defineProperties(globalThis, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  Temporal: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.Temporal\n})), Object.defineProperties(Intl, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  DateTimeFormat: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.DateTimeFormat\n})), Object.defineProperties(Date.prototype, (0,_chunks_internal_js__WEBPACK_IMPORTED_MODULE_0__.createPropDescriptors)({\n  toTemporalInstant: _chunks_classApi_js__WEBPACK_IMPORTED_MODULE_1__.toTemporalInstant\n}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvdGVtcG9yYWwtcG9seWZpbGwvZ2xvYmFsLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7QUFBcUc7O0FBRW5DOztBQUVsRSxvQ0FBb0MsMEVBQUM7QUFDckMsWUFBWSx5REFBRTtBQUNkLENBQUMsa0NBQWtDLDBFQUFDO0FBQ3BDLGtCQUFrQiwrREFBRTtBQUNwQixDQUFDLDRDQUE0QywwRUFBQztBQUM5QyxxQkFBcUIsa0VBQUU7QUFDdkIsQ0FBQyIsInNvdXJjZXMiOlsiL1VzZXJzL25pa2l0YS9EZXNrdG9wL2ZvY3VzcGhlcmUvbm9kZV9tb2R1bGVzL3RlbXBvcmFsLXBvbHlmaWxsL2dsb2JhbC5lc20uanMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVGVtcG9yYWwgYXMgWG4sIERhdGVUaW1lRm9ybWF0IGFzIF9uLCB0b1RlbXBvcmFsSW5zdGFudCBhcyBqYSB9IGZyb20gXCIuL2NodW5rcy9jbGFzc0FwaS5qc1wiO1xuXG5pbXBvcnQgeyBjcmVhdGVQcm9wRGVzY3JpcHRvcnMgYXMgbiB9IGZyb20gXCIuL2NodW5rcy9pbnRlcm5hbC5qc1wiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhnbG9iYWxUaGlzLCBuKHtcbiAgVGVtcG9yYWw6IFhuXG59KSksIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEludGwsIG4oe1xuICBEYXRlVGltZUZvcm1hdDogX25cbn0pKSwgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRGF0ZS5wcm90b3R5cGUsIG4oe1xuICB0b1RlbXBvcmFsSW5zdGFudDogamFcbn0pKTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/temporal-polyfill/global.esm.js\n");

/***/ })

};
;